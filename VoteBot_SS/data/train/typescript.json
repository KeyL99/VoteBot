{"dataset": [{"target": [3], "doc": ["it would be nice if \" compileroption \" be an object like <tag> instead of an array of string  .", "this be similar to how the grunt plugin , etc", "- what option should not be honor in a", "for example , i do n't know if anyone will ever want \" watch \" to be a default behavior of run tsc under their project directory , so even if", "tsconfig contain \" watch \" it should be ignore"], "issue_sim": [0.19572924077510834, 0.14074347913265228, 0.06424468755722046, 0.4561913311481476, 0.14637404680252075], "prob": [0.7824103832244873, 0.003785469802096486, 0.0007346929633058608, 0.7799898982048035, 0.0007398187881335616]}, {"target": [3], "doc": ["a few question / concern :", "be we not go to be able to specify typescript file in the config file", "perhaps this be something for down the road instead", "this seem a little odd - it be like we be get close to the _ actual _ structure of <tag> , but we be still expect something we have to parse .", "why not just permit the full command line string or a plain object", "for instance , the following could be equivalent :", "and if we really do n't want user to have to a type the whole word , the following could be allow as well :", "in fact , i do n't think it should be a <tag> file , i think it should be something like <tag>", "dot prefix for filename be an  , and now an artifact from indicate hidden file on unix system when filesystem do n't support a ' hidden ' attribute", "let 's just be explicit"], "issue_sim": [-0.067386195063591, 0.4650859236717224, -0.007593400776386261, 0.03836805000901222, 0.31278300285339355, 0.06357668340206146, 0.08463344722986221, 0.308745801448822, 0.32794272899627686, -0.03838268667459488], "prob": [5.770687948825071e-06, 0.0012269522994756699, 2.9034643375780433e-05, 0.3677147626876831, 1.840367986005731e-05, 6.471256347140297e-05, 0.013028237037360668, 0.007993646897375584, 0.024218453094363213, 7.82310453359969e-05]}, {"target": [3], "doc": ["some tool like jake allow both <tag> and <tag> for the \" default file \"", "json could be allow here", "well they do have the nice property of automatically become hide file , and of be a shell convention rather than a filesystem attribute .", "filesystem attribute require support not just from every filesystem the code be go to live on , but also from tooling like version control", "git do n't support they , for example"], "issue_sim": [0.21150735020637512, 0.09964017570018768, 0.27539822459220886, 0.38196510076522827, 0.21328628063201904], "prob": [0.3237728774547577, 0.006302504800260067, 0.306245356798172, 0.29796457290649414, 0.005799169186502695]}, {"target": [5], "doc": ["the idea that you do not need to specify anything", "all file in your folder be part of the compilation", "i can see an \" exclude list \" , but not include", "my preference would be to have the actual structure of ts", "the problem with this be that there be enum value for module and target , and <tag> do not look helpful", "so since we be do a translation step anyways , stick with something standard be simple , like the accrual command line you would use to build on the command line without the tsconfig file .", "i would say , compileroption should just take a string which be the command line , that would be parse"], "issue_sim": [0.02229399047791958, 0.4372752904891968, 0.10405091941356659, 0.19014744460582733, 0.26557791233062744, 0.4047924280166626, 0.36840495467185974], "prob": [0.014933843165636063, 0.007287655025720596, 0.008310550823807716, 0.004721511155366898, 0.06336405128240585, 0.905156672000885, 0.038069240748882294]}, {"target": [8], "doc": ["@mhegazy , thank for raise this", "my preference be for the file to be call <tag>", "visual studio now provide  for these file", "in addition it be possible to  the content", "in vs people tend to use the typescript setting ui in order to change project setting", "since edit a json config file be even easy , i would suspect that the setting in", "csproj will get out of date very soon", "something need to be do about this", "we should n't permit setting to be specify in two place , because that just introduce another potential source of confusion .", "in vs compile a project with setting specify in both", "csproj and the propose <tag> should result in a compilation error", "i also have an additional suggestion", "we should deprecate the <tag> file and permit reference to be specify directly in <tag>", "that way we be not really introduce yet another config file into the mix , but rather replace an exist one"], "issue_sim": [-0.042332351207733154, 0.25182777643203735, 0.2301693856716156, 0.003210637718439102, 0.3460741639137268, 0.23634649813175201, 0.14098435640335083, -0.009554208256304264, 0.045003652572631836, 0.2843940258026123, 0.41177603602409363, 0.030430462211370468, 0.3368251323699951, 0.21246349811553955], "prob": [0.0007225070730783045, 0.006241743918508291, 0.00030526911723427474, 0.000559530162718147, 0.010803104378283024, 0.002278209663927555, 0.0004993207403458655, 0.0004463858203962445, 0.45697325468063354, 0.0005035926587879658, 0.003114895662292838, 0.00018219053163193166, 0.0009908383945003152, 0.05640163645148277]}, {"target": [5], "doc": ["@mhegazy , thank for start work on this", "i have a couple of comment and question", "i be in favor of have a", "alternative name be ts", "i agree with arnavion to store the compiler option as a json object instead of a string", "it ease readability and will ease to manipulate and read the config file from other tool .", "i like the approach of find a config file by walk up the directory structure and then use it", "however from the writeup it be unclear to i what happen if the directory contain the pick config file have a subdirectory that have its own config file", "will it first call tsc with the config file of the sub directory and when finish tsc with the config file of the parent directory exclude the file from the sub directory", "and what do we do if the parent have two subdirectory with a config file", "do we need to specify a build order then", "and +1 to be able to specify an exclude list in the config file"], "issue_sim": [-0.03902236372232437, -0.0682670921087265, 0.0023942887783050537, 0.13641776144504547, 0.3544842004776001, 0.109180748462677, 0.4486461579799652, 0.428640216588974, 0.525489091873169, 0.24337060749530792, 0.2111983597278595, 0.25715675950050354], "prob": [8.704519859747961e-05, 0.0005007273284718394, 5.197497011977248e-05, 1.888874248834327e-05, 0.013256924226880074, 0.2611338198184967, 0.00210648775100708, 0.049243468791246414, 0.030557524412870407, 0.003235960379242897, 0.00012655417958740145, 0.0004129651642870158]}, {"target": [3], "doc": ["@dbaeumer the problem be that if a ' tsconfig", "json ' be adopt it will become the de facto standard for typescript project build configuration , independently of the original purpose and scope of the feature", "it would kill the competition and i be not sure it would benefit in anyway the tooling around typescript", "i seriously would prefer that to never land in typescript than have a solution with limited / incomplete feature set ."], "issue_sim": [0.10157370567321777, 0.34340792894363403, 0.23693005740642548, 0.30589866638183594], "prob": [8.563802111893892e-05, 0.79693204164505, 0.01928926259279251, 0.71722811460495]}, {"target": [0], "doc": ["it might be more logical to give it the type of the property x in a or b."], "issue_sim": [0.2506749629974365], "prob": [0.9990560412406921]}, {"target": [0], "doc": ["the intent be that you do n't use <tag> as an <tag> or a <tag> until you 've use a type assertion or other mechanism to actually \" decide \" which thing <tag> be .", "if we jam on _ all _ the property of <tag> and <tag> , you 'd have a sort of nonsense object -- imagine code like this :", "the other option on the table be to not have those property _ at all _ , but there be concern that this make code like <tag> too annoying to write", "i could n't come up with a more clear way to write this rule ; the paren here be just for explanatory purpose", "consider code like this :"], "issue_sim": [0.368857204914093, 0.31263288855552673, 0.32926636934280396, 0.17905724048614502, 0.15769758820533752], "prob": [0.5620183944702148, 0.2954648435115814, 0.27079203724861145, 0.09790214151144028, 0.0012400884879752994]}, {"target": [4], "doc": ["thank for the clarification @ryancavanaugh", "i be try to think of scenario where lack of paren would be a problem - instinctively i be assume there must be some", "but it be first thing in the morning and i have n't have coffee yet", "- i be sure you guy cover that off", "i really like the \" local meanings of union types \" possible next step which adjust the type of an identifier in conditional block .", "i think this would be really useful", "that say i think the rule that govern how this work need to be very clear", "i be also curious about the ide experience - would hover over the identifier in a conditional block reveal it as , for example , a dog or a cat|dog", "i be hope for the specific type rather than the union in this scenario"], "issue_sim": [-0.03220772743225098, 0.033641766756772995, -0.07016846537590027, 0.00786832720041275, 0.4342472553253174, 0.07175368070602417, 0.02828836813569069, 0.12800787389278412, 0.20572982728481293], "prob": [0.0008751402492634952, 0.30487436056137085, 0.008620626293122768, 0.005822932347655296, 0.06223643571138382, 0.0006165656959638, 0.043067872524261475, 0.5561037063598633, 0.02007736638188362]}, {"target": [2], "doc": ["do we have a special case for <tag>", "should <tag> end up be <tag> , or be it helpful to maintain the <tag>", "i can see this as both useful as well as something that might turn out to be an anti - pattern ."], "issue_sim": [0.16605055332183838, 0.1478709578514099, 0.18120694160461426], "prob": [0.03209517523646355, 0.24438735842704773, 0.758470892906189]}, {"target": [3], "doc": ["@ryancavanaugh \" disjoint property be not present for the purpose of property access", "that be very good , i hope that be how it stay", "i be quite disturbed when i read the quote bit of the first comment here", "the disjoint type should n't have anything the only one of the summand have .", "this be also important for something like intellisense , where you really do n't want to have those non - property list", "this be an awesome feature", "it make typescript the first type - safe real - world imperative language with that kind of power in a type system"], "issue_sim": [0.16942542791366577, 0.02463988959789276, 0.04334134981036186, 0.24180001020431519, 0.19876524806022644, 0.05865124613046646, 0.40654122829437256], "prob": [0.003247648011893034, 0.007422300986945629, 0.018172189593315125, 0.8128858208656311, 0.1754865199327469, 0.00030393031192943454, 0.03241179883480072]}, {"target": [0], "doc": ["side note , i discover that i be use requirejs ' <tag> option wrong , so it be indeed possible to solve the problem in requirejs :", "a typescript solution would still be nice"], "issue_sim": [0.6767479181289673, 0.48874640464782715], "prob": [0.9444326162338257, 0.011084534227848053]}, {"target": [1], "doc": ["lead slash refer to the root directory , so this be an absolute path", "path mapping do not work on absolute or relative path ."], "issue_sim": [0.2296062409877777, 0.2916998267173767], "prob": [0.16996003687381744, 0.43559372425079346]}, {"target": [1], "doc": ["@mhegazy that be not compatible with meteor js which be a very popular javascript application framework", "all that would be require to solve this be a way to override the absolute path behavior for framework that desire it .", "the default could remain but just a flag as i describe in my previous comment would work great"], "issue_sim": [0.3633732199668884, 0.4494413733482361, 0.1756153702735901], "prob": [0.012372707016766071, 0.5818673968315125, 0.33036181330680847]}, {"target": [0], "doc": ["this seem to go against the design goal of typescript because it introduce an opinion about import path should be interpret which be clearly not the same across all javascript framework and platform .", "bare node interpret it this way , sure , but many framework include the popular meteor framework and also user of babel support map the lead slash to mean the project root not filesystem root", "let 's face it , import a file from the filesystem root be about as useful as a cap lock key and we know many people remap that key as well", "and not that i think you should support everything that flow do , but they also support map the lead slash to something else : <url>", "here be some other example of platform that use the lead slash to mean something else :", "if you ca n't tell i really want to use typescript on this project but this be a show - stopper", "thank for consider this"], "issue_sim": [0.4510178565979004, 0.3403612971305847, 0.19024449586868286, 0.18491685390472412, 0.1569119095802307, 0.41836661100387573, -0.016108810901641846], "prob": [0.958676278591156, 0.6344080567359924, 0.8984447717666626, 0.07000868767499924, 0.0006250374135561287, 0.00416608527302742, 0.00017198653949890286]}, {"target": [1], "doc": ["thank for the extra detail", "actually , i just want the compiler to pass it through unchanged as meteor in this case will properly interpret the path in the result js . it implement its own module loader .", "i might have hijack this thread a bit but ideally i just want typescript to find the file in the right location so that it can typecheck everything but i be fine if it just pass the path through unchanged and have the framework handle it at in its exist way at runtime", "so perhaps i should open a different issue for my case as it be somewhat different than the op 's issue"], "issue_sim": [0.0032088463194668293, 0.551830530166626, 0.6001524925231934, 0.12618166208267212], "prob": [0.0038032555021345615, 0.40272340178489685, 0.2463059276342392, 0.0017451680032536387]}, {"target": [7], "doc": ["while you be of course technically correct we could ask ' what do root mean", "in web application this mean the web root", "there be exactly <number> use case where i want to include anything from the root of my system , my build server or my production server", "one could even argue that it be unsafe to allow that", "in any case , to i it make much more sense that <tag> refer to the root of the application", "i however understand that for some other people  <tag> should mean the directory that contain <tag>", "i would recommend you to either allow for extension to influence the resolve process  and  ) or allow the <tag> set to contain absolute path :", "the default behavior can remain the same and from a naive perspective this change do not seem to involve much as test for an absolute path be rather easy : <tag> ."], "issue_sim": [0.012551508843898773, 0.14499717950820923, 0.28177934885025024, 0.04333798214793205, 0.188320130109787, 0.20423395931720734, 0.33287790417671204, 0.3430534601211548], "prob": [0.068691186606884, 0.005252303555607796, 0.16344846785068512, 0.022292058914899826, 0.00847067590802908, 0.009530714713037014, 0.031158559024333954, 0.26917245984077454]}, {"target": [2], "doc": ["it would be nice to type these more strongly but we will need a proposal for some option", "we previously discuss this in some early design meeting on generic and be n't really able to come up with something suitable", "at least use function instead of ' any ' where applicable might be a meaningful improvement .", "see ander 's response here for a similar example : <url>"], "issue_sim": [0.17055311799049377, 0.06746821105480194, 0.1404067724943161, 0.07959683239459991], "prob": [0.011248180642724037, 0.12641902267932892, 0.8989656567573547, 0.0007276330143213272]}, {"target": [0], "doc": ["it seem like the <tag> method of a function just can not return a type value .", "in order to determine the type we have to find a mapping of an array  to a number of tuple", "it can only be do if we know the number of element in the array and their type", "have these <number> thing we can view the array as a tuple", "match tuple to tuple be a solvable problem", "now in order to know the number of element in an array and their type at the compile time it have get to be an array literal", "only in this case we can deduce the type , but restrict <tag> to array literal only would be a significant and pointless limitation", "all this mean that in order to have a type version of apply there have to be a different syntax that take array literal , or just tuple straight , and deduce the type of the result", "in order not to introduce new syntax there can be a type overload of <tag> that take an array literal or just a list of argument as they list in the original function", "even when the original signature of a function match the one of the <tag> method of that function it should not be a problem", "in this case there will be no overload , but just one single way to call it which be what it have now"], "issue_sim": [0.40689435601234436, 0.3611592650413513, 0.29530656337738037, 0.2175266146659851, 0.27373576164245605, 0.4171378016471863, 0.3877948820590973, 0.4898054599761963, 0.5157402753829956, 0.2826193571090698, 0.27624791860580444], "prob": [0.44257599115371704, 0.04217161238193512, 0.003030726918950677, 0.0006798420799896121, 0.00023050284653436393, 0.015018630772829056, 0.005028777290135622, 0.059015560895204544, 0.03809988871216774, 0.025269174948334694, 0.023815937340259552]}, {"target": [1], "doc": ["here be another example i come across where this be an issue :", "the <tag>s be need because of the usage of <tag> , but since <tag> return <tag> , the compiler will error out because of the mismatch of <tag> and <tag> .", "the only solution i could think of be to force the type :"], "issue_sim": [0.019161682575941086, 0.5828933715820312, 0.3406235873699188], "prob": [0.0014089274918660522, 0.9884213209152222, 0.015689918771386147]}, {"target": [2], "doc": ["i find i have a lot of trouble with this issue , as i frequently factor my function so that they contain small helper function", "here be a simplified example to show the structure i use :", "any helper that reference * * this * * must be invoke via call  .. this problem hit i hard when i refactor code , include rename variable , which i do frequently as i come up with well naming .", "i would greatly appreciate it if you could add support for type check the argument of a call", "have too many ambiguity to support type checking )", "edit : to add type helper"], "issue_sim": [0.2268640697002411, 0.23563814163208008, 0.4307527542114258, 0.37768256664276123, 0.25613027811050415, 0.3026607632637024], "prob": [0.1553279459476471, 0.026118099689483643, 0.6754165291786194, 0.002365896012634039, 0.005070443730801344, 0.0006764802383258939]}, {"target": [4], "doc": ["ok how about this as a spec for bind :", "- args which do not match the original function type", "- too many args", "result in compiler error : ' supply parameter do not match any signature of call target", "for an overloaded function where there be ambiguity , ' bind ' should return type any . e.g.", "- a function which be not overload", "- a function which be overload but bind be call unambiguously", "bind return the expect type value :"], "issue_sim": [0.21314874291419983, 0.38573288917541504, 0.06500223278999329, 0.4747951626777649, 0.5708752870559692, 0.25761306285858154, 0.4967477023601532, 0.43003273010253906], "prob": [0.014164536260068417, 0.0077533237636089325, 0.00025147036649286747, 0.0036741201765835285, 0.987825334072113, 0.00034418742870911956, 0.010066057555377483, 0.000622123945504427]}, {"target": [7], "doc": ["@danielrosenwasser could you expand on why you be against my solution for bind", "do you believe your proposal will be well from a user standpoint", "as a typescript user , i want to use bind in an identical way to javascript", "and have it type as per my previous post", "your proposal would not support this", "for example , use your solution ' bind2 ' , the code would look like :", "and even bad for function with more apply args e", "use bind as describe in my proposal be not only more familiar to people who know javascript , but also allow easy transition from untyped javascript code into properly type typescript ."], "issue_sim": [0.2589207887649536, -0.026331758126616478, 0.4660850763320923, 0.06590723991394043, 0.08109773695468903, 0.2944851517677307, 0.1590939313173294, 0.46805649995803833], "prob": [6.096587094361894e-05, 0.001745849964208901, 0.09413094073534012, 0.00023756854352541268, 0.0007431403500959277, 0.009481697343289852, 0.0003072867984883487, 0.8016394972801208]}, {"target": [6], "doc": ["can this be approach in an incremental way", "what i be interested in the use of <tag> for , in most case , be to avoid wrap a callback in an arrow function", "in this circumstance , i be not use <tag> for partial application", "i be use it merely to avoid write code that look like this :", "in this situation , the type should be <tag> , just as <tag> be in the class", "what would need to be add to the compiler , just to achieve this", "i feel like if <tag> be able to take on the exact type of the function it be call from , it would be a start in the right direction .", "partial application could be work in later"], "issue_sim": [0.09135320782661438, 0.31769102811813354, 0.24064797163009644, 0.2791209816932678, 0.2615351974964142, 0.4202640950679779, 0.2429867386817932, 0.041697908192873], "prob": [0.0075057027861475945, 0.20136812329292297, 0.0034563641529530287, 0.010918887332081795, 0.1491670459508896, 0.000723200268112123, 0.9306453466415405, 0.0005790412542410195]}, {"target": [0], "doc": ["i hit the same issue today , the idea be to not rely on transpiling on server side , for example , i want to define my own object type like this , below do not work :", "the editor complain that it do not understand <tag>"], "issue_sim": [0.4179849624633789, 0.022450342774391174], "prob": [0.9503070116043091, 0.012877674773335457]}, {"target": [0], "doc": ["such a workflow would also be brilliant for angular1 app where you may have a main file that inject all your dependency and a separate file that specify your controller .", "the controller file export a function / class", "it receive its dependency but do not inject they directly , be able to tag they use jsdoc as a type that be define in a different file in your workspace would be invaluable there"], "issue_sim": [0.32902467250823975, 0.19404208660125732, 0.31532585620880127], "prob": [0.8412082195281982, 0.0008779510390013456, 0.7826210260391235]}, {"target": [0], "doc": ["have a straightforward way to do this be a must in any decent code design where one need to inject a dependency .", "any update , please"], "issue_sim": [0.4456116855144501, 0.010814154520630836], "prob": [0.9217342138290405, 0.015453348867595196]}, {"target": [1], "doc": ["this issue be encompass in <url>", "so i think it be unlikely to add support for this functionality .", "unfortunately , this make it very difficult to migrate vanilla javascript to typescript type checking while still appease jsdoc stakeholder wary of change since the new syntax break jsdoc execution", "i 've experiment with <tag> syntax but have n't be able to find a substitute that will allow typescript to pull in the jsdoc typing", "if it be support , the <tag> syntax propose by @joma74 or even <tag> by @sergeysova would work for most folk since  allow unknown tag such as <tag>"], "issue_sim": [0.005822545848786831, 0.31845349073410034, 0.3446348309516907, 0.40353822708129883, 0.2652099132537842], "prob": [0.0033824353013187647, 0.38278844952583313, 0.26114168763160706, 0.03405151888728142, 0.26560989022254944]}, {"target": [1], "doc": ["but <tag> already do mean subset", "if i be not mistaken , <tag> be simply typescript 's implementation of bounded quantification .", "do you have a specific example of behavior where you 'd do <tag> for some t not assignable to u"], "issue_sim": [0.12314289063215256, 0.538608729839325, 0.3172321915626526], "prob": [0.005578191485255957, 0.8156588673591614, 0.2740618884563446]}, {"target": [1], "doc": ["tl;dr from design discussion :", "it be somewhat obvious what the \" right \" thing to do be , but would require a large rework of how we treat type parameter , with concordant negative perf impact , without a corresponding large positive impact on the actual user - face behavior side .", "if new pattern emerge that make this more frequently problematic , we can take another look"], "issue_sim": [0.10715717077255249, 0.26681244373321533, 0.1644817590713501], "prob": [0.06380512565374374, 0.9314373731613159, 0.025794627144932747]}, {"target": [1], "doc": ["by use <tag> and <tag> ,", "unfortunately . there be no well way , because while ts will narrow num it won narrow t for you .."], "issue_sim": [0.17404672503471375, 0.28850290179252625], "prob": [0.03175885230302811, 0.9327723383903503]}, {"target": [1], "doc": ["@jhnns this be actually more closely related to another issue i   raise , # <number>", "basically , typescript never consider the narrowing of a _ value _ , e.g. <tag> as inplye anything about the _ type _ , e.g. <tag> , that value have .", "the reason why be this :", "in that function call , <tag> be <tag> , which mean it will pass <tag> and return <tag>", "but the definition of <tag> say that <tag> should be <tag> instead", "such as it be , be to use casting", "whether you do that by define a particular type ( e", "<tag> or by just write out <tag> , either work , but you basically be force to tell the compiler that you have do this right , which mean the compiler can not correct you if you have not , in fact , do it right", "which _ drastically _ limit the value of conditional type , in my opinion , since they will almost - always , necessarily , be unsafe at least within the internal of the function", "and plenty of case where <tag> be <tag> exist , which could be handle safely , but the ts team seem to be uninterested in go down that road"], "issue_sim": [0.20212417840957642, 0.5347994565963745, 0.016484487801790237, 0.43337810039520264, 0.2794496715068817, 0.07770504057407379, 0.27864810824394226, 0.38032323122024536, 0.31738996505737305, 0.38609880208969116], "prob": [0.002704344457015395, 0.2674718201160431, 0.003681291127577424, 0.06607569009065628, 0.02860608883202076, 0.000852925528306514, 0.002626370871439576, 0.2030690461397171, 0.10319028794765472, 0.17313100397586823]}, {"target": [2], "doc": ["as # <number> be close with # <number> now it seem that this issue be out of scope", "do you now have any plan on implement different access modifier", "because <tag> be not enough to solve what be describe here as a property might be actually writable inside a class ."], "issue_sim": [0.22283083200454712, 0.33781009912490845, 0.46805548667907715], "prob": [0.005926191341131926, 0.001719971769489348, 0.9732635021209717]}, {"target": [3], "doc": ["i believe i should also move my example here from related issue :", "here , property <tag> actually * * can * * have a setter but it * * should not be accessable * * outside of   <tag>", "moreover this setter contain complex logic and a simple readonly or an absence of a setter be not enough", "i agree that private setter be just a syntax sugar for private method with additional logic  but i think it be inconsistent when part of logic relate to a field be in a property  and another in a method  .", "this way getter / setter be implement in <tag> , i think it would be usefull to allow different visibility at compile time , though this contract will be lose in runtime"], "issue_sim": [0.19092974066734314, 0.5629433393478394, 0.475005567073822, 0.6204230189323425, 0.68213951587677], "prob": [0.0027780167292803526, 0.18555912375450134, 0.05074365809559822, 0.3258698582649231, 0.10890667885541916]}, {"target": [3], "doc": ["the recommendation here be to use a public readonly getter and a private / protect backing field", "accessors be symetrical with property in the type system", "anything we do will need to be manifest in the type and expressible on property", "add new access modifier to enable private_set / public_get would increase the complexity of the language and the learning curve , and the value gain from this would not match the add complexity ."], "issue_sim": [0.5980881452560425, 0.458168089389801, 0.2236964851617813, 0.28261178731918335], "prob": [0.25713029503822327, 0.01564706303179264, 0.04972417652606964, 0.3790196478366852]}, {"target": [1], "doc": ["this be a good addition to the language : the amount of complexity that this would add  be small .", "the concept be easy to understand and the compiler should be able to provide good error message hint of why you can not access getter or setter due to scope"], "issue_sim": [0.12849393486976624, 0.5191363096237183], "prob": [0.5822470784187317, 0.6302621364593506]}, {"target": [6], "doc": ["i 've be read you guy claim it be too complex", "remember the \" c++ way \" why it be different from :", "i can see a lot of use case for this , that be why i be here right now", "what if i want myattribute to be publicly accessible but allow only to be modify inside its class", "what if i want to add some custom logic each time the attribute be modify", "it can be a business rule , it can be just a logging to understand why it have be assign a specific value , together with a breakpoint condition for debug purpose , etc", "basically , we want a method to be use each time we modify the attribute together with the syntactic sugar that make it seem we be just assign a value , instead than call a method .", "c # have the concept of property for this and i think ts inherit that concept , but not allow different accessibility be a big limitation for people that think like i and make we fall back to the \" c++ style \""], "issue_sim": [0.06612950563430786, 0.18526402115821838, 0.0312538743019104, 0.5437265634536743, 0.39999228715896606, 0.4063326120376587, 0.5205082297325134, 0.46841710805892944], "prob": [0.09760301560163498, 0.013205897063016891, 0.03050186112523079, 0.05291038751602173, 0.0012988857924938202, 0.15991328656673431, 0.18971391022205353, 0.28928542137145996]}, {"target": [1], "doc": ["not have this feature be a real pain for i and  make i switch from ts / nodejs to something more", "it be all fine and dandy , but when you be work on a complex project with a * a lot * of data structure  and you can not model the datum properly , you get the feeling that this be not a language \" for big boy \" .", "in my particular case , i want the property to be readonly , but modifiable from the inside", "and also serialize to json", "too many hoop to jump through"], "issue_sim": [0.11316647380590439, 0.23580798506736755, 0.5538665056228638, 0.2684984505176544, -0.09251721203327179], "prob": [0.044187888503074646, 0.9390457272529602, 0.08212477713823318, 0.0002740154159255326, 0.0001742117601679638]}, {"target": [1], "doc": ["i be sorry but this be a rubbish reason", "typescript include feature like private constructor , yet you say that the complexity of different getter / setter be too high and steepen the learn curve .", "like somebody mention here , <tag> should not be an argument against a standard in most modern programming language", "your suggestion to use private / protect be not really helpful either - it make the code less readable and it add complexity to it"], "issue_sim": [0.003844240680336952, 0.5422384738922119, 0.20594769716262817, 0.3863895833492279], "prob": [0.00021678366465494037, 0.792353093624115, 0.031008681282401085, 0.33424651622772217]}, {"target": [1], "doc": ["seem like a good idea", "if this feature be add , i think it would be important that it also work with <tag> .", "maybe this would be a small", "step toward project references : wink :"], "issue_sim": [-0.0060162656009197235, 0.22566363215446472, -0.047637008130550385, 0.09068025648593903], "prob": [0.0034648184664547443, 0.9802718758583069, 0.00030946650076657534, 0.0009037968120537698]}, {"target": [3], "doc": ["we exclude it during the initial implementation due to complexity , but leave an error for it in so we could go back and add it later if we need to", "an issue here be that the module resolution strategy we use be determine by your compiler option", "and an <tag> option can be specify just what that module resolution scheme be , which be kind of a circular dependency -", "you must know your module resolution scheme to resolve an <tag> option , but your <tag> option can lead to where you specify some module resolution scheme !"], "issue_sim": [0.16999971866607666, 0.2706180214881897, 0.3273106813430786, 0.31694236397743225], "prob": [0.5896044373512268, 0.026895232498645782, 0.1982840746641159, 0.19287389516830444]}, {"target": [2], "doc": ["@mightyjam that be a relative path , so it be fine", "we do not always use node module resolution for your package  , and it stand to reason that we 'd use the same module resolution for your configuration as for your other file", "which lead to the issue that it become possible to not know what module resolution scheme to use to find your configuration until we have find your configuration , which be an issue ."], "issue_sim": [0.19061966240406036, 0.29138171672821045, 0.3719633221626282], "prob": [0.004141355399042368, 0.7841507792472839, 0.7297357320785522]}, {"target": [1], "doc": ["not a very good idea", "in my mono - repo setup , the plan would be to have a config - like sub - repo , and it could end up get put at a high level , so you 'd need to do <tag> , essentially guess where <tag> would put thing , which be exactly why i suggest some way to follow the build - in node module resolution algorithm ."], "issue_sim": [-0.0106460340321064, 0.563153862953186], "prob": [0.02770831622183323, 0.9614048004150391]}, {"target": [0], "doc": ["but the npm module resolution algorithm * * do * * resolve to global package. anyway , you ca n't stop it .", "on thu , oct <number> , <number> at 10:37 pm , lucas ciruzzi < notifications@github"], "issue_sim": [0.27252864837646484, 0.10052631795406342], "prob": [0.8608934879302979, 0.03503189608454704]}, {"target": [0], "doc": ["i do n't think be a good practice to require a global package from a module .", "quote npm itself :", "in general , the rule be :", "if you  e instal something that you want to use in your program , use require , then install it locally , at the root of your project", "if you  e instal something that you want to use in your shell , on the command line or something , install it globally , so that its binary end up in your path environment variable"], "issue_sim": [0.23034536838531494, 0.14098942279815674, 0.0783008262515068, 0.3308264911174774, 0.28024065494537354], "prob": [0.9590561389923096, 3.7626305129379034e-05, 5.288714964990504e-05, 0.05690978467464447, 0.39053860306739807]}, {"target": [1], "doc": ["@ravenscar either of these look good", "however , i would point out that <tag> be a <tag> , which apply to the compilation process , and would not necessarily , and possibly should not , apply to the process by which ts read in and process its configuration .", "there be potentially no need to worry about any conflict between the compiler 's module resolution set and that apply by ts in resolve <tag> path", "i see no problem with the latter always use node resolution strategy", "for instance , afaik tslint always use node resolution semantic for its <tag> option", "if it be consider important to have both resolution strategy available for <tag> , then i would slightly prefer a new <tag> property at the top level of <tag> instead of embed this information in the <tag> path itself with the scheme - like <tag> notation", "or , allow <tag> , with the default for <tag> hopefully be <tag>"], "issue_sim": [0.014094429090619087, 0.24220219254493713, 0.38599106669425964, 0.2489975392818451, 0.25790610909461975, 0.45303547382354736, 0.14291289448738098], "prob": [0.0017928326269611716, 0.9165726900100708, 0.061700910329818726, 0.003324296325445175, 0.008430449292063713, 0.4483909606933594, 0.0005393857136368752]}, {"target": [0], "doc": ["this just bite i because i have to extend a tsconfig.json in node_module , that itself have to extend a tsconfig.json from a package in node_module .", "but it ca n't , because <tag> be now actually <tag>"], "issue_sim": [0.404640257358551, 0.039289772510528564], "prob": [0.9033277630805969, 0.06245987489819527]}, {"target": [0], "doc": ["in the same way , static private attribute in class must be allow too .", "already compatible in edge  , node  , chrome"], "issue_sim": [0.34309086203575134, 0.15644827485084534], "prob": [0.881136417388916, 0.017962636426091194]}, {"target": [0], "doc": ["private property and method should not be accessible from outside the class instance .", "own method of a class should have access to private method of a class if they be static or not", "can be a constructor private", "if it be not , be this singleton example valid"], "issue_sim": [0.350496768951416, 0.4512284994125366, 0.32326140999794006, 0.27824491262435913], "prob": [0.5946736335754395, 0.4137204885482788, 0.004761472810059786, 0.011931512504816055]}, {"target": [0], "doc": ["<tag> be a private and static field inside <tag> class and <tag> be static too .", "as you can create this kind of static field and method in nodejs , it should work in ts", "node allow this way for create singleton pattern", "i do n't understand why ts be show that error"], "issue_sim": [0.3121471405029297, 0.47531816363334656, 0.3269551396369934, 0.170752614736557], "prob": [0.7627684473991394, 0.34661397337913513, 0.004167652688920498, 0.017627840861678123]}, {"target": [1], "doc": ["that be a good point", "i think we can use a private constructor . i think it fit well with this pattern . but , in a singleton pattern everyone can use getinstance method or new .", "if getinstance method exist , then should be use"], "issue_sim": [0.02431875839829445, 0.3941348195075989, 0.3359505534172058], "prob": [0.00652215164154768, 0.9382631182670593, 0.02255491353571415]}, {"target": [0], "doc": ["i mean private instance method , private static method , private accessor property and private static accessor property --- all this feature be similar to each other and should be support all together ."], "issue_sim": [0.4143560826778412], "prob": [0.9994926452636719]}, {"target": [1], "doc": ["while there be some confusion on this , both private field and private method be stage <number>", "private field be allow in typescript , but private method be not  .", "in @denoland we have a version of v8 that support the private method proposal", "it would be great to have private method as part of <tag> target in typescript so we can author code in typescript that be support in the runtime"], "issue_sim": [0.3090748190879822, 0.549717903137207, 0.32839030027389526, 0.5765576362609863], "prob": [0.17442913353443146, 0.30102741718292236, 0.0030340002849698067, 0.4876544177532196]}, {"target": [2], "doc": ["the first step have just be complete and ship in babel 7", "blog post : <url>", "this new transform eliminate the need for user have to add <tag> in scope of their js file in order for jsx to work , as it be inject by the transform .", "there be some talk in the pr of why this be n't solve with pragma :", "i be not familiar with the internal of this pr , i be just an enthused bystander but i think change would be something like :", "- when the <tag> compiler option be set to <tag> or <tag> , do n't throw a warning if you use jsx but <tag> be not in scope - as the import to the jsx factory function would be add by a further transform step", "- add a new value to the jsx compiler option <tag>  , that will transform code in a similar manner to <tag> as discuss in <url>"], "issue_sim": [0.05360599607229233, 0.0730859786272049, 0.5584802627563477, 0.1897880584001541, 0.19724659621715546, 0.6299498081207275, 0.598143994808197], "prob": [0.044818345457315445, 0.004799937829375267, 0.6146193742752075, 0.010156521573662758, 0.2710528075695038, 0.15148019790649414, 0.1033521294593811]}, {"target": [12], "doc": ["have though about this a bit , i have a few implementation concern", "we need some feedback from the react core team on this so that we can give a good experience for everyone", "it be not clear what the new flag that user should use be", "while this sound trivial , i really want to get this right", "do we name it <tag>", "that might be really confuse for new user where <tag> be already an option", "that also bring we to versione concern", "it sound like the intent be for <tag> and <tag> to be opaque function so that transformer can use different function in the future", "this way , user ca n't take a hard dependency on the <tag>/<tag> function , and an upgrade in react might imply an upgrade in the transformer", "that be not possible for we since our transformer be part of our codebase and ca n't be versione differently", "any new transform behavior would need a new <tag> flag on our end", "i think something we need to know from the core team be what the expectation be of incompatible update to the transformer", "the current proposal be for jsx expression to implicitly import <tag> so that user do n't have to .", "in the babel world , this be fine because there be an automatic assumption that user be always use module ; however , in typescript , we only assume a module if we see some <tag> or <tag>", "this mean that a jsx expression in the tree can automatically convert a file into a module , and for file that have no other import , we 'd have to potentially do a full walk of the tree to decide whether a file be a module", "this also mean user use the new jsx emit mode in global <tag> file would potentially be break", "i be not sure how many people use jsx without use module nowadays , but it be something that need to be recognize", "what we 'd probably end up do be say that under <tag> , a file must be a module", "user could get a quick fix in the editor to add an explicit <tag> , but it would be a weird divergent behavior that might be confuse"], "issue_sim": [0.13128285109996796, 0.1631917953491211, 0.35517194867134094, 0.046484336256980896, 0.21644800901412964, 0.3005399703979492, 0.11067315191030502, 0.4116917848587036, 0.4726245403289795, 0.3138701319694519, 0.47164979577064514, 0.32979172468185425, 0.479674369096756, 0.5206576585769653, 0.431041955947876, 0.5381776690483093, 0.43509790301322937, 0.2227812558412552, 0.33592838048934937], "prob": [0.001303697470575571, 0.041868988424539566, 0.0002429405867587775, 0.0001808760716812685, 2.6942694603349082e-05, 0.0011252030963078141, 0.00011205698683625087, 0.017530407756567, 0.13782623410224915, 0.006332972086966038, 4.160427488386631e-05, 0.0009607446845620871, 0.06980123370885849, 0.020906731486320496, 0.017728503793478012, 0.0012109085218980908, 0.0023723284248262644, 0.0007534998585470021, 0.07114536315202713]}, {"target": [0], "doc": ["the deprecation of <tag> on fc seem particularly ugly when view through a typescript ergonomic lens , add my comment on their rfc :"], "issue_sim": [0.2637850344181061], "prob": [0.9999918937683105]}, {"target": [1], "doc": ["@craigkovatch i do n't think use <tag> be good practice", "there be basically no benefit to use it , and a number of downside that you might run into .", "i do n't want to tangent this thread on the point ; but i 've describe in detail some of the downside here : <url>"], "issue_sim": [0.22805923223495483, 0.052109528332948685, 0.07822403311729431], "prob": [0.0012547698570415378, 0.979036271572113, 0.2781367003917694]}, {"target": [2], "doc": ["@retsam i second this", "in my book and base on my research , i 've advise against the use of react", "those type only add noise and hinder readability ."], "issue_sim": [0.046675801277160645, 0.12567642331123352, 0.0963243618607521], "prob": [0.022583432495594025, 0.6605846881866455, 0.6495531797409058]}, {"target": [4], "doc": ["i think the wise move be definitely to make it as generic  as possible , though , i expect most framework that rely on jsx will over time migrate to the new <tag> and <tag> style function , if history be any precedent here", "the real issue with leave it up to be plugin , be that the compiler api documentation just be n't great", "it feel very neglected in comparison", "also , with plugin you can only load they via the node compiler api , you ca n't have  transform plugin add into the tsconfig under <tag>", "if the story around plugins get clean up  , then rely on plugin be the way forward , and you could use react as a reference implementation of say plugin .", "i think that would be very acceptable"], "issue_sim": [0.5869094133377075, 0.34633439779281616, -0.0628582239151001, 0.37722793221473694, 0.3462345004081726, 0.04126901179552078], "prob": [0.4477790296077728, 0.36232736706733704, 0.009895416907966137, 0.4067925810813904, 0.35692328214645386, 0.0037300216499716043]}, {"target": [1], "doc": ["from <appname> , turn out this issue already exist : <url>", "i think this be the correct syntax to use and the same thing i try when i want to use generic with a template tag ."], "issue_sim": [0.03967156261205673, 0.5922865271568298], "prob": [0.04444558545947075, 0.837066113948822]}, {"target": [0], "doc": ["if all you be do be specify the type argument for an output type  , that be not really a case for generic - that seem like a well case for a type assertion .", "the one thing that i do see as a benefit in the original use case be that you do n't have to write <tag> every time , which be definitely a pain"], "issue_sim": [0.3845742344856262, 0.23739652335643768], "prob": [0.7141896486282349, 0.42815375328063965]}, {"target": [6], "doc": ["to give some technical background on this , there be four operation that we consider flavor of function invocation in the compiler :", "* call expression : <tag>", "* <tag> expression : <tag>", "* tag template : <tag> foo <tag> <tag>", "* decorator : <tag>", "the latter two do not allow explicit type argument", "my feeling be that both should be allow , but give the demand , work to support tag template be reasonable and should have some more priority ."], "issue_sim": [0.2846260368824005, 0.21789661049842834, 0.2591164708137512, 0.4424354135990143, 0.31525295972824097, 0.20464195311069489, 0.27993687987327576], "prob": [0.5203295946121216, 0.001975768944248557, 0.005952885840088129, 0.007548446301370859, 0.00283912499435246, 0.002928683767095208, 0.9888752698898315]}, {"target": [3], "doc": ["so i remember the real reason we do n't do this originally", "right now , tagged template be consider * memberexpression*s", "those bind just a bit more tightly than a * callexpression * or * newexpression *", "since tag template will always bind more tightly , we 'll always * try * to parse tag template type argument , even when we be go to parse out a call expression .", "if you take the following :", "a naive approach would do the following :", "let i try to parse out a * memberexpression *", "i have a <tag>", "keep parse out the rest of a * memberexpression *", "let i look try parse out type argument for a tagged template", "i have type argument", "let i see if i have a template string", "i have an open paren - let i discard all the work i 've do to get those type parameter", "i be able to get <tag> as a * memberexpression *", "let i see if i can parse out a call", "i see a <tag>", "i should parse out type argument as part of a * callexpression *", "i get type argument", "now i see an open paren", "i 'll try parse out the call argument", "this approach mean that * for every call expression with generic * , we have to perform step 1", "ii , through 1", "iv even though we be go to throw away the result", "while it be rare that you have to supply type argument , it be less - than - ideal to do a re - parse every time"], "issue_sim": [0.05522455275058746, 0.1978318691253662, 0.056802380830049515, 0.4737005829811096, -0.02040826715528965, 0.018350839614868164, 0.29053795337677, 0.1637195348739624, 0.10998456180095673, 0.43449199199676514, 0.2541404366493225, 0.35635906457901, 0.3567025661468506, 0.2988167405128479, 0.21180665493011475, 0.14131523668766022, 0.29890578985214233, 0.2765209376811981, 0.1661941558122635, 0.1672924906015396, 0.25473564863204956, -0.042844124138355255, -0.004050716757774353, 0.264512836933136], "prob": [0.0348982997238636, 0.002221322152763605, 0.0620393231511116, 0.08078961074352264, 0.0029888872522860765, 0.00026533222990110517, 0.0024592499248683453, 0.0001789091620594263, 0.00034095198498107493, 0.000327577959978953, 0.00011639660806395113, 0.00013845873763784766, 0.0006421071593649685, 0.00011676637950586155, 9.335535287391394e-05, 6.111872789915651e-05, 0.00023345228692051023, 9.682509698905051e-05, 0.00018407049356028438, 0.00038257052074186504, 0.009078696370124817, 0.0004244697920512408, 0.0005512323696166277, 0.02460860274732113]}, {"target": [3], "doc": ["hey @wycat , i assume you mean <tag>", "yeah , i try something like :", "with no luck since , like you mention , the construct type need to be resolve to a class or an interface", "i think the limitation should be from extend primitive type , not from non - class / interface type .", "@ahejlsberg can you weigh in on this"], "issue_sim": [0.1178225576877594, 0.05410115793347359, 0.5045738816261292, 0.44409534335136414, 0.15247589349746704], "prob": [0.027145668864250183, 0.007118892855942249, 0.2891867160797119, 0.6502886414527893, 0.005635835230350494]}, {"target": [10], "doc": ["@wycat here be something that work :", "some comment on what be go on", "first , we have a hard constraint that you can only inherit from a class or interface type , and not from type parameter", "a key reason be that we ca n't properly check whether the base class have property that conflict with the derive class when we do n't yet know the final shape of the base class", "this also highlight the primary difference between <tag> and the <tag> operator : the <tag> operator allow the type operand to be type parameter but do n't cause error when property have the same name", "instead , <tag> recursively apply <tag> to the type of the similarly name property", "so , in the <tag> method , i be \" cast away \" the type parameter  and then \" cast back \" to the intersection type <tag>", "this mean that <tag> end up have the type <tag>", "the fact that you can only inherit from a class or interface type also  imply that you ca n't inherit from an intersection type", "therefore , you ca n't do the last bit of your example where you inherit <tag> from <tag>", "i be definitely open to suggestion on make thing more flexible here , but we be push close to the limit of our type system  ."], "issue_sim": [0.17898525297641754, 0.02492390386760235, 0.4049701690673828, 0.28515633940696716, 0.2512487769126892, 0.2047712802886963, 0.28420907258987427, 0.2739619314670563, 0.4139055609703064, 0.17358729243278503, 0.21255554258823395], "prob": [0.0001828983804443851, 0.0007340930751524866, 0.01440553367137909, 0.13964995741844177, 0.09781128913164139, 0.000743954791687429, 0.03905868157744408, 4.507484118221328e-05, 0.005316170398145914, 0.00018480533617548645, 0.1940792351961136]}, {"target": [2], "doc": ["i want to check in and see if there be any possibility of progress here , since the type system get some nice upgrade recently", "this be the close i 've ever be able to come at type es6 mixin correctly , which unfortunately still have a pretty high cost on both the definition and use side :", "not only would the <tag> type operator be helpful for shorten this like @artazor 's example , but it 'd be much well if we could omit the extra interface declaration and get at the infer return type of the mixin .", "maybe something like :"], "issue_sim": [0.209584042429924, 0.28195106983184814, 0.43401414155960083, 0.17313851416110992], "prob": [0.2344001680612564, 0.5614346861839294, 0.4376455247402191, 2.810603655234445e-05]}, {"target": [1], "doc": ["grab a big coffee and read # <number> for some history on this", "one nit be that <tag> be n't a generic type  , so it 'd be wrong to provide it \" type argument \" .", "it be tempting to revisit <tag> as a potential syntax , though", "with the advent of conditional type , overload be become less common and we might be able to get away with not support overload resolution for this process"], "issue_sim": [-0.110117107629776, 0.4555620551109314, 0.16780267655849457, 0.2803407609462738], "prob": [0.012842894531786442, 0.3060718774795532, 0.03099595196545124, 0.3641885221004486]}, {"target": [11], "doc": ["thank for the pointer", "quick summary on what be relevant for this issue :", "the link proposal be reject because it be too complex , and many use case it be originally think for can now be solve use other feature like indexed and conditional type", "it be still not possible to infer the type of all possible expression", "two interesting use case that be still not possible be to access infer return type of generic or overloaded function", "this proposal would solve the former , but not the latter", "i do n't know the code base , but i imagine this proposal would be relatively easy to implement , at least when compare to # <number>", "when i write <tag> , i mean that as <tag> , not <tag>", "to elaborate , let 's reconsider the <tag> example", "<tag> have type <tag>", "then <tag> have type <tag> , and <tag> would return exactly that", "i guess what i be try to say be that <tag> narrow the type of a function on the expression level , and use <tag> you can access the type of that expression .", "as i say , this be really just take what already happen in call like <tag> , but decouple the generics - bind syntax from the function call syntax", "that be another interesting possibility i have n't think about", "it rely on type - level function call be implement , and use typeof to lift the result expression to the type level", "the advantage of such a type - call syntax would be that you do n't need <tag> anymore", "on the other hand , you have to provide type for all argument even if the return type do n't depend on they", "to access the infer return type <tag> for <tag> with call syntax you need <tag> , whereas with type argument you need <tag>", "so one need extra <tag> and <tag> symbol , while the other need the <tag> helper", "when overload resolution be out of play , i would like to come back to <tag> for a moment : would that really be so wrong", "i only think about it on the expression level , but i think it would work on the type level as well", "i understand that <tag> be not a generic type in the same way as promise < t > would be , since the type variable of the function signature be still free", "but be n't that exactly the reason it make sense to provide it with one", "<tag> be essentially a higher - kinded type , and by provide it with a <tag> , we could get an ordinary type <tag>"], "issue_sim": [0.04735841602087021, -0.0050070397555828094, 0.43132394552230835, 0.3124436140060425, 0.5970887541770935, 0.2188572883605957, 0.370817631483078, 0.12616793811321259, 0.09554695338010788, 0.33638566732406616, 0.3375741243362427, 0.44834157824516296, 0.5971518754959106, 0.11544520407915115, 0.4687212109565735, 0.485024094581604, 0.4056951701641083, 0.5666515231132507, 0.19647270441055298, 0.14458057284355164, 0.26026588678359985, 0.5745385885238647, 0.15201476216316223, 0.36147841811180115], "prob": [1.8091363017447293e-05, 1.2317510481807403e-05, 0.11078047752380371, 6.002834652463207e-06, 0.00025571411242708564, 1.1437823559390381e-05, 0.00030577954021282494, 6.976235908950912e-06, 0.0005211831303313375, 2.1790335722471355e-06, 5.468574272526894e-06, 0.004621639382094145, 0.003282252699136734, 4.0265244933834765e-06, 0.00011675574205582961, 0.000138853196403943, 0.0002578520798124373, 0.00014419847866520286, 4.820782123715617e-06, 0.0016016960144042969, 3.966322401538491e-05, 0.016330726444721222, 0.0011761017376556993, 0.034996453672647476]}, {"target": [0], "doc": ["so where your example work for return type @simonmesken i do not thing it work for other type of infer whereas i do believe the propose solution would fix my request which be to use the return type from <tag> to infer with   # <number>", "essentially , the goal imo would be to have :", "then we can derive a new type by use <tag>", "or in my more complex example :", "mean that we can tell typescript what the generic will be for the function so it can tell we what another argument  will be in turn"], "issue_sim": [0.5596257448196411, 0.081212118268013, 0.31035682559013367, 0.03720856085419655, 0.50461345911026], "prob": [0.7781593203544617, 0.15199927985668182, 0.03522806242108345, 0.009648325853049755, 0.7944114804267883]}, {"target": [0], "doc": ["i think your approach be n't quite work . your <tag> would n't be a propper type , since it depend on a type <tag> which you neither define as a type parameter nor provide as a type argument .", "also , while <tag> do evaluate to <tag> , that do n't seem very helpful , since the inner <tag> shadow the outer one you be declare", "so basically <tag> and <tag> behave exactly the same", "the only difference be that <tag> have an unused type parameter", "with my proposal implement , you could achieve the want behavior as follow :", "note that the function type of <tag> do n't have its own <tag> type argument anymore , so the argument really must match the type you provide to <tag>"], "issue_sim": [0.5669545531272888, 0.12504824995994568, 0.19013631343841553, 0.37670373916625977, 0.3045218288898468, 0.5777560472488403], "prob": [0.44114038348197937, 0.5346153378486633, 0.0014008065918460488, 0.0009286365238949656, 0.00044326865463517606, 0.2009461224079132]}, {"target": [1], "doc": ["@bradennapier you be right , you show how this feature would be useful for infer parameter type as well , not only return type", "this be another key difference between this proposal and the <tag> syntax proposal , since the latter would always yield the return type , and never a parameter type ."], "issue_sim": [0.5593829154968262, 0.5103198289871216], "prob": [0.04274305701255798, 0.8611542582511902]}, {"target": [4], "doc": ["i be suggest to add a way to concretize the type of a generic function", "the example with <tag> should demonstrate how the suggest feature would work , but it be not a use case where i would really need it", "even this work fine as well :", "well use case be the one provide in the link issue by @bradennapier , or the one in my proposal about discriminate union", "in general , it would be useful to help typescript infer the correct type without provide it explicitly .", "i agree that this be probably not need very often , but when it be , it would very useful", "also , i do n't think it would be a big change , at least not on the surface of the language , so it could be well worth the effort"], "issue_sim": [0.5313237309455872, 0.33161336183547974, 0.06511040776968002, 0.2941845655441284, 0.49964439868927, 0.10458335280418396, 0.15510910749435425], "prob": [0.11038556694984436, 0.15186235308647156, 0.00017059731180779636, 5.602705277851783e-05, 0.3056410551071167, 0.006935913115739822, 0.47915053367614746]}, {"target": [8], "doc": ["my 2c : as they be define in atscript now , annotation have a couple of nasty problem", "they do n't compose", "if you need to add <number> annotation to <number> field , and they only differ sligtly by one parameter , you will need to copy - paste all <number> field , <number> time", "you ca n't abstract they behind a single annotation", "a factory function be more appropriate - that way they wo not have to be define as class", "they be passive and therefore limit in power", "the standard practice in js be to wrap function / object / property use other function , e", "angular , ember and other framework already do this kind of wrapping", "if annotation be add to the language , i 'd think they should reflect this . its quite easy to implement passive annotation on top of it .", "one of the tc39 proposal mention in the document above work like this", "its  and i think that s what atscript , typescript and es7 should aim for"], "issue_sim": [0.37931448221206665, 0.03591247648000717, 0.344500869512558, 0.35413533449172974, 0.1648574322462082, 0.006029363721609116, 0.38264065980911255, 0.3512307405471802, 0.5414086580276489, 0.18485179543495178, 0.3401869535446167], "prob": [0.046269409358501434, 0.0030443700961768627, 0.23630310595035553, 0.0010519354837015271, 0.0018475290853530169, 0.00027360275271348655, 0.007769524119794369, 0.0012554115382954478, 0.27625152468681335, 0.0011029306333512068, 0.0346716046333313]}, {"target": [9], "doc": ["as an aside , use new with a factory function will work as expect", "the return value of the factory function will be use", "however , i concede that it be n't idiomatic javascript , and cause an unnecessary object creation", "that be say , i think i can address <number> and <number> in one or two way :", "with just the propose syntax above , note that you can still set annotation directly , give you control over composition and factory vs new :", "or , if you really want composition in the syntax , then i would propose the follow alternate array syntax , which would require the es6 spread operator", "the following would be equivalent to the above sample :", "i think either of these be sufficient to overcome concern <number> and <number>", "with respect to your third comment , i specifically avoid \" decorator \" in this proposal", "first of all , you do n't really need new syntax for decorator - as you say , function wrapper give you everything you need , and the syntax be already about as concise as it could possibly be .", "secondly , mutate decorator have implication for type", "if a decorator modify the prototype of the class it be apply to , say add a set of function , how do typescript know", "you could annotate the class with an interface , but you 'd have to stub everything that the decorator add to your class first , because the typescript compiler ca n't tell that a decorator add implementation for the interface", "and even if you stub the field out , the interface check be effectively turn off , because you ca n't enforce that the decorator be add field / method that match the interface anyway", "in those kind of case , i think use the type system for that kind of type augmentation be a superior option , especially if we support mixin", "finally , i think there really should be a separation between decorator and annotation", "decorator function / wrapper be good candidate for be consumer of the metadata", "make annotation inert also improve their reliability - it would cause a lot of confusion to have to track down issue relate to mutate annotation", "there be no way to document to the type system  , what it be that the mutate annotation be do to your type , field , function argument , or method", "thus , i propose a more conservative passive approach to annotation"], "issue_sim": [0.20768919587135315, 0.06823058426380157, 0.2627474367618561, 0.058388493955135345, 0.47422125935554504, 0.5238929986953735, 0.02299356460571289, 0.045838188380002975, 0.25317519903182983, 0.40648001432418823, 0.3097922205924988, 0.5734505653381348, 0.5721982717514038, 0.35502976179122925, 0.3468475341796875, 0.4875549077987671, 0.3548773527145386, 0.4599955976009369, 0.5860174894332886, 0.3061763048171997], "prob": [0.0034221489913761616, 0.004933910444378853, 0.0760355293750763, 0.000670075707603246, 0.008783066645264626, 0.010501000098884106, 2.746137761278078e-05, 5.494659853866324e-05, 0.00035797033342532814, 0.03192542865872383, 0.037490103393793106, 0.0005721081979572773, 0.003246140666306019, 0.00206212536431849, 0.0007481013308279216, 3.304283745819703e-05, 9.872721420833841e-05, 0.0017136480892077088, 0.1515856385231018, 5.385063559515402e-05]}, {"target": [1], "doc": ["yes , its important that all language feature compose easily", "the spread operator solution would be okay but it kinda break the abstraction barrier .", "the developer should not have to know whether the annotation they be use be composite or not", "new syntax be necessary mostly because they be not allow inside class definition in es6", "this be also why yehuda propose they when they switch ember to es6", "you be right that there would be type problem with decorator", "mutation would be tricky to model", "maybe decorator could always return new value instead mutate they , and intersection type  could be use to model augmentation", "or maybe the mixin mechanism will be able to help there", "i agree with most of the benefit of inert / passive annotation that you mention", "overall , i feel it may be too early to add annotation to ts", "the proposal be  in the strawman stage for es7 +", "angular / atscript be just now start to experiment with what annotation would mean - it may still turn out that their design be flawed"], "issue_sim": [0.17794841527938843, 0.2256268709897995, 0.42136311531066895, 0.504508376121521, 0.30484122037887573, 0.24243572354316711, 0.057847537100315094, 0.4272325336933136, 0.2049950808286667, 0.2967529892921448, 0.36323148012161255, 0.09626615047454834, 0.3628343641757965], "prob": [0.0032088959123939276, 0.038912516087293625, 0.04592807963490486, 0.008141519501805305, 0.03705800324678421, 0.004744508303701878, 0.0033864183351397514, 0.18018631637096405, 0.010009604506194592, 0.019942762330174446, 0.006278572138398886, 0.001060282695107162, 0.2879183292388916]}, {"target": [3], "doc": ["we ca n't make too many assumption about how application code will consume annotation , but , assume it check for match constructor recursively up the prototype chain - could n't we just use the type system to compose annotation to avoid the situation you link", "it would of course require mixin  , but you could just create sub - type annotation that mix in the aggregation of common annotation", "you would n't then need the spread operator , explicit , or alternate array syntax to make it work", "also , third party library could provide their own composition functionality for attribute , say with an aggregate annotation that take an array of annotation ."], "issue_sim": [0.5221141576766968, 0.6110052466392517, 0.3421593904495239, 0.590873122215271], "prob": [0.376592218875885, 0.09610328078269958, 0.023502644151449203, 0.5154174566268921]}, {"target": [1], "doc": ["i tend to agree with @wycat on this", "one of the big use for annotation be to provide metadata to a runtime system that end up do some sort of metaprogramming base on that datum .", "but the alteration be make to the annotate object be in no way discoverable by the typescript compiler", "however , by use decorator , the metaprogramming can be move out of the framework proper and into the decorator itself", "and define in such a way that typescript can understand the transformation", "for non - metaprogramming use case , the decorator can still add meta - datum to a know location on the object", "this could also be declare as part of the ts decorator definition also"], "issue_sim": [0.0734497606754303, 0.4792110025882721, 0.5774409174919128, 0.37627798318862915, 0.40224429965019226, 0.4602202773094177, 0.32211214303970337], "prob": [0.0004896236350759864, 0.42639583349227905, 0.004025781061500311, 0.06104850396513939, 0.001034674234688282, 0.29353025555610657, 0.0047075385227799416]}, {"target": [2], "doc": ["as a clarification , i would say that i be not argue against decorator , even if i have reservation about they", "i be instead propose annotation independently", "you can consider they to be sugar for a very common family of decorator use case , a way to nudge framework towards a common standard for those use case , and as a way to align with traceur / atscript .", "you could conceivably have both in the language , so long as you use a different sigil for each", "also , while you can implement annotation use decorator , the result be not as clean", "for example , you can implement they one of two way that i can think of : via an ' annotate ' decorator that take an annotation list as input :", "the drawback to this approach be that the syntax be painful", "at this point , you might as well just use a static :", "alternatively , each decorator could add the annotate field internally , so you could get roughly back to the same clean declarative syntax :", "the drawback to this approach be that each decorator would need boilerplate code for add itself to the annotate array of the constructor function , if it do n't exist , else create it", "that be somewhat brittle , as any decorator which forget to check if the array already exist would end up overwrite the exist one", "use decorator to implement member and parameter annotation , however , be troublesome :"], "issue_sim": [0.2306400090456009, 0.4274616241455078, 0.356914222240448, 0.15536461770534515, 0.4695208668708801, 0.5812114477157593, 0.2781369388103485, 0.07664299011230469, 0.4995117783546448, 0.5379359722137451, 0.26682764291763306, 0.5283757448196411], "prob": [0.04200419783592224, 0.000518222339451313, 0.07328085601329803, 0.030080903321504593, 0.0055638267658650875, 0.34818607568740845, 0.00010142221435671672, 0.001123929745517671, 0.022850362583994865, 0.09746278077363968, 0.02279350534081459, 0.012478016316890717]}, {"target": [0], "doc": ["this could be useful for spread in argument list , but why would n't you use an object literal instead ?"], "issue_sim": [0.3999476730823517], "prob": [0.9999750852584839]}, {"target": [1], "doc": ["actually , i do n't see this feature be very useful in argument list , b / c the variable you name in the destructure expression implicitly label the element of the tuple :", "as for why one would use tuple in a return type vs. object , or really , why one would use tuple over object generally ; sometimes , it be easy to have data structure with positional value rather than name value , such as when one have to write a bunch of these value  .", "use tuple get rid of a lot of repetition / noise", "additionally , in recent news ,  which be base on return / destructuring tuple", "using name tuple as a return value :", "seem much more descriptive than use unnamed tuple :"], "issue_sim": [0.5909571051597595, 0.5323904752731323, 0.295301228761673, 0.34033066034317017, 0.49784228205680847, 0.47921597957611084], "prob": [0.7490436434745789, 0.9739083647727966, 0.03365118429064751, 0.06771424412727356, 0.0026268542278558016, 0.005208915565162897]}, {"target": [0], "doc": ["name tuple element would improve code readability .", "i currently have <tag> , which would be much more readable as <tag>"], "issue_sim": [0.5663800835609436, 0.24356994032859802], "prob": [0.05631006136536598, 0.9313164949417114]}, {"target": [0], "doc": ["add to this : i think it might be nice to have human readable label fallback , i.e. :"], "issue_sim": [0.40201446413993835], "prob": [0.9999833106994629]}, {"target": [0], "doc": ["propose feature do n't improve readability in call site .", "this be obvious if use interface instead of tuple :", "rule be very straightforward : if meaning of element be obvious , then use tuple", "otherwise , use interface", "similar to positional and name argument", "i be afraid that with new syntax people will start to use tuple in unsuitable place", "the provide example be synthetic", "how propose feature should improve readability in such case", "also , you can always write helper function to reduce repetition", "moreover , the propose feature do n't   protect from error at compile time when order of element in tuple be change :"], "issue_sim": [0.28751838207244873, 0.49895718693733215, 0.40354692935943604, 0.13646304607391357, 0.21501624584197998, 0.45804786682128906, 0.08555568754673004, 0.33328697085380554, 0.20103353261947632, 0.47045350074768066], "prob": [0.029926104471087456, 0.11230386048555374, 0.28199055790901184, 0.010111037641763687, 0.023796146735548973, 0.09550254046916962, 0.004492088686674833, 0.003642141353338957, 0.007911721244454384, 0.21356745064258575]}, {"target": [0], "doc": ["i personally prefer the first option for both choice , the reason be you could then copy a function parameter list directly into a tuple and have everything work :"], "issue_sim": [0.4499315619468689], "prob": [0.9999732971191406]}, {"target": [1], "doc": ["i have to agree with @vitaly - t", "to i , it would make a lot of sense in the context of vector math to perform operation that read like you be work on an object  instead of work with array  .", "the big plus to i would be readability"], "issue_sim": [0.0671750009059906, 0.25794222950935364, 0.07383677363395691], "prob": [0.0005765706882812083, 0.9823355078697205, 0.009823366068303585]}, {"target": [0], "doc": ["to avoid work with index , and instead work with name , make it so much easy to read such code .", "one have to wonder , from all the down - vote , and without explanation , where all the negativity come from", "seem like just very unfriendly place"], "issue_sim": [0.258383184671402, -0.05860842391848564, -0.036327142268419266], "prob": [0.7258732318878174, 0.3955904245376587, 0.012856250628829002]}, {"target": [0], "doc": ["i take it this problem be suppose to arise when <tag> reexport <tag> and <tag> when both reexport <tag> .", "we do n't have to do anything special to support this in a nice way right now", "since our support of typing in package", "json , we can create \" type wrapper \" for exist library , like  we can leverage npm , rather than attempt to solve a solve problem ourselves", "in this specific example , you change your ts library  to use a <tag> and <tag> package shim", "write every shim use external module syntax , and you be conflict free no matter how you compose your package , since the type follow the package", "in effect , i be say to stop use <tag> and dt with node package , and start author type shim package instead , because <tag> handle all of this as part of package resolution anyway", "it also make it easy to swap to use the original package 's typing if they be add later - you just update your dependency in your package", "json and swap your require call", "additionally , this provide independent versioning of the dts _ and _ the underlie library but with semver compatibility", "additionally , this make typing discoverable on <tag> , which should hopefully be a boon to their usage"], "issue_sim": [0.35676318407058716, 0.054989852011203766, 0.0876757800579071, 0.3528943657875061, 0.45105013251304626, 0.45268484950065613, 0.5290616154670715, 0.3702597916126251, 0.18597713112831116, 0.2858201265335083, 0.16156795620918274], "prob": [0.30507469177246094, 0.004137213341891766, 0.0009653823799453676, 0.13416790962219238, 0.0067001208662986755, 0.13278637826442719, 0.17606931924819946, 0.021281590685248375, 0.000973211950622499, 0.02008998394012451, 0.021329127252101898]}, {"target": [4], "doc": ["that be an interesting idea", "a big disadvantage i see with it , though , be that i be then dependent on the provider of that type package to provide high - quality typing in the first place , and then update it every time the source package change", "i be afraid that we 'll have ten of these typed-\\ * package  , just like we have ten of webpack - typescript , gulp - typescript , etc etc package", "on dt , this be much less of a problem because ' anyone ' can contribute , and there be many people to approve the change", "yeah , but that be in my proposal even simple : as soon as the real package have the typing , it will automatically be use over the dt one , no need to change anything"], "issue_sim": [-0.027160752564668655, 0.28465765714645386, 0.42203691601753235, 0.1189669743180275, 0.305072158575058], "prob": [0.0012568638194352388, 0.43666502833366394, 0.13702799379825592, 0.006312187761068344, 0.2181975245475769]}, {"target": [0], "doc": ["if you 'd like , you can just restructure the dt org  to publish npm package in the new style , and accept contribution in kind .", "the contribution model be not contingent on the distribution one"], "issue_sim": [0.3964720368385315, -0.13600227236747742], "prob": [0.9226862192153931, 0.03875862434506416]}, {"target": [5], "doc": ["clarification : i mean to say ' per package ' , there be ten of same - but - different package", "for gulp , there be gulp - typescript , gulp - tsc , gulp - type ,", ", for webpack there be typescript - loader , awesome - typescript - loader , ts - loader ,", "my fear be that the same will happen for basically every other package", "the big one will likely converge into a group of people maintain they , but for the small one", "what could work , maybe , be if we can automatically generate npm package out of the dt repo . that would have the good of both world . hmmm"], "issue_sim": [0.18158090114593506, 0.37701553106307983, 0.39827796816825867, 0.025478050112724304, 0.013244779780507088, 0.38293468952178955], "prob": [0.10795503109693527, 0.13187217712402344, 0.14835552871227264, 0.0015871343202888966, 0.04391518980264664, 0.4141290485858917]}, {"target": [2], "doc": ["it should be possible to autogenerate external declaration dts file from dt type", "i 've be go through and do it by hand for node", "plus , not everything on dt be a node package ."], "issue_sim": [0.24198879301548004, 0.1260966807603836, 0.27577903866767883], "prob": [0.00794990174472332, 0.0035597141832113266, 0.9796149134635925]}, {"target": [2], "doc": ["@jbrantly would an es6 version of the package really be different from a non - es6 typing in term of how the end - user can use it", "can you give an example of such a difference", "because i think that if the typing simply follow the style of the package itself  , the user of the library can already choose to use old or new style import , and the compiler will do the ' conversion ' for you .", "so it would only really matter if you want your typing to work on e", "4 or low , but i be not sure that be worth the trouble"], "issue_sim": [0.3727496862411499, 0.02429870329797268, 0.39883920550346375, 0.1127917543053627, -0.03714770823717117], "prob": [0.01474255695939064, 0.008474869653582573, 0.9469391107559204, 0.0027892100624740124, 0.0034158045891672373]}, {"target": [2], "doc": ["the difference be in module assignment  and default export", "here be some example :", "these two concept be fundamentally incompatible  .", "additionally , typescript treat these differently when use import statement , so if you be target es6 you would n't even be able to import the cjs module", "pretty much any module compile by babel though support both mode , and therefore it make sense for there to  be typing for both mode", "if the module do n't use a default export or a module assignment then separate typing be n't need"], "issue_sim": [0.2050969898700714, -0.09155891835689545, 0.0370016023516655, 0.4916047751903534, 0.41520947217941284, 0.3889811038970947], "prob": [0.0004023598157800734, 9.074965782929212e-05, 0.25182580947875977, 0.04156331345438957, 0.0368778221309185, 0.0005552413640543818]}, {"target": [5], "doc": ["but this may lead to the situation where the compiler emit es6 code without complaint , which will only work when you be indeed go to pull they through babel", "if you 'd use a non - dynamic - check - loader , it will fail at runtime", "but simply ' automagically re - type ' it as something else  be not the right solution either , as it only work if you be use babel", "even though the package may be generate use babel  , it be not guarantee that the user will also use babel", "what do you mean", "i think both ' proper external ' be equally applicable to cjs and es6", "i think our discussion show that there be valid use - case for it , but that it should not be the default behaviour :)", "certainly not just base on --target es6", "maybe some other switch that ' tweak ' the resolve behaviour", "i be sure there will be more of these anyway", "anyway , this be only really relevant for the algo a case", "in algo b , people would still explicitly list their reference somehow  , and can handle it there", "i 've be think about that recently as well , but i come to the conclusion that an es5 / cjs package should _ not _ provide such definition if it do n't also provide the implementation", "i think it would be a good thing that the compiler tell i \" unknown type promise \" , such that i know i need to provide a polyfill myself when i be use node 0", "or that if i be compile for 0", "12 , it will already work without complaint", "seem the ts team be already work on something to facilitate the latter in # <number> , btw"], "issue_sim": [0.2723308503627777, 0.20842428505420685, 0.24517011642456055, 0.26571837067604065, 0.05309751629829407, 0.22612446546554565, 0.21269148588180542, 0.1876634657382965, 0.12193560600280762, 0.04044182226061821, 0.07099840044975281, 0.1188555508852005, 0.33685940504074097, 0.3461230397224426, 0.12140648066997528, 0.014162377454340458, 0.17820626497268677], "prob": [0.09570766985416412, 0.04688461869955063, 0.36286911368370056, 0.04967566207051277, 0.00032887194538488984, 0.0039757429622113705, 0.14202450215816498, 0.0024025491438806057, 0.00264413608238101, 0.0018920877482742071, 0.002071058377623558, 0.00810291524976492, 0.2648523449897766, 0.05123937875032425, 0.0009006155887618661, 0.0029693313408643007, 0.006874649785459042]}, {"target": [16], "doc": ["@weswigham you be absolutely right about not want to leak thing like <tag>", "but i think that be actually relate to a subtly different issue", "in my opinion , a package should not publish the typing of its ' host environment '", "just like no package export <tag> , a package should neither export <tag>", "see bottom part of <url>", "the fact that basically every package do so today , be imo only because there simply be no good way to do it in a well way", "however , note that in my proposal , i think this be actually handle gracefully :", "- ' all ' exist package typing  be of the ' non - proper ' variant , and typically ' include '  their own copy of <tag>", "- when ts 1", "6 be release , we can start make <tag> typing if we want to", "this be opt - in , and we should encourage people to _ not _ reference / export the host typing anymore", "in ' proper external ' typing , people ca n't accidentally create global , unless they directly <tag> other", "but because we have this nice automatic lookup in 1", "6 , there be no need to anymore", "simply <tag> your dependency", "i suppose / hope that when use proper external module / typing , you will never have to write a single <tag> line again , _ unless _ you explicitly want to make a real global", "in the ' non - proper ' variant , my ' mixed mode ' will apply , so stuff will be isolate .", "note how this keep work nicely when mix proper with non - proper / isomorphic : proper external include thing with import  , so they will be isolate as need", "isomorphic can either import or reference , and will stay isolated if they already be", "this do assume that people need to be a bit careful when they start write proper external typing : any use of <tag> be probably a sign of ' bad habit ' , and will indeed cause trouble"], "issue_sim": [0.11953272670507431, 0.09137047827243805, 0.27025455236434937, 0.3584851324558258, -0.03029901161789894, 0.1386321485042572, 0.09896904230117798, 0.2732072174549103, 0.1342194676399231, 0.1360969841480255, 0.14279979467391968, 0.20949327945709229, -0.0018887557089328766, -0.04463832080364227, 0.26483744382858276, 0.4966445565223694, 0.17544791102409363, 0.3001425862312317, 0.25318261981010437, 0.17163848876953125], "prob": [0.0014883645344525576, 0.0004988019936718047, 0.0007171034230850637, 0.008959217928349972, 0.0019399200100451708, 0.03513018414378166, 0.0015031029470264912, 0.03436627984046936, 9.041219163918868e-05, 0.00044731618254445493, 0.0020355035085231066, 0.0144425630569458, 0.00024745342670939863, 0.00031020937603898346, 0.00027707676053978503, 0.10672860592603683, 0.06374191492795944, 0.04158993065357208, 0.0014562138821929693, 0.5135964751243591]}, {"target": [2], "doc": ["a <tag> might be more appropriate than <tag> , so that you can pass in the currently select span", "i think in vs this would roughly map to an implementation of", "i do n't see any cause for concern with the propose command / response schema ."], "issue_sim": [0.4012215733528137, 0.3087621331214905, 0.2515870928764343], "prob": [0.7208951115608215, 0.014790220186114311, 0.10615266859531403]}, {"target": [0], "doc": ["we 've refine our api on the vs code side and have decide not to include the <tag> in v1 .", "we 've also move to use a link list structure instead of an array", "here be an update proposal that reflect this :", "the vs code api also take a list of position in the file and we return a list of selection range for each of those position", "this avoid extra request in some case", "we should consider do this in the ts api as well , as i do n't think there be any downside", "this would look like :", "here be the vs code api : <url>"], "issue_sim": [0.4273611009120941, 0.22072789072990417, 0.08807574212551117, 0.4981483817100525, 0.021755307912826538, 0.251991331577301, 0.09771136939525604, 0.41560783982276917], "prob": [0.8837758898735046, 0.03576643392443657, 0.012263349257409573, 0.15540970861911774, 0.0006760150426998734, 0.08994624763727188, 0.0007069503772072494, 0.000288869981886819]}, {"target": [0], "doc": ["that be how we 've implement the feature for vs code 's json and html support at least"], "issue_sim": [0.38624584674835205], "prob": [0.999947190284729]}, {"target": [0], "doc": ["it be kind of optional because the editor will deduplicate range anyways - so if it hinder an elegant implementation i wo n't do it ."], "issue_sim": [0.2972069978713989], "prob": [0.9999889135360718]}, {"target": [3], "doc": ["can i bring up a third option", "i think option <number> be the more flexible way of reduce duplicate declaration", "however both option <number> & <number> have limitation :", "support a global type and have <tag> extend it be pretty good because it be simple , and other environment  can use this too .", "but it would not solve the duplication problem in custom sandboxe environment , whereas the equally simple option <number>  would solve it", "generate <tag> with all global mirror on <tag> - but then do other environment miss out", "<tag> have similar duplication of declare global with the <tag> interface , and then there be web worker , custom environment , etc", "a third option would be a declaration that tell the compiler to augment the global environment with all the declaration in a particular interface", "eg <tag> for <tag> , <tag> for <tag> , etc", "this be similar to option <number> but in reverse , and allow additional scenario like sandboxing", "an example of this scenario be give in <url>", "note that if option <number> be use , then there would be no way to write a set of declaration that be just a normal interface in the host code but be be global in the sandboxe code", "they would all still have to be duplicate", "custom environment may be niche , but it would be nice if the mechanism choose here would work for they too"], "issue_sim": [-0.011425269767642021, 0.3496745228767395, 0.03679138794541359, 0.45523446798324585, 0.32065463066101074, 0.4092387557029724, 0.5244948863983154, 0.4552047550678253, 0.21254736185073853, 0.18345177173614502, 0.036342356353998184, 0.5029715299606323, -0.05730415880680084, 0.16648463904857635], "prob": [0.0022961259819567204, 0.016565153375267982, 0.008009640499949455, 0.40235841274261475, 0.035861458629369736, 0.00032143096905201674, 0.0012438218109309673, 0.002852102741599083, 0.00032234194804914296, 0.0011994227534160018, 3.0442002753261477e-05, 0.06537558138370514, 0.00019092694856226444, 0.0007936499314382672]}, {"target": [1], "doc": ["one other valid usecase be if you be work with", "for example we could be in another dom  so <tag> be a different one :"], "issue_sim": [0.2321757674217224, 0.19373300671577454], "prob": [0.2905956208705902, 0.6318183541297913]}, {"target": [2], "doc": ["thank you very much @tranquilmarmot", "there be and , unfortunately , there be a lot of error", "i still have the same \" property ' api ' do not exist on type ' window & typeof globalthis ' .", "there must be a root cause to fix", "src / app / component / app", "tsx:91:14 - error ts2339 : property ' api ' do not exist on type ' window & typeof globalthis '", "src / app / component / app", "tsx:93:14 - error ts2339 : property ' api ' do not exist on type ' window & typeof globalthis '", "electronipcon = > {", "src / app / component / app", "tsx:97:18 - error ts2339 : property ' api ' do not exist on type ' window & typeof globalthis '", "src / app / component / app", "tsx:101:14 - error ts2339 : property ' api ' do not exist on type ' window & typeof globalthis '", "electronipcon = > {", "ts:22:28 - error ts2345 : argument of type ' string ' be not assignable to parameter of type ' number '", "ts:32:8 - error ts2339 : property ' api ' do not exist on type ' window & typeof globalthis '", "ts:34:5 - error ts2304 : can not find name ' ipcrenderer '", "catch = > console", "ts:38:5 - error ts2304 : can not find name ' ipcrenderer '", "on = > func ) ;", "ts:41:5 - error ts2304 : can not find name ' ipcrenderer '", "ts:44:5 - error ts2304 : can not find name ' ipcrenderer '", "ts:47:12 - error ts2304 : can not find name ' ipcrenderer '", "ts:53:5 - error ts2304 : can not find name ' ipcrenderer '", "ts:59:5 - error ts2304 : can not find name ' ipcrenderer '", "ts:65:5 - error ts2304 : can not find name ' ipcrenderer '", "ts:68:5 - error ts2304 : can not find name ' ipcrenderer '"], "issue_sim": [0.031814321875572205, 0.0005658585578203201, 0.3747730255126953, -0.04714899882674217, 0.11654993146657944, 0.38054707646369934, 0.11654993146657944, 0.368640661239624, 0.18709112703800201, 0.11654993146657944, 0.37135767936706543, 0.11654993146657944, 0.37020498514175415, 0.18709112703800201, 0.29478880763053894, 0.3648776412010193, 0.19333221018314362, 0.2306419312953949, 0.13884994387626648, 0.266849160194397, 0.177508145570755, 0.18197005987167358, 0.17924517393112183, 0.16821390390396118, 0.19184310734272003, 0.16881786286830902, 0.1588185429573059], "prob": [0.011066942475736141, 0.010507915169000626, 0.006592999678105116, 0.001826438819989562, 0.00010501563519937918, 0.01050898153334856, 9.223639062838629e-05, 0.005285445600748062, 0.00017163302982226014, 0.0031913304701447487, 0.02814987115561962, 0.0011168791679665446, 0.004224947653710842, 3.726000795722939e-05, 0.0005500343977473676, 0.00022359145805239677, 0.00010456485324539244, 4.052700751344673e-05, 0.0003498464357107878, 0.1163787767291069, 0.0002192481333622709, 0.00041191827040165663, 0.000566023460123688, 0.000538941181730479, 0.0014730826951563358, 0.0009470041841268539, 0.0012026069452986121]}, {"target": [1], "doc": ["we do some work at sourcegraph in  , but hit some limitation with the current api", "specifically , the  you can provide to the server require the   method that return file content to return synchronously . in a language server however this be most likely do asynchronously because retrieve the file content involve io with the file system or over the protocol stream .", "i would be very interested in help or improvement in the ts server to solve this use case"], "issue_sim": [0.16020266711711884, 0.41770458221435547, 0.3510788679122925], "prob": [0.2835160791873932, 0.8061440587043762, 0.021968530490994453]}, {"target": [1], "doc": ["@felixfbecker sorry , i 'll try to clarify what i mean", "instead of implement <tag> , you could let <tag> host the language service , and you would n't need to care about how it satisfy that interface .", "your language server process would rely on pass message to / from tsserver , which be inherently async"], "issue_sim": [-0.01851586252450943, 0.41104838252067566, 0.31194624304771423], "prob": [0.01166967861354351, 0.8799833655357361, 0.3013239800930023]}, {"target": [1], "doc": ["@felixfbecker yeah , it would read the file directly", "i do n't think that would affect your language server process in any way though", "if / when they make performance improvement to tsserver you do n't need to make any change ."], "issue_sim": [0.20565932989120483, 0.24587653577327728, 0.10111868381500244], "prob": [0.011928455904126167, 0.7829322218894958, 0.7766664624214172]}, {"target": [0], "doc": ["that be a dealbreaker unfortunately , because the file be not available locally in the container ."], "issue_sim": [0.1446191519498825], "prob": [0.9999974966049194]}, {"target": [2], "doc": ["i have implement the initial version of language server protocol for typescript which can be find at <url>", "it act as a proxy for <tag>", "currently <tag> , <tag> and <tag> be implement but add other should be fairly easy .", "in the long term i would definitely love to see lsp ship as part of the official typescript installation"], "issue_sim": [0.4827924966812134, 0.12412945181131363, 0.36099323630332947, 0.15798164904117584], "prob": [0.015454336069524288, 0.0019337877165526152, 0.8787097334861755, 0.024200133979320526]}, {"target": [1], "doc": ["you can use <url> which more or less do the work of wrap tsserver message as lsp one", "i be close this issue as i be satisfied with <url> and would n't -as a consumer- get.any clear add - value if this be implement directly in tsserver ."], "issue_sim": [0.1766684651374817, 0.18550239503383636], "prob": [0.24073784053325653, 0.8391245603561401]}, {"target": [0], "doc": ["just run into this myself and notice that this break esm interop in node .", "per  it be possible to load esm file from commonj via <tag>", "therefore the dynamic import statement * * must * * not be transpile to <tag> call", "this be currently break when use typescript"], "issue_sim": [0.42734599113464355, 0.2846873700618744, 0.37774962186813354, 0.48703110218048096], "prob": [0.9407528042793274, 0.016235286369919777, 0.04696528986096382, 0.014766167849302292]}, {"target": [3], "doc": ["i can as i 've be ask about this in a few context", "today we assume that all require and import have the same end result post - transpilation , as either commonj or esmodule", "however , it be a bit more nuanced because node support the same keyword work differently depend on if you be in an esm context or commonjs context", "so in a commonjs context , you normally ca n't use <tag> , but you can use <tag> to import an esm module :", "what typescript think today be that this import should be switch to a <tag>", "which be what you want for exist case because that be a normal feature of <tag> statement", "it be a signal that the thing you be about to grab be a esm module", "what be tricky be that typescript have no way to disambiguate whether you want <tag> in a cjs context to continue be a <tag> or now stay as a <tag>", "we 'd either need a flag like the above which handle it app wide , or a pragma at the import call - site", "this seem to be hit a few big project because people want to have config file in esm but let the app stay in cjs"], "issue_sim": [-0.015741746872663498, 0.15358364582061768, 0.36526596546173096, 0.5385037660598755, 0.5767028331756592, 0.21991118788719177, 0.1924259066581726, 0.4885048568248749, 0.36675673723220825, 0.2904995083808899], "prob": [0.011201686225831509, 0.11675769835710526, 0.08827421814203262, 0.16904519498348236, 0.0004690586938522756, 0.0004610098258126527, 0.0004245619638822973, 0.1512083113193512, 0.0037189945578575134, 0.01199313998222351]}, {"target": [2], "doc": ["thank @dummdidumm for file this issue", "i be about to post the same thing about a week ago", "not transpile dynamic import be an important aspect to enable for node v12 + in regard to load esm for commonjs target ts effort .", "it will be use for a lot more than load configuration file", "i be an outside contributor ~~attempting~~  to get heroku / salesforce to add esm load capability to their  that be due for launch in the come month", "i have already work out the essential change with a proof of concept that be discuss in the issue link above , but it require a workaround", "oclif be a ts project which target commonjs for release", "one can build cli in commonjs or ts ; my propose change add esm to the mix which be quite relevant as the node ecosystem move to esm", "the least bad workaround i could come up with be the follow :", "<tag> which be use internally to an encapsulate addition for load esm via dynamic import or require for non - esm code -", "as an outside contributor i certainly could not touch the build process , so the above seem to do the trick until a flag can be add to typescript which be certainly desirable"], "issue_sim": [0.10133901983499527, 0.022120457142591476, 0.5343637466430664, 0.2138187289237976, 0.27165350317955017, 0.28042086958885193, 0.23667141795158386, 0.48510390520095825, 0.13181453943252563, 0.5000321865081787, 0.4348522424697876], "prob": [0.0018364033894613385, 0.001032914617098868, 0.11933440715074539, 0.0021235637832432985, 0.10538091510534286, 0.008321914821863174, 0.0006195568130351603, 0.08330881595611572, 0.0005928649916313589, 0.03363064303994179, 0.20180641114711761]}, {"target": [0], "doc": ["the beauty of <tag> be that it can import both esm and cjs :", "this be highly desirable to maintain interop as the ecosystem slowly move towards esm because i can import a file without know the module system", "the current all - or - nothing approach be too painful", "i would be okay with either solution , but the pragma would give the most flexibility if it can be configure per call site"], "issue_sim": [0.2272830605506897, 0.4168132543563843, 0.03757180646061897, 0.3725571036338806], "prob": [0.20740659534931183, 0.48061782121658325, 0.005646649748086929, 0.5503485798835754]}, {"target": [1], "doc": ["for future reference :", "a workaround for this issue can be have by move the <tag> to a non - compile dependency , such as  .", "big drawback of this , apart from it be confusingly non - standard , be that type wo n't get import", "that can be work around by manually import the type"], "issue_sim": [-0.05689001828432083, 0.4365360140800476, 0.19586361944675446, 0.3552144169807434], "prob": [0.011220091953873634, 0.9077919721603394, 0.20196077227592468, 0.059995137155056]}, {"target": [1], "doc": ["be you sure you do n't want a _ union _ type <tag> instead", "i be not sure how the intersection type <tag> make sense ."], "issue_sim": [0.200212299823761, 0.17086876928806305], "prob": [0.1264559030532837, 0.8442604541778564]}, {"target": [2], "doc": ["@arnavion why would a union be useful here", "i do n't think that would change anything", "i want to be able to use the intersection to override property of the initial object with valid assignment - in this case , reset they back to void  .", "edit : for example , i have one large interface and i want to specify that everything other than this property be require", "<tag> <tag> c <tag> <tag>", "this be a pretty common pattern for i - where i may have a function that define the ideal object and then some of it can be populate at a later time", "for instance , a database model that be currently two object but after the first object be store it add the <tag> to the second object", "currently i have to make a bunch of small interface and keep extend / intersecting to build they upward - but it require refactoring interface with each change instead of just override once"], "issue_sim": [0.14278115332126617, 0.17316268384456635, 0.4963701367378235, 0.26868507266044617, 0.35084837675094604, 0.2805527448654175, 0.1785704791545868, 0.3554076552391052], "prob": [2.4016160750761628e-05, 6.505641795229167e-05, 0.4523652493953705, 0.004375236574560404, 1.7929913838088396e-06, 0.006524204276502132, 0.0010083181550726295, 0.2805189788341522]}, {"target": [3], "doc": ["but really , the type do n't make sense", "you be try to do this :", "the compiler correctly complain about both the assignment , since neither <tag> nor <tag> can satisfy the type <tag>", "the valid value of the type <tag> need to be simultaneously a <tag> and <tag> , which be n't possible .", "it sound to i like you be actually look for a way to take an interface of normal property and produce an interface that have a subset of property miss or optional , like  or something like flow 's type operator  )", "so hypothetically where <tag> be the type subtraction operator , you 'd write something like :"], "issue_sim": [0.013075216673314571, 0.055763594806194305, 0.3661454916000366, 0.25635862350463867, 0.28845110535621643, 0.22574648261070251], "prob": [0.006395770702511072, 0.006308786105364561, 0.1552697718143463, 0.22402408719062805, 0.2720150053501129, 0.009571300819516182]}, {"target": [0], "doc": ["actually , this work on current typescript and any nightly - it be only appear if you enable <tag> as i mention in the original issue .", "you can try copy my original snippet into typescript and you 'll see it actually work"], "issue_sim": [0.6188478469848633, 0.47722551226615906], "prob": [0.8553759455680847, 0.11052701622247696]}, {"target": [1], "doc": ["<tag> and <tag> do have an observable difference - they can be differentiate by <tag> or the plain <tag> operator", "so i think it be well for ts to continue treat <tag> to mean a _ require _ <tag> property of <tag> type , and <tag> to mean an optional <tag> property ."], "issue_sim": [0.37911540269851685, 0.3813157081604004], "prob": [0.0826740637421608, 0.9548161625862122]}, {"target": [0], "doc": ["i be think a well approach would have be to add a flag to the <tag> file like <tag> rather than break browser base code .", "as of now it seem like the good way would be to make a break change in typescript <number> and move this change back and add in a flag", "in the interim it would be nice to have a flag that say <tag> that will stop the auto creation of <tag>", "i do n't know all the in and out of typescript and the decision make but this decision seem highly irregular for code that should also work in the browser and in service worker script"], "issue_sim": [0.4494645595550537, 0.3380342721939087, 0.18429279327392578, 0.4661065340042114], "prob": [0.3116146922111511, 0.2938808798789978, 0.02582329884171486, 0.5186160206794739]}, {"target": [0], "doc": ["typescript do not follow semver ."], "issue_sim": [0.3260093927383423], "prob": [0.9997804760932922]}, {"target": [2], "doc": ["i 'll check it out tonight", "regardless , this would be more of a work around", "typescript should not be add additional unneeded and unexpected code to our code base .", "this seem more like a tooling problem and should be an config set change"], "issue_sim": [-0.07535363733768463, -0.027571553364396095, 0.4568858742713928, 0.2615848183631897], "prob": [0.010260622948408127, 0.15246661007404327, 0.7718517184257507, 0.10087215155363083]}, {"target": [3], "doc": ["this be what firefox say when add the <tag> to the end of a script file that be n't a module", "as an error and it break the code", "and in chrome :", "so , long term this really need to be fix since it be clearly a bug on typescript 's side ."], "issue_sim": [0.31480997800827026, 0.24871176481246948, 0.057302363216876984, 0.28250449895858765], "prob": [0.8525742292404175, 0.055907487869262695, 0.0009382338030263782, 0.20621924102306366]}, {"target": [0], "doc": ["aside : even if we do follow semver , this would n't warrant a major version bump , because it be a change that increase our compliance with the ecmascript spec .", "anyway the file you write be a module  , and we be emit a file that be not a module  , so that be a bug", "it be always be the intend behavior that we do n't change the moduleness of a file during emit , this be just a miss case that never should have work this way in the first place", "you be free to suggest a new compiler option but this be the intentional behavior"], "issue_sim": [0.3105917274951935, 0.28938859701156616, 0.34548842906951904, 0.29439055919647217], "prob": [0.6094083189964294, 0.12150888890028, 0.5044402480125427, 0.010149890556931496]}, {"target": [2], "doc": ["type import be not the same as import actual javascript file", "regardless , i do n't think typescript should be create random code in our code base", "even if it be a module if i do n't want to export anything i should have some random <tag> append to my file .", "if the way forward be to make everything global , that be fine", "the behavior of inject random code into our code basis do n't seem right though"], "issue_sim": [0.3583706021308899, 0.48609715700149536, 0.2795589566230774, 0.11376692354679108, 0.4868757426738739], "prob": [0.00024199180188588798, 0.30285730957984924, 0.16504202783107758, 5.926278026890941e-05, 0.024815751239657402]}, {"target": [24], "doc": ["first i want to link # <number> , which i  e been use as the canonical issue to reconsider this behavior", "i also  in some detail how auto - import work today and some idea  about how we could change they to solve this", "i want to expound on this a little bit for the benefit of other who aren    as familiar with what this mean , and to emphasize   otentially breaking", "what you  e get at here , which i also explain in # <number> , be that today , auto - import for a particular module be offer if and only if that module be already part of your whole - program compilation , which be determine by :", "- the file cover by <tag>/<tag>/<tag> in your tsconfig", "- the lib file cover by <tag> in your tsconfig", "- the type definition cover by <tag> and <tag> in your tsconfig", "- the recursive dependency of all of the above", "any file match by these criterion be automatically parse and bind , and type - check to some degree , depend on the file location and <tag>", "* * the information produce by parse , bind , and check these file be central to the ability to offer auto - import from they", "* * at the same time , though , these criterion be also use when compile a program with <tag> on the command line", "on one hand , we  e see in the past that automatic type inclusion , or even inclusion of additional type by recursive dependency , create problem of  , which have be the subject of many other discussion and", "i have personally advocate in the past for ease some of the pain of this problem by _ not _ eagerly include all of <tag> in program", "the detail of global / environment collision aren    super important here ; rather , my point be that we know automatic type inclusion _ do _ break people , and there be potentially some merit  to do _ less _ of it when we look at other problem", "but on the other hand , do less of it can also make typescript unaware of global declare by <tag> package , which be also break", "in other word , * * any change to the rule that govern what file a program contain , include default value of relate tsconfig option , be a significant breaking change * *", "a part of i think it would make a lot of sense to use package", "json file to guide type definition inclusion , and stop give special behavior to <tag>", "it would solve the auto - import problem automatically , and in some case it would prevent unwanted inclusion of definition like <tag> that can sometimes cause problem", "but another part of i think that   a really hard sell for a break change to tsc", "i think it   worth talk about , but my assumption in think about this so far have be that it   not go to be on the table", "in that case , the only option be , as you say , add a language - service - specific implementation that doesn    affect program semantic , and doesn    touch tsc at all", "so , a couple thought on that :", "i completely agree with this", "if people have package list in their package.json , theye go to import or reference they somehow .", "i    not at all concerned about the memory impact of load type from package", "json - list dependency ; i    only concerned about their semantic impact on the program", "so if we need a way to isolate these type from influence the core program , how do we do that", "load they into a second program", "that would take care of all the parsing , bind , and check that auto - import rely on , but it would duplicate a lot of work and type and symbol from common lib file   that   _ the concern i have with memory", "we should do some experiment and see what the cost of that really be", "i also think it   worth see how much we can do with parse and bind alone", "but both of these idea be pretty complicated in an editor scenario , where the user be continually instal and uninstalle node module and change the shape of the core program by add and remove import", "- i guess i didn    comment on whether your proposal be the right expect behavior , because i  e think it   the right expect behavior since i get here , and i always imagine # <number> as the first step in a process toward that goal", "- i want to hear thought about change default type definition inclusion rule to look at package", "json before rule it out", "- assume we don    change type definition inclusion rule , i want to hear more thought on an editor - specific implementation", "what have i miss in my analysis", "be there a simple approach", "do other agree with my assessment of the complexity of the approach i  e mention"], "issue_sim": [0.3202611804008484, 0.19502022862434387, 0.15595270693302155, 0.48676496744155884, 0.0288261566311121, 0.1968556046485901, 0.23773369193077087, 0.19353647530078888, 0.25897926092147827, 0.18802329897880554, 0.2753112316131592, 0.375085711479187, 0.3100496232509613, 0.2730224132537842, 0.33968067169189453, 0.2951107323169708, 0.2617579698562622, 0.40076959133148193, 0.47114098072052, 0.09905799478292465, 0.05468278005719185, 0.36166054010391235, 0.005632245913147926, 0.050689779222011566, 0.26765763759613037, 0.2959325313568115, 0.2821715772151947, 0.19034528732299805, 0.042941123247146606, 0.39789867401123047, 0.051965512335300446, 0.15595658123493195, 0.27991122007369995, 0.27413493394851685, 0.43335801362991333, 0.06336928904056549, 0.34403592348098755, 0.12924060225486755, 0.045670703053474426, 0.10709992796182632], "prob": [0.06376753002405167, 0.02720450423657894, 0.0015856098616495728, 0.10541924834251404, 0.0008929504547268152, 2.1693233065889217e-05, 0.00019642490951810032, 0.000525199226103723, 0.016030918806791306, 0.0001593656197655946, 0.00026673704269342124, 0.004576425999403, 5.539385892916471e-05, 0.002544099697843194, 0.0005312373978085816, 0.008367536589503288, 8.031100878724828e-05, 8.172013622242957e-05, 0.0017342539504170418, 1.2247149243194144e-05, 0.0010981897357851267, 0.06211041286587715, 4.3864583858521655e-06, 3.260026278439909e-05, 0.006911742500960827, 1.804534122129553e-06, 7.494531928387005e-06, 1.2390726624289528e-05, 7.720542498645955e-07, 0.003093436826020479, 2.8473739348555682e-06, 6.191982720338274e-06, 0.005557096563279629, 0.01057269237935543, 3.775899313041009e-05, 7.0232358666544314e-06, 0.000349689886206761, 0.00013631708861794323, 0.0001501627266407013, 0.0005368484416976571]}, {"target": [1], "doc": ["i 'll need to read through this tomorrow for any lucid feedback , but be there anything we can learn from roslyn 's version of this for c #", "i think theirs even recommend thing from package you do n't yet have instal , so i imagine they 've put work into the appropriate heuristic for this , albeit tune to their user base ."], "issue_sim": [0.2940444350242615, 0.20000827312469482], "prob": [0.6597998738288879, 0.5517792105674744]}, {"target": [0], "doc": ["have different file in program from what they be in <tag> be bad idea as that result in discrepancy or error / non error and that get confuse .", "i think the idea of different program to support the auto import seem well one"], "issue_sim": [0.2113153338432312, 0.34258294105529785], "prob": [0.9826406836509705, 0.002804382471367717]}, {"target": [9], "doc": ["as the person who open # <number> , which be link to this issue , let i just provide one user 's viewpoint", "i look at # <number> and see that only import from package", "i can understand need to limit the scope of what you provide auto - import for , and if package", "json be the limit then i will work with that", "that be say , sometimes package provide function / etc", "that reference type  from other package , which may be in their own package", "you could consider a scheme that import from a project 's package", "json , and then through all dependency of the package list in that package 's package", "it could go <number> level deep , or even fully recursive", "perhaps the number of level could be configurable by some property to allow user to chose the balance betwee performance and coverage .", "i do n't pretend to know all the under - the - hood detail here , and look at the link issue i can see that there have be signficant discussion on this issue to date", "and i understand that this be just one use case in a sea of many", "so take my input with a grain of salt , and perhaps it will prove useful"], "issue_sim": [0.15540552139282227, 0.3535098433494568, 0.48179566860198975, 0.11899860203266144, 0.17691591382026672, 0.23204688727855682, 0.37453174591064453, 0.42427971959114075, 0.0778062641620636, 0.15801751613616943, 0.17109796404838562, 0.050733983516693115, 0.05297209322452545], "prob": [0.149749755859375, 0.0011212899116799235, 0.03605353832244873, 7.489737618016079e-05, 0.0005234849522821605, 0.002875996520742774, 0.0006269810837693512, 0.005074324551969767, 0.0016841826727613807, 0.29022732377052307, 0.18752458691596985, 8.686852379469201e-05, 0.003060577204450965]}, {"target": [1], "doc": ["@amcasey be correct , but it sound like @ilcallo   concern be  that", "type discover by the auto - import provider would leak into type checking , negate any carefully define project boundary and <tag>/<tag>/<tag> configuration setting", "that   not the case  ny type discover by the auto - import provider be isolate into a separate type checker , so this pr have zero effect on compilation or error expose by your editor", "even if type within the auto - import provider conflict , those error will never be surface", "@ilcallo do i understand your concern correctly , and do my answer address it", "edit : i think this comment be on my pr , not on the original issue , which might be a source of confusion", "some of the approach discuss here _ would _ have create the problem i just describe , but we have pretty much settle on an approach that avoid it , which be in progress here : <url>"], "issue_sim": [0.09683766216039658, 0.3144828975200653, 0.4051405191421509, 0.2534867525100708, 0.0724351778626442, 0.03252117335796356, 0.19782134890556335], "prob": [0.0032032416202127934, 0.4801775813102722, 0.5007897615432739, 0.009525575675070286, 0.0020571970380842686, 0.0022971834987401962, 0.3056473433971405]}, {"target": [0], "doc": ["i would expect these to break only if you misspell an option , which wo n't work anyway .", "i be just curious what other breaking changes be you think about @ryancavanaugh"], "issue_sim": [0.16817152500152588, 0.15383224189281464], "prob": [0.9175947308540344, 0.0004548550059553236]}, {"target": [1], "doc": ["i 'd love to see this discuss , or move forward", "to i , move runtime exception out of js into hard compile - time error in typescript be one of the strong point of typescript to begin with ."], "issue_sim": [0.06353078782558441, 0.4887574315071106], "prob": [0.005026873201131821, 0.9961169958114624]}, {"target": [1], "doc": ["here be a break change :", "the author of <tag> will have to propagate the strict type of <tag> out , possibly break its consumer ."], "issue_sim": [0.13385680317878723, 0.25750625133514404], "prob": [0.11574302613735199, 0.7602410316467285]}, {"target": [0], "doc": ["s there some process where you tag all pr : s with fix for under - specify type like this by something like \" improvement for next major version bump \" , so you can land a busload of such fix in batch whenever you decide that enough of those have pile up since last time , or that you be just about to release a major version bump anyhow , because of some non - type - relate fix to typescript itself", "if not , i think it would be a good process to introduce , so we do n't get stick forever with a lot of dom / tc39 type that be a notch or two well than the <tag> type ."], "issue_sim": [0.39811205863952637, 0.1707020103931427], "prob": [0.9602870941162109, 0.2085943967103958]}, {"target": [1], "doc": ["much or most of the value a strict type here bring _ be _ in flag illegal string value as illegal", "the documentation aspect of call out a few explicitly legal value be nice , but we 'd miss the catch bug at compile time aspect for everything else that the browser definitely explode on ."], "issue_sim": [0.12656794488430023, 0.4014322757720947], "prob": [0.3028531074523926, 0.6365779042243958]}, {"target": [0], "doc": ["we do n't like to replace basic ts declare unless necessary , so we extend the base .", "for that reason i just create a complete type from the mdn doc"], "issue_sim": [0.14305907487869263, 0.30345314741134644], "prob": [0.8367279171943665, 0.08613575994968414]}, {"target": [0], "doc": ["seem like a legit bug , but as a side note , a little strange to resolve a promise from a promise executor callback .", "promise executor should basically be reduce down to the low level that be n't already promisifie", "if you already have a promise in the executor , then you could just make that your promise call , instead of create a wrapper promise around a promise"], "issue_sim": [0.4038969576358795, 0.13731025159358978, 0.4196290969848633], "prob": [0.7458037734031677, 0.0012208841508254409, 0.8629342317581177]}, {"target": [1], "doc": ["we have the same problem", "we wrap unknown return type into an additional promise and can get stick with a resolve type of <tag> if the original type be a promise .", "this nest promise however be problematic :", "here , <tag> be wrongfully see as a <tag> while <tag> be correctly see as <tag>", "why do <tag> and <tag> behave differently", "also why ca n't we assign a <tag> to a <tag> variable", "this be valid js since nest promise always unwrap"], "issue_sim": [0.023237060755491257, 0.4216316342353821, 0.22974027693271637, 0.2971675395965576, 0.23515835404396057, 0.11253000795841217, 0.5060276985168457], "prob": [0.0012320162495598197, 0.9342405796051025, 0.005435708910226822, 0.5075487494468689, 0.00088683603098616, 0.0035328816156834364, 0.0019312385702505708]}, {"target": [4], "doc": ["@oresoftware it do not matter how often you nest a promise , the result be the same :", "this be just how promise work", "you simply can not get the \" inner \" promise , it be go , flatten .", "i be not say that the type <tag> be wrong , it might just be the result of a function , wrap something into a promise", "however , typescript should always collapse nest promise when type checking and compile because that be what javascript do"], "issue_sim": [0.19997936487197876, 0.1883174180984497, 0.12155230343341827, 0.4265625476837158, 0.4984745681285858], "prob": [0.018920177593827248, 0.003064133692532778, 0.7639569640159607, 0.22358077764511108, 0.42093372344970703]}, {"target": [0], "doc": ["the <tag> type seem break :"], "issue_sim": [0.20067198574543], "prob": [0.9989232420921326]}, {"target": [0], "doc": ["the solution would be for <tag> not to re - wrap if it be already a <tag> .", "that way , we can never end up with nested <tag>s", "here be a little proof of concept :"], "issue_sim": [0.272024005651474, 0.030278967693448067, 0.07207982987165451], "prob": [0.8735828399658203, 0.03205874562263489, 0.023383235558867455]}, {"target": [3], "doc": ["how much value do all this work get we over a simple textmate like solution", "we have to maintain a tmlanguage file anyway for our sublime plug - in , and editor such as sublime or atom manage fine with textmate base solution", "yes there be a few case where you can get a token that be n't colorize perfectly , but this be rarely a cause of notable user confusion or complaint", "i think we should be very practical and deliberate in assess just how much complexity we want to add  , compare to the real value we get out of it ."], "issue_sim": [0.16704416275024414, 0.14315882325172424, 0.21297436952590942, 0.12342188507318497], "prob": [0.05359536036849022, 0.6629970073699951, 0.19624370336532593, 0.24676965177059174]}, {"target": [1], "doc": ["@cyrusnajmabadi and @vladima can weigh in on this ,", "but my understanding be that even if we have one classifier for the entire file , it will still marshall a very large string over to vs , and the performance will be just as bad .", "and it will cause lag while type , since it will be on the ui thread"], "issue_sim": [0.042092423886060715, 0.38063573837280273, 0.1443651169538498], "prob": [0.013731841929256916, 0.9270855188369751, 0.11206042766571045]}, {"target": [2], "doc": ["i do n't follow", "would n't this all be vs side where it already have the text buffer available", "same as sublime and atom , they do n't give the buffer to the language service to colorize , they do the work themselves base on the editor buffer and the syntax specify by the tmlanguage file ."], "issue_sim": [-0.06023036688566208, 0.08439896255731583, 0.24984565377235413], "prob": [0.013757138513028622, 0.11535810679197311, 0.964937150478363]}, {"target": [0], "doc": ["i do n't think a pay user of vs would find something like that acceptable , and i would think that down the line , the other editor should also use our classifier , provide that the experience provide can feel fluid .", "side note : @cyrusnajmabadi template work pretty well ; that do n't tend to be a problem with the tmlanguage format"], "issue_sim": [0.3372212052345276, 0.19049692153930664], "prob": [0.9462970495223999, 0.007800585124641657]}, {"target": [3], "doc": ["i be curious why we be call the \" textmate \" solution ' simple '", "to i it be much more complicated than an actual syntactic classifier", "in order to get it ' right ' you need to find a way to effectively support context free grammar in a regexp - orient framework", "even if that be something support well by tm solution , you 'd still effectively be build a parser / grammar in that world ts so that you can properly classify thing", "this seem _ order of magnitude _ more complex to i than just reuse the exist parser / syntax model _ we already have _ ."], "issue_sim": [0.2047228366136551, 0.4286801517009735, 0.3095186650753021, 0.3800262212753296, 0.4254048466682434], "prob": [0.02211129665374756, 0.08688664436340332, 0.22586727142333984, 0.2221275120973587, 0.10002565383911133]}, {"target": [2], "doc": ["you be right , we only need two new group", "i wholeheartedly agree with @cyrusnajmabadi that have two or more implementation of the grammar be not simple", "especially because the grammar change frequently , this mean a high marginal cost for grammar change ."], "issue_sim": [0.01953972317278385, 0.249891459941864, 0.1937650889158249], "prob": [0.0024157436564564705, 0.14294512569904327, 0.747878909111023]}, {"target": [3], "doc": ["but we already maintain a well grammar / tree already for tsc", "js , and all other feature as well", "the tm solution seem necessary because we be plug into system that only support that more complicated system", "for system that be n't so limited , i 'd far prefer we just use the actual correct single tree that we use for literally every other feature in the ls"], "issue_sim": [0.20739352703094482, 0.04490489512681961, 0.09640571475028992, 0.18144197762012482], "prob": [0.009858690202236176, 0.02646470069885254, 0.03955920413136482, 0.8944120407104492]}, {"target": [0], "doc": ["all the idea in the proposal relate to multiple tagger and certain tag override other be base on how our semantic classifier work .", "and the semantic classifier work very well , and do the right thing , and be low cost", "we have have good experience with it", "it add teal coloring to all the type , and yet we do not think of that as over the top", "why not do the same with the syntactic classifier"], "issue_sim": [0.5399237871170044, 0.3448370397090912, -0.004597007296979427, 0.16572794318199158, 0.4675902724266052], "prob": [0.9668735861778259, 0.13835681974887848, 0.0011456428328529, 0.1264481395483017, 0.009288032539188862]}, {"target": [3], "doc": ["the case of <tag> i believe this be different from the <tag> and <tag> problem", "in the <tag> and <tag> case , it would be incorrect for typescript to assume that the only key on the object be limit to those on the type", "in the case of <tag> however , typescript _ can _ guarantee that the object it return will _ at least _ have the set of key it know about on the incoming tuple array", "i recommend remove the <tag> case from this request as that can not change without break typescript type safety", "i think <tag> can be fix though"], "issue_sim": [0.19196373224258423, 0.5504169464111328, 0.48551416397094727, 0.6021268963813782, 0.1611333191394806], "prob": [0.0073188310489058495, 0.4903603792190552, 0.6622498631477356, 0.0003446612972766161, 2.526619573472999e-05]}, {"target": [3], "doc": ["in that case , i guess the <tag> problem could be solve by a 3rd - party library that implement runtime extraction base on a type / interface , simply for the sake of not write these function by hand", "would generate  a function that take an object and return the field of <tag> only by call <tag> and then call <tag> to only return the subset contain in <tag>", "or something like that", "assume the object.fromentries proposal be accept , this would work perfectly well for we , although in our particular case we would n't need the <tag> overhead from such a library as the value pass around in our app never satisfy two separate type .", "at least so far", "but then again , this seem to fall outside of the intend use of typescript itself", "i stumble upon <url> and <url> today", "could use its source code as a starting point if <number> be accept and its easy to plug into ts for code generation"], "issue_sim": [0.4594862163066864, 0.4548325538635254, 0.06608769297599792, 0.3624430298805237, 0.04434320703148842, 0.36737990379333496, -0.004734992049634457, 0.2805745601654053], "prob": [0.4253830015659332, 0.6885406970977783, 8.569766941946e-05, 0.3563632667064667, 9.653490269556642e-05, 0.004247342236340046, 7.053857552818954e-05, 0.030243635177612305]}, {"target": [0], "doc": ["just as a starting point for thing we need in the proposal , there be no such thing as \" partial assignability \" ."], "issue_sim": [0.09998603165149689], "prob": [0.9999961853027344]}, {"target": [1], "doc": ["i be lack proper terminology sorry", "out of all possible combination of type a , ... , z use operation of <tag> and <tag> a type guard assert a value being of a separate constituent type should be allow :", "in other word : anything that , accord to the type be assert , be possible should be able to be the target type of a custom type guard"], "issue_sim": [0.11682920902967453, 0.38145971298217773, 0.42393794655799866], "prob": [0.0027871925849467516, 0.9237060546875, 0.24201074242591858]}, {"target": [2], "doc": ["to sure i get it", "not only intersection , but union too :", "i get it : any sub - type - expression    of the type - expression be assert against should be a valid target of a type guard :"], "issue_sim": [0.02407529018819332, 0.13683268427848816, 0.3837421238422394], "prob": [0.16099825501441956, 0.10812046378850937, 0.6763217449188232]}, {"target": [0], "doc": ["you do n't need a special rule for union type because it be already the case that <tag> be assignable to <tag>"], "issue_sim": [0.3366377353668213], "prob": [0.9999403953552246]}, {"target": [0], "doc": ["because  be what type guard do ! : stuck_out_tongue_winking_eye :"], "issue_sim": [0.25036704540252686], "prob": [0.999754011631012]}, {"target": [3], "doc": ["@yortus   i understand the mechanic of how it work now and you be right   in what you say", "i be question the very premise that narrowing ca n't go beyond a member of a union type", "i see no reason why it ca n't", "what i be suggest be that narrowing should be allow to any sub - expression include lone term ."], "issue_sim": [0.02007545530796051, 0.25126326084136963, 0.26815012097358704, 0.20931145548820496], "prob": [0.003939702641218901, 0.3353728652000427, 0.000894030265044421, 0.9633828401565552]}, {"target": [0], "doc": ["so while allow narrow <tag> to <tag> seem pointless in the simple case  , with more complex type expression it make type guard much clear without diminish type safety ."], "issue_sim": [0.3761709928512573], "prob": [0.9999872446060181]}, {"target": [0], "doc": ["type guard return must be a subtype because they introduce new property in their guard expression , not remove they"], "issue_sim": [0.3883724808692932], "prob": [0.9996192455291748]}, {"target": [0], "doc": ["hmm , it be an intentional decision that <tag> wouldn change the behavior of elide the actual import name ; it would just keep the module dependency graph as you write it .", "be there any use case for this besides stringified execution"], "issue_sim": [0.4860857129096985, 0.22486968338489532], "prob": [0.9516036510467529, 0.001735095283947885]}, {"target": [10], "doc": ["ok , i think that be fair", "i be hope this feature would achieve preservation of the original js code , i", "avoid dead identifier elimination", "but i see it do not have that ambition so this be not a bug and i will close it", "and having write all this up , i be now think that be an unreasonable assumption on my part", "as background , this issue be detect because we ban the <tag> form  in a build rule that operate after ts->js conversion - and that be errore despite the source code not use that form - but i view that as an \" we \" issue and not convince general argument", "i be also try to test some name - shadow behavior by disable the type - checker but be thwart - again this be not a practical use - case", "answer your question , i think stringified execution be the only practical case", "in this case , it seem there be no way to get typescript to emit  even if you disable the checker", "so instead , when you detect in your test or runtime execution that the code be faulty ,  to prevent the compiler from eliminate it", "imo this be a * * super - mild * * case of break the js+types model because we ca n't passthrough plain js .", "it be an unavoidable transform", "maybe it be also a category mismatch because typescript be kinda do the work of a minifier", "other simplistic form of dead code , such as unused <tag> declaration , be not eliminate", "i appreciate that eliminate type name from the import statement be essential core functionality , and that _ \" not statically detectable as a use value \" _ be a neat heuristic / approximation for achieve that", "fix that whilst preserve isolated 1:1 per - file transpilation seem to require more thought", "i think this be worth think about for the future but it be not an urgent matter"], "issue_sim": [0.02126961760222912, 0.4222659468650818, 0.0730547234416008, 0.07510048151016235, 0.017834410071372986, 0.36936497688293457, 0.4273720383644104, 0.119654580950737, 0.4542027711868286, 0.311798632144928, 0.26544782519340515, 0.11872140318155289, 0.41826170682907104, 0.15266630053520203, 0.38190072774887085, 0.18895864486694336, 0.05605839192867279], "prob": [0.004540595225989819, 0.012816376984119415, 0.0001601766562089324, 0.001935213222168386, 0.018813567236065865, 0.27910295128822327, 0.03144710138440132, 0.0015155449509620667, 0.014243248850107193, 0.0023184262681752443, 0.025457529351115227, 0.00043792364886030555, 0.009152967482805252, 0.003380598733201623, 0.18044544756412506, 0.015088832937180996, 0.011786107905209064]}, {"target": [0], "doc": ["so this same thing come up in the context of svelte transpilation processhey have to write a custom transformer to re - add back import that be remove because they look unused , but be in fact use in template code , which ts doesn understand .", "move some conversation from # <number> and continue it here", "in # <number> i propose a mode where :"], "issue_sim": [0.4509325623512268, 0.057707782834768295, -0.014385901391506195], "prob": [0.9972737431526184, 0.003736811922863126, 0.0023910978343337774]}, {"target": [4], "doc": ["thank you for revive the issue @andrewbranch", "i see how svelte need this same _ \" just remove the type \" _ mode", "i like where this be go", "the mode you propose above sound reasonable and will solve the problem", "it mean the whole import statement be either retain or eliminate base on whether it be a type - only import or not .", "there be a potential extension to the above mode", "which be to introduce new syntax for explicit * * type - only identifier * *", "i read this be already support by flow and hegel but can not find support documentation", "i think we would still need your new mode in order to error in the case where <tag> or <tag> have no value export in <tag>", "the benefit of explicit type - only identifier be ergonomic", "it help keep the code dry", "otherwise some people may be disappoint to find they must write two independent import to pull in a value and a type from a module", "please say if you think this extension be well handle in a separate issue - i would be happy to create it"], "issue_sim": [0.04838269203901291, 0.2266719788312912, -0.016021298244595528, 0.06342263519763947, 0.2663787007331848, -0.0662665143609047, 0.24032486975193024, 0.20469608902931213, 0.3556807041168213, 0.14324960112571716, 0.12873665988445282, 0.22756901383399963, 0.32426559925079346], "prob": [0.0007062614313326776, 0.013241441920399666, 0.0017980216071009636, 0.0020636145491153, 0.31649547815322876, 0.0010997364297509193, 0.008202534168958664, 0.008382909931242466, 0.5449551939964294, 0.0008502064156346023, 0.00045319111086428165, 0.048792775720357895, 0.015231916680932045]}, {"target": [1], "doc": ["i be also in favor of es2015 +", "as you say , this be not to please stylistic preference but to solve transpilation constraint .", "and through time this problem will hopefully solve itself when the ecosystem as a whole have move towards esm"], "issue_sim": [0.11723741888999939, 0.19337129592895508, 0.1441301852464676], "prob": [0.02245270274579525, 0.8529964685440063, 0.11697988212108612]}, {"target": [1], "doc": ["require <tag> to use the new <tag> mode seem reasonable", "the primary use - case here be to minimize source transform and just erase the type syntax , to cater for code / tool whose runtime behavior be break by todays dead - identifier transform .", "i foresee it be use most commonly in toolchain that also use <tag>", "there be a quote from paul rudd in forget sarah marshall that i think apply here : _ \" the less you do , the more you do \" _", "the stylistic / lint use - case be new to i", "personally i feel similar to @dummdidumm and would prioritize functional need over aesthetic", "implement this for commonjs , whilst feasible , feel like unnecessary work to i", "if the demand for this feature with non - esm module target arise in future , maybe the requester could create an eslint rule as @milahu suggest"], "issue_sim": [0.2874794006347656, 0.4475224018096924, 0.2633171081542969, -0.03022897243499756, 0.18350568413734436, 0.17503446340560913, 0.14498677849769592, 0.2895388901233673], "prob": [0.01521885022521019, 0.4723023474216461, 0.010924293659627438, 0.3505355715751648, 0.0006998828612267971, 0.0008641777094453573, 0.008592182770371437, 0.050885092467069626]}, {"target": [2], "doc": ["cc @chuckjaz as we have a chat with about this issue", "so why do you use <tag> to do the load", "i would expect you just use <tag> all the time , give that there be no language service operation need here ."], "issue_sim": [0.14782802760601044, 0.20630234479904175, 0.2578403353691101], "prob": [0.011549882590770721, 0.008686574175953865, 0.9973830580711365]}, {"target": [2], "doc": ["cc @s - panferov @jbrantly , please chime up if i be not explain this right", "@mhegazy @chuckjaz so i say above that webpack be responsible for serve individual file _ one at a time _ to a loader", "in that case , you ca n't use compilerhost on one ts file at a time  .", "lsh provide the ability to build up your program of file , and then additionally update they only compile that one file in the context of the program", "be there something i be miss"], "issue_sim": [0.024468228220939636, 0.676985502243042, 0.20738141238689423, 0.23428909480571747, -0.018549947068095207], "prob": [0.004648953676223755, 0.0013314582174643874, 0.9567373394966125, 0.17187084257602692, 0.0028113112784922123]}, {"target": [4], "doc": ["the languageservice api  , and the matching host , languageservicehost  , be build for ide / editor scenario", "the ls be mainly design to be able to answer question like get completion at position , quick info , format edit , etc", "one thing that the ls have to do well be update the state after an edit", "the compiler api ,  , and the match host implementation , compilerhost , be design for generate output and error give a set of source", "obviously there be an overlap . the ls be a high level abstraction than the compiler api .", "but , assume i understand your need correctly , you do not really need it", "if i understand correctly , what you need be give some source file , generate js / map / declaration , and compute error", "and once you build that state , you want to keep it in memory and reuse it if one or more file change , and quickly regenerate error and output", "if this be not an accurate representation of your scenario please let i know", "generate output and error be do through <tag> and <tag>", "cache state , and reuse it be do through two thing :", "cache sourcefiles  , i", "if a file do not change , do not parse it again", "reuse program structure : i", "do not resolve module on disk if the file have not change and we resolve they before", "for reuse the sourcefiles , the compilerhost api have <tag> method specifically for this", "it allow you to chose either to parse it , i", "call <tag> or get it from a cache , say a previous program object that have parse this file , e", "this be what the <tag> implementation do", "the second be achieve by pass the old program to the <tag> call , see <url>", "the ls can do this for you as well , as part of other thing , but as note before , you do not need the ls to do this", "i think the request here be for an api , that give a program instance , and a set of edit , generate a new program with reuse as much as possible", "if this be accurate , then we can definitely do that"], "issue_sim": [0.23363716900348663, 0.0488717183470726, -0.03622698783874512, 0.24424225091934204, 0.10321605205535889, 0.016581859439611435, 0.35024696588516235, 0.27001243829727173, 0.07590573281049728, 0.22458994388580322, 0.16515929996967316, 0.11655495315790176, 0.18154580891132355, 0.021602127701044083, 0.2666133940219879, 0.24660784006118774, 0.07706038653850555, 0.23847487568855286, 0.09916725754737854, 0.042830754071474075, 0.14963334798812866, 0.15875835716724396, -0.004173273220658302], "prob": [0.01818056032061577, 0.044371362775564194, 0.08508319407701492, 0.09382195770740509, 0.13199685513973236, 0.006383878644555807, 0.05539447069168091, 0.016328684985637665, 0.0014373405138030648, 0.002902805805206299, 0.002617861609905958, 0.0005881552351638675, 0.0014742892235517502, 0.0006608719704672694, 0.006157456897199154, 0.013829478062689304, 0.0008786814869381487, 0.00487352954223752, 0.0004247449105605483, 0.007248005364090204, 0.13807915151119232, 0.12576070427894592, 0.0074757179245352745]}, {"target": [7], "doc": ["first , i want to thank you and @danielrosenwasser for the support while you guy be in the midst of a crazy busy and awesome ts2", "i apoligize if this response be messy but its hard for i to track everything in both loader to ensure that the right thing be do here", "not quite , what be need be :", "* * that give a program instance , and a _ single edit _ , generate the follow :* *", "- the * * single * * transpile file", "- give access to <tag>", "- the <tag> for the transpiled file", "this allow loader to add dependency into webpack dependency system"], "issue_sim": [0.12784238159656525, 0.2198227047920227, 0.003369388170540333, 0.05044375732541084, 0.2195495069026947, -0.01229930017143488, 0.221817284822464, 0.6545533537864685], "prob": [0.6260521411895752, 0.4497982859611511, 0.002851613564416766, 0.030023252591490746, 0.000149917061207816, 0.0002723261422943324, 0.0018177811289206147, 0.0012809630716219544]}, {"target": [0], "doc": ["the dependency graph be not something that be provide today by the ls or the compiler api .", "so we can use this issue to track add it"], "issue_sim": [0.24516472220420837, 0.06605289876461029], "prob": [0.8632027506828308, 0.022902676835656166]}, {"target": [1], "doc": ["the compiler will still emit code in the presence of error unless give the <tag> flag", "emit in the face of syntactic error be a good - effort emit with no guarantee in syntactic validity ."], "issue_sim": [0.47512295842170715, 0.34638774394989014], "prob": [0.5235313177108765, 0.8482065796852112]}, {"target": [2], "doc": ["this code should be support on all browser , give <url>", "i appreciate the <tag> flag when do development , but this do n't help when our ci block deploy when there be a compile error , and there be no option to disable error on line  )", "i strongly object to the <tag> tag here , since a well design would be to avoid trigger a compile error at all .", "the post workaround be unnecessarily verbose"], "issue_sim": [0.21505384147167206, 0.47604697942733765, 0.45999252796173096, 0.2470996379852295], "prob": [0.02356378734111786, 0.8103382587432861, 0.15778294205665588, 0.01277631800621748]}, {"target": [1], "doc": ["the <tag> property will only be correct if the constructor function choose to initialize it", "although typescript generate code to do so , it be not a requirement and you ca n't generally rely on it for an arbitrary constructor function  .", "for that reason typescript do n't strongly type the <tag> property"], "issue_sim": [0.3351607322692871, 0.3386484384536743, 0.21706852316856384], "prob": [0.02316765859723091, 0.9842377305030823, 0.014726342633366585]}, {"target": [3], "doc": ["i ca n't find any evidence support this", "all runtime seem to hook this up automatically", "i ca n't find any evidence support this , either", "the es spec do n't define that this property be present as a result of object creation ."], "issue_sim": [0.01064113900065422, 0.17790192365646362, 0.006391055881977081, 0.27906712889671326], "prob": [0.03165081515908241, 0.06647294014692307, 0.04630132019519806, 0.9084630608558655]}, {"target": [0], "doc": ["mdn  the relevant spec near the bottom of the page - this be the most relevant :"], "issue_sim": [0.060204051434993744], "prob": [0.9999755620956421]}, {"target": [1], "doc": ["@jiaweihli but all that say be that the actual field <tag> point to <tag>", "it do n't imply anything about whether or not <tag>'d value automatically get a <tag> property ."], "issue_sim": [0.24430398643016815, 0.19461563229560852], "prob": [0.03666416555643082, 0.9436471462249756]}, {"target": [0], "doc": ["this be a geneneral temporal dead zone issue in javascript ."], "issue_sim": [0.25034746527671814], "prob": [0.9999696016311646]}, {"target": [0], "doc": ["as long actual result be different from expect result , its hard to call it \" this be correct \" .", "i understand that there be not too much workforce to fixe all issue , but you should choose one of :", "- mark it as know issue , that maybe in future it will be fix", "you admin that current behavior differ from ideal , expect one", "- mark decorator feature in documentation as \" sometimes might work , sometimes not \" and live with that", "- add compiler warning for case when it might occur", "- remove decorator feature completely"], "issue_sim": [0.30110231041908264, 0.16944585740566254, 0.18072566390037537, 0.13531671464443207, 0.2593878209590912, 0.2861097753047943, 0.18132328987121582], "prob": [0.9671795964241028, 0.06607367843389511, 0.0022347706835716963, 0.0009399388218298554, 0.05724150314927101, 0.04274652525782585, 0.008584480732679367]}, {"target": [6], "doc": ["this be not special to decorator", "you can observe the :", "the issue be in javascript name binding be hoist to the top of the scope , but they be undefined until first initialize", "this be really hard for a static analysis tool / compiler to detect correctly all the time", "as the same code can be valid if your variable be define", "consider wrap the first class in a function declaration as :", "the only possible way i can think of be to make <tag> a function instead of an array , this mean a dispatch call on every query , which can be expensive ."], "issue_sim": [0.04906157776713371, -0.0067654019221663475, 0.5231955051422119, 0.25078606605529785, 0.34526747465133667, 0.2635418176651001, 0.43265289068222046], "prob": [0.004673946648836136, 0.002444509882479906, 0.3055625259876251, 0.04481618106365204, 0.014578481204807758, 0.006637937389314175, 0.6005737781524658]}, {"target": [4], "doc": ["that be true when you write sequential code", "statement after statement , function after function etc", "in initial example add last line \" var f = new a ) ; \" result that a", "ctor will have non null param argument", "in ts code there be nothing that indicate you be refer to something that be not define yet .", "still not understand why it s correct behavior"], "issue_sim": [0.15150927007198334, 0.24870720505714417, 0.3491905629634857, 0.27634724974632263, 0.3846747875213623, 0.10534064471721649], "prob": [0.0010027624666690826, 0.004898512735962868, 0.017411286011338234, 0.00013721801224164665, 0.8717437386512756, 0.0012258188799023628]}, {"target": [2], "doc": ["the problem be not the call site", "it the definition site", "the decorator be call only once the declaration , and when this happen , the value of <tag> be <tag> , which be undefined at this point .", "i get it that you want the compiler to be more helpful in these case , and i be list case that behave similarly", "we would be open to discuss suggestion here", "again the only thing i can think of be make the value of <tag> either a getter , or a function that need to be call to get the param type", "also there have be similar design discussion here : <url>"], "issue_sim": [0.11893853545188904, 0.1572713851928711, 0.4543050229549408, 0.2677813768386841, -0.12161645293235779, 0.36968517303466797, 0.0072142742574214935], "prob": [0.0026503039989620447, 0.006107508670538664, 0.8446061611175537, 0.020966092124581337, 0.0007293897797353566, 0.791485607624054, 0.0005152353551238775]}, {"target": [0], "doc": ["there do n't seem to be an actionable suggestion here apart from whatever happen when the new decorator spec appear"], "issue_sim": [0.23028016090393066], "prob": [0.9996333122253418]}, {"target": [3], "doc": ["for the sake of my own context", "be this issue specifically root in the fact that metro be use their non standard haste module system", "or be this not entirely related", "or well yet , would this issue still occur if you be package / bundle your app use webpack to bundle which actually respect nodejs 's / or esm module resolution system ."], "issue_sim": [-0.005288789980113506, 0.3708045184612274, 0.022904742509126663, 0.6372498273849487], "prob": [0.018466508015990257, 0.602326512336731, 0.007456790190190077, 0.6986880302429199]}, {"target": [1], "doc": ["this would still be base on node 's resolution strategy , but with platform - specific extension in mind", "it do n't have any of the specific quirk of haste , since that can usually be achieve via path mapping / aliasing ."], "issue_sim": [0.2507897615432739, 0.21420219540596008], "prob": [0.05247747525572777, 0.9618909955024719]}, {"target": [0], "doc": ["please consider use a more abstract <tag> option or something rather than just the react native particular case .", "in my project i have a \" custom \" <tag> along with <tag> , <tag> and <tag> , and it be all solve gracefully in every tool around from babel to webpack only because there be a way to tweak extension"], "issue_sim": [0.440243661403656, 0.5844902992248535], "prob": [0.7791503667831421, 0.5016582608222961]}, {"target": [3], "doc": ["this feature be really want for react - native user", "ts postfix rule if", "we use almost reusable module have partial difference about web and native", "now , we must specify alias path for import file have either extension because relative path do n't support change extension   as mention in <url> .", "because of that , though bundle work in webpack configure resolve extension , vscode do n't analyze type   unless use set compileoption 's path like \" ~ / * \" :  , and even if export file in same directory in which locate the file import it , we must specify ' ~/dir1 / dir2 / dir3/", "/target ' the file point to target", "i really have trouble that configuration always more complex as it be"], "issue_sim": [0.37978097796440125, 0.07084640860557556, 0.22741541266441345, 0.44936642050743103, 0.582797646522522, 0.14018815755844116, 0.1312275528907776], "prob": [0.11116908490657806, 0.028035618364810944, 0.01018903311342001, 0.04134538024663925, 0.18573738634586334, 0.010302837938070297, 0.09973818808794022]}, {"target": [0], "doc": ["this become a much large problem when you start use typing from other project , you can standardize your use of \" string \" and \" number \" across your own code but when someone drop in a \" number \" or \" string \" into their typings file you end up write a ton of type casting for no reason ."], "issue_sim": [0.6497272253036499], "prob": [0.999992847442627]}, {"target": [6], "doc": ["they be indeed very different", "they simply can not be interchange because they do not correspond to the same javascript construct .", "take <tag> and <tag>", "the <tag> type represent the type of value produce by numeric literal and by expression which yield numeric result", "the <tag> type represent the type of value produce by invoke the <tag> function , a value , with the <tag> operator", "this create a by reference equate wrapper value around a value of type <tag>", "use <tag> as a constructor be a * * terrible * * practice but the value that this produce be indeed of a different type and typescript need to model that behavior", "all of these declaration be almost certainly wrong", "unless the value these api return at runtime be produce by call <tag> , or perhaps with some weird <tag> invocation , they be incorrect and need to be fix"], "issue_sim": [0.06654445827007294, 0.27832159399986267, 0.035664357244968414, 0.35392606258392334, 0.29301804304122925, 0.3059863746166229, 0.5460832118988037, 0.23827886581420898, 0.535817563533783], "prob": [0.0006234376924112439, 0.49179837107658386, 0.0013577892677858472, 0.02060096152126789, 0.0833117738366127, 0.01834084279835224, 0.4775574505329132, 0.0004022137145511806, 0.30499622225761414]}, {"target": [4], "doc": ["thank for the reply ,", "if that be the case , then should n't this be against the rule :", "<tag> since <tag> be not declare via <tag>", "you should n't be able to take a <tag> and set to a variable that be of type <tag>", "this would make the behavior make a bit more sense and pevent folk from accidentally use one when they mean another .", "so just to be clear current behavior allow this :", "expect behavior should call a type error on the above code , the only allowable version being :", "unless you use <tag> , in which case the current behavior be fine :", "and ditto with <tag> and <tag>"], "issue_sim": [-0.021332306787371635, 0.12542010843753815, 0.19025664031505585, 0.42447981238365173, 0.23332585394382477, 0.1574365794658661, 0.5119152069091797, 0.19872622191905975, 0.04967956990003586], "prob": [0.0018712959717959166, 0.016431758180260658, 0.0031000839080661535, 0.011991060338914394, 0.3076150715351105, 0.0003723131667356938, 0.004076803103089333, 0.0019291586941108108, 0.0003544241772033274]}, {"target": [2], "doc": ["that be an excellent point", "i be not sure why the current behavior do not produce a compile time error", "it might break a lot of build , but it probably should have be in place from the start .", "this may have be raise before"], "issue_sim": [-0.053318288177251816, 0.4607201814651489, 0.10479642450809479, 0.020604901015758514], "prob": [0.0032806547824293375, 0.00042297536856494844, 0.9303407669067383, 0.00044774264097213745]}, {"target": [0], "doc": ["string , number , and boolean should all follow the same rule ."], "issue_sim": [0.4857134521007538], "prob": [0.9999423027038574]}, {"target": [1], "doc": ["thank for take another look at this", "my main point be that the current behavior be inconsistent and that we should adjust the behavior to make it consistent .", "i do n't have a strong preference for how the consistency be attain , just a few idea", "to summarize everything above :", "the current behavior for <tag> , <tag> , and <tag> be all the same and represent in this example :", "in reality , be there a situation where someone would specifically need the argument of the example function <tag> to differentiate <tag> vs <tag>", "the idea that need to be communicate be that a number should be pass into the function", "if both \" number \" and \" number \" type can be use to identify something that behave like a number in javascript , then why be there a difference be force by the type system", "i can think of three solution to this problem to create consistent behavior :", "we assume that something that look like a duck be a duck and avoid break change", "make uppercase and lowercase type fully compatible", "you can use <tag> and <tag> interchangeably , for example", "these be treat as identical type because their structure be identical", "in my opinion , this be the good solution", "we force these primitive to work and act like other js primitive by remove the <tag> , <tag> , and <tag> type completely", "after all , there be no <tag> primitive type", "this would force the use of <tag> , <tag> , and <tag> as the only valid primitive type", "this would also make it consistent with the other js primitive type like <tag> and <tag>", "we take the idea that <tag> and <tag> be incompatible type to it be logical conclusion", "force uppercase <tag> , <tag> , and <tag> to only be declare as you would a class", "since <tag> and <tag> be n't the same , we force the two to be generate differently in a way that correspond to how the type be declare"], "issue_sim": [-0.016629084944725037, 0.24417002499103546, 0.07549022883176804, -0.0781160518527031, 0.26022055745124817, 0.29479628801345825, 0.18843530118465424, 0.6279036998748779, 0.22398823499679565, 0.15537472069263458, 0.29890239238739014, 0.22689801454544067, 0.2146850824356079, 0.04040836915373802, 0.23536595702171326, 0.1563769280910492, 0.37294724583625793, 0.4227156341075897, 0.2002500742673874, 0.3977557420730591, 0.44045335054397583], "prob": [0.002255038358271122, 0.05640292540192604, 0.020149817690253258, 7.592962356284261e-05, 0.030634460970759392, 0.000593057309743017, 5.49896176380571e-05, 0.027182241901755333, 0.0001807005173759535, 7.967647252371535e-05, 2.153954847017303e-05, 0.002787262201309204, 0.00043137589818798006, 9.521544598101173e-06, 0.03658560290932655, 4.383465693535982e-06, 0.00038149688043631613, 4.734029062092304e-05, 0.0012352364137768745, 0.0007372402469627559, 0.10679523646831512]}, {"target": [0], "doc": ["to give a more concrete example of why fix this be important : set <tag> mean that every new file you add to the <tag> location  be an opportunity to accidentally break thing .", "for example : your code might be do <tag> , successfully import from <tag>", "you later create a file call <tag> at the project root for some testing", "whoops , your exist import of <tag> be now break", "it be ideal if the only thing that can override <tag> be explicit and minimal ; use <tag> without <tag> be the way to do that"], "issue_sim": [0.20700538158416748, 0.3524132966995239, 0.204225555062294, 0.2259840965270996, 0.3882009983062744], "prob": [0.7544874548912048, 0.013126051053404808, 0.007772241719067097, 0.0015528734074905515, 0.7606363892555237]}, {"target": [8], "doc": ["there   one ambiguity that need to be clear up in order to allow drop <tag>", "consider two path entry :", "the former value be a relative path , while the latter be an unrooted path", "currently , both of these be resolve to the same location , relative to <tag>", "in the absence of a <tag> , i think it   fairly clear that the value for the <tag> mapping should be resolve relative to the tsconfig", "json location , as all other relative path in tsconfig", "it   less clear what should happen with the value for the <tag> mapping", "without an explicit base , it look like we could do a node_module search for <tag>", "this could be a useful feature , but be fairly asymmetrical from how resolution work with <tag> ."], "issue_sim": [0.07213055342435837, 0.14976570010185242, 0.29239606857299805, 0.11794576048851013, 0.3820061683654785, 0.43154793977737427, 0.2174079269170761, 0.1781000941991806, 0.2166091501712799], "prob": [0.033807072788476944, 1.0038279469881672e-05, 0.0012287606950849295, 0.007103562355041504, 0.6647363901138306, 0.00020387944823596627, 0.002554988721385598, 0.0030225198715925217, 0.6114434599876404]}, {"target": [2], "doc": ["thank for look into this", "re the <tag> example , another option be to error in such a case , so the user can fix the path", "i think it be helpful to avoid new node - specific thing in a world with multiple js runtime ."], "issue_sim": [-0.027755577117204666, 0.40924251079559326, 0.4479798674583435], "prob": [0.003842567326501012, 0.23894669115543365, 0.7839237451553345]}, {"target": [4], "doc": ["i do not think it be useful for bare - specifier in <tag> value to ever be treat as <tag>-relative", "if the user want that , they should use a relative specifier", "if they be instead pass to the resolver directly , it then raise the question of whether that resolution would include further path resolution", "path resolution be a demon - haunt world of complexity", "i would strongly err towards simplicity rather than completeness , and because i do n't have a use - case for bare - specifier here , i 'd suggest errore for now  .", "if someone want the feature , it can always be add later"], "issue_sim": [0.21217739582061768, 0.16812407970428467, 0.2229360193014145, 0.13300821185112, 0.34003186225891113, 0.09223870933055878], "prob": [0.43442144989967346, 0.00028684514109045267, 0.010001069866120815, 0.00011582869774429128, 0.4492586851119995, 0.00015094716218300164]}, {"target": [0], "doc": ["that be back when there be only a hairy map - type base definition of <tag> which we do n't particularly like , so do n't want to add ."], "issue_sim": [0.23566792905330658], "prob": [0.9999333620071411]}, {"target": [2], "doc": ["trivial for some magic for other , i would argue all build - in map and conditional type be trivial to write but that do not make they any less useful", "have a common set of type make code easy to understand across project", "<tag> be also simple to understand for new typescript devs and they do n't have to do conditional type math when look at a definition , they just care about the behavior of the type ."], "issue_sim": [0.2626454830169678, 0.28045228123664856, 0.4941875636577606], "prob": [0.7253687381744385, 0.005766387563198805, 0.6258065700531006]}, {"target": [0], "doc": ["i personally use <tag> much more often than the other  ."], "issue_sim": [0.02434307523071766], "prob": [0.9999339580535889]}, {"target": [0], "doc": ["i 've use <tag> in every single project and every single time i have to look it up , because <tag> be n't trivial to recall ; if many people use it in every project , it make sense to make it part of <tag> right ?", "that be not the same ; and it be not even close"], "issue_sim": [0.23480524122714996, 0.0729670450091362], "prob": [0.9546390175819397, 0.022933803498744965]}, {"target": [0], "doc": ["other than this be how it use to work in ts , why should these two be different ?"], "issue_sim": [0.1076694056391716], "prob": [0.9999430179595947]}, {"target": [1], "doc": ["this also have impact for certain minifier", "i think there be a strong argument to allow opt in to the classic behavior  ."], "issue_sim": [0.11582976579666138, 0.2551122009754181], "prob": [0.11940359324216843, 0.958016037940979]}, {"target": [3], "doc": ["they be different in any case", "<tag> work both in 2", "2 regardless of exist of index signature", "so add index signature affect only pass a value not use it .", "sorry , do n't get it", "what do have impact"], "issue_sim": [-0.024282293394207954, 0.0969133973121643, 0.2085299789905548, 0.3701079189777374, 0.025911962613463402, 0.07497455179691315], "prob": [0.1778215765953064, 0.08177687227725983, 0.1010393351316452, 0.6252729892730713, 0.0055491249077022076, 0.004862347152084112]}, {"target": [1], "doc": ["i be sorry , but i understand you as that you think they should be the same", "but even we forget about the fact how it be in ts 2.1 these two expression be in fact different  for any type without index signature .", "so i can ask the same question : why", "and if they be different for type w/o index - signature why should they be same for type w / index - signature"], "issue_sim": [0.05635499209165573, 0.31637758016586304, 0.00388423353433609, 0.30998727679252625], "prob": [0.24147248268127441, 0.433104932308197, 0.010030991397798061, 0.4280562102794647]}, {"target": [7], "doc": ["a type <tag> have a property <tag>", "you can access it use <tag> or as <tag> , and in both case the type of the property be <tag>", "similarly a type with an index signature , <tag> , say it can be access with any string , and the property type be always a <tag> , so it can be access as <tag> or <tag>", "a type with no explicit member declaration or index signature have no property", "in this case , both <tag> and <tag> be consider error", "you could argue that both should be the same , but that would be most property access", "the change only allow type with index signature", "i view this change as fix to an inconsistency in the system ."], "issue_sim": [0.3363969922065735, 0.44068872928619385, 0.502203643321991, 0.2758966088294983, 0.308337539434433, 0.23744776844978333, 0.43397703766822815, 0.19395890831947327], "prob": [0.015590769238770008, 0.2059626579284668, 0.8197678327560425, 0.012446236796677113, 0.008838145062327385, 0.08287793397903442, 0.0013636621879413724, 0.09905983507633209]}, {"target": [5], "doc": ["@mhegazy , @kitsonk typescript be widely use by angular <number> developer", "the only compiler that can treeshake angular <number> module be google closure  )", "it be a huge difference for google closure between { ' a ' :", "} and { a :", "} , x and x", "so provide an option to disallow dot access for type with index signature and quote access for type w / out index signature could be really beneficial , the way i see it ."], "issue_sim": [0.30987846851348877, 0.26018622517585754, 0.1320856660604477, 0.039588943123817444, 0.03229944407939911, 0.4571412205696106], "prob": [0.018084291368722916, 0.4218239486217499, 0.013628119602799416, 0.0026786685921251774, 0.009870979934930801, 0.8157972097396851]}, {"target": [4], "doc": ["to provide eclipse completion , you must implement", "where <tag> be the position of the cursor", "so eclipse work with position for completion and as you have say you can transform position to line / offset by use getlineofoffset / getlineoffset", "but i think it be very shame to transform position to line / offset although tsserver convert every time   line / offset to position <url> :", "if tsserver can accept just position , it will avoid convert position to line / offset on client eclipse side and line / offset to position on tsserver side .", "yes i be aware that it exist <number> eclipse typescript plugin  and  but even if they have do great job , i be developpe   , why", "let 's i explain the reason : at first i be the author of  which support angular 1", "x and it be base on the  which provide the capability to use  a very powerful javascript inference engine   in a java context", "it work great but now i would like to support angular2 and so support typescript", "for that i have <number> choice :", "- extend the javascript parser  with typescript language  to support typescript completion with tern", "- use typescript language service", "so i be experiment the second choice now , and the first thing i want to do be to", "- * * use tsserver instead use custom typescript server * *", "eclipse typescript do n't use tsserver and customize the type language service with their own server implementation", "imho , i prefer use tsserver", "when you will do a new release , user will just do <tag> and that be all", "- eclipse typescript implement their own texteditor", "in eclipse word , it exist jsdt which be the official javascript editor", "i would like to do the sam ethe with typescript", "- eclipse typescript seem very slow", "eclipse typescript write and read after when command must be send", "it can not support \" event \" command", "-  be not only for eclipse", "it be for java and i hope netbeans , webstorm guy will be interest to implement that and consume typescript", "hope you will understand my explanation"], "issue_sim": [0.31248733401298523, 0.2578803300857544, 0.6592247486114502, 0.5543686747550964, 0.659532904624939, 0.29882824420928955, 0.02410747855901718, 0.28173065185546875, 0.18605853617191315, 0.025512725114822388, 0.2195228487253189, 0.1035546213388443, 0.05957509204745293, 0.20078973472118378, 0.2575034499168396, 0.1895626187324524, 0.036139026284217834, 0.32320326566696167, 0.41653913259506226, 0.14967988431453705, 0.2765263319015503, 0.39849406480789185, 0.13347624242305756, 0.19848285615444183, 0.31457868218421936, -0.025468163192272186], "prob": [0.03735428676009178, 0.001575618633069098, 0.25929638743400574, 0.013466092757880688, 0.06224117800593376, 0.01553027518093586, 0.0006880350410938263, 0.0007745298207737505, 0.00028870071400888264, 0.0006007319898344576, 0.00034111368586309254, 8.031063043745235e-05, 0.005759002175182104, 9.306113497586921e-05, 0.00018090337107423693, 1.4717267731612083e-05, 0.00013409010716713965, 2.219840644102078e-05, 3.782874409807846e-05, 2.6699734007706866e-05, 1.7570288036949933e-05, 3.6975634429836646e-05, 3.1138319172896445e-05, 3.990618643001653e-05, 0.01239029597491026, 5.573075031861663e-05]}, {"target": [2], "doc": ["have the same problem than i", "sublime work with position and it need to translate to line / offset", "so if <tag> could support position , typescript sublime could use directly position and remove <tag> ."], "issue_sim": [0.02257094345986843, 0.5509734153747559, 0.426486611366272], "prob": [0.04835973307490349, 0.10851762443780899, 0.8290257453918457]}, {"target": [0], "doc": ["one important reason to use position be. that different editor , environment and language have different concept of what a line or column be .", "encoding and position be far less inconsistent , and work more reliably", "this be why the vs environment move to position , and all the modern api  be base around this", "ideally our server will consistent in be position base in the future", "from : daniel rosenwassermailto:notifications@github", "subject : re :   use position instead of line / offset from tsclient", "i be not familiar with its api but if i be not mistaken , an editor like eclipse should be equip to handle this sort of thing :", "-    <url> should get you the line of the position", "-    <url> can be subtract from the position to get the offset from the beginning of the line", "as a side note , be there any reason you be not use the eclipse-<url> plugin", "reply to this email directly or view it on <url>"], "issue_sim": [0.3300001323223114, 0.22736014425754547, 0.33598506450653076, 0.1976969987154007, -0.01634269580245018, 0.5000389218330383, 0.4847377836704254, 0.2768636643886566, 0.4268101453781128, 0.21692562103271484, 0.03880930691957474], "prob": [0.6172174215316772, 0.009509050287306309, 0.05431775376200676, 0.006071735173463821, 0.0005545751773752272, 0.0037010216619819403, 0.37714481353759766, 0.0003221050137653947, 0.0071416920982301235, 0.01580568216741085, 0.0019116484327241778]}, {"target": [0], "doc": ["you be right about roslyn / we use position - base input at the language service layer ; however ,  . i suspect that this be to accommodate vim 's api which only provide a line & column ."], "issue_sim": [0.49002766609191895], "prob": [0.9999825954437256]}, {"target": [5], "doc": ["i would like to know if tsserver could give the option to use position instead of use line / column", "i be integrate tsserver inside eclipse which use position instead of use line / column", "i can convert position to line / column for completion , etc but now i have a big problem with \" change \" command", "for the moment , i use \" reload \" command  to synchronize editor content with tsserver , but i would like to use \" change \" command  provide i just position and iit 's impossible to retrieve the end line / column", "imho , i think tsserver should provide position option :", "to avoid convert every time on tsserver side line / column - > position for client editor which already support position", "- to use \" change \" for client editor which can support th eretrieve of end line / column when editor change"], "issue_sim": [0.5294158458709717, 0.5534815192222595, 0.43134498596191406, 0.6099878549575806, 0.2860066592693329, 0.5322455167770386, 0.3729320168495178], "prob": [0.04144113510847092, 0.03459804505109787, 0.03684461489319801, 0.4675721824169159, 0.0004227885219734162, 0.005564205814152956, 0.022437315434217453]}, {"target": [0], "doc": ["i do not think we should switch to use position , as that would be a disruptive change that all editor tsserver today have not ask for .", "we should look into way where we can enable position along with line / col"], "issue_sim": [0.3078724443912506, 0.37077048420906067], "prob": [0.9758761525154114, 0.013156802393496037]}, {"target": [0], "doc": ["i think this be a duplicate of # <number> ."], "issue_sim": [0.031789179891347885], "prob": [0.9999176263809204]}, {"target": [1], "doc": ["@mattmccutchen you be right , # <number> propose a different solution for the same problem", "however i think this one could be implement much more easily as it do n't have any break change and do n't colide with something as basic as ... parenthesis ."], "issue_sim": [0.14439547061920166, 0.3226833641529083], "prob": [0.0006169289117679, 0.9982566237449646]}, {"target": [0], "doc": ["the react css style can be handle with a type annotation on the constant :"], "issue_sim": [0.4522378444671631], "prob": [0.9999110698699951]}, {"target": [2], "doc": ["@yortus that be great", "it seem the trick be the \" extend \" and one of the literal type with the notable exception you mention", "booleans , tuples , number , and string all work when give the specific type use <tag> which make the <tag> function a short option when you do n't want to re - type the literal .   so other than symbol , it be possible today to achieve the desire behavior .... just not ideal .", "imo it would be great if something as simple as this would prevent widening in all case :"], "issue_sim": [0.08044984191656113, 0.3228066861629486, 0.5845856666564941, 0.2248564064502716], "prob": [0.002523567993193865, 0.09094993025064468, 0.8760769963264465, 0.002003245521336794]}, {"target": [0], "doc": ["this would be very helpful in modern nodejs project try to use esm module .", "this will be more and more recurring upon tc39 module proposal be finalize"], "issue_sim": [0.5281175374984741, 0.2218778431415558], "prob": [0.7236034274101257, 0.032790407538414]}, {"target": [2], "doc": ["in the meantime , you could use  with the <tag> option to enforce extension", "it would be nice if typescript could enforce this though", "typescript should be able to detect simple runtime error like not include a file extension in an import ."], "issue_sim": [0.288727730512619, 0.5585036277770996, 0.6001549959182739], "prob": [0.10677070170640945, 0.01658341847360134, 0.574694037437439]}, {"target": [14], "doc": ["i think this be become increasingly important", "there have be  in the last few month", "for example , i be use the  package", "the late version have drop commonjs support entirely", "after update , i immediately run into the fact that you ca n't import es modules from commonjs", "i flip my <tag> over to <tag> , think that would solve it", "how naive i be", "my project build fine , only to fall over immediately when launch in node", "my esm import path absolutely _ must _ have <tag> extension to work", "after read through the notorious # <number> , i have the same thought as @trusktr", "i 'll tolerate spend a few hour to rewrite all my import path with a <tag> extension", "but it be absolutely * * critical * * for i that the compiler reject invalid import , and that tsserver / intellisense suggest the correct one", "yes , you can set a config flag in vscode , and add an eslint rule", "but not everyone use vscode , and some people will manage to avoid run eslint", "and that mean that a catastrophic runtime exception will probably sneak into a production deployment at some point .", "add this flag or a new <tag> option would fix it", "then there will be a simple and clear solution for the ten of thousand of developer who inevitably try to update a package in the next few month and smack head - first into this same problem"], "issue_sim": [0.01753535307943821, 0.002740645781159401, 0.018162842839956284, 0.0891616940498352, 0.3050214648246765, 0.04776846244931221, 0.049710437655448914, 0.20535476505756378, 0.41138145327568054, -0.07534623146057129, 0.40942755341529846, 0.30458372831344604, 0.45214444398880005, 0.09930001199245453, 0.2227700650691986, 0.22985461354255676, 0.0520763024687767], "prob": [0.012427431531250477, 0.004450380336493254, 0.00613782973960042, 0.0005573510425165296, 0.0016284859739243984, 0.004205097910016775, 0.0006392534705810249, 0.0003403262817300856, 0.0004132789035793394, 0.0026806634850800037, 0.0011867565335705876, 0.01270561758428812, 0.0030439537949860096, 0.00019174972840119153, 0.12482074648141861, 4.022470238851383e-05, 0.18553534150123596]}, {"target": [0], "doc": ["it doesn make sense to say ake i write file extensions?outside the broad context of a module resolution strategy where file extension be require , and <tag> be the first of those strategy that wel support ."], "issue_sim": [0.3352169394493103], "prob": [0.9999622106552124]}, {"target": [1], "doc": ["it enforce file extension", "ts will never rewrite an import declaration module specifier under any mode , and in node esm implementation , file extension be require , therefore we must make you write they ."], "issue_sim": [0.22071680426597595, 0.5401319265365601], "prob": [0.0013403979828581214, 0.9922785758972168]}, {"target": [0], "doc": ["sound like this will work in browser and support <tag> map too - i be really look forward to it ."], "issue_sim": [0.18698003888130188], "prob": [0.9999502897262573]}, {"target": [1], "doc": ["i do n't want * any * new syntax for skip type parameter", "you should simply be able to not supply anything for unnecessary type parameter and have it work ."], "issue_sim": [0.465728759765625, 0.3969975709915161], "prob": [0.15584157407283783, 0.8168560266494751]}, {"target": [0], "doc": ["if i be not wrong you want name type argument and partial inference . # <number> , # <number> and # <number> all revolve around the same request , syntax aside ."], "issue_sim": [0.47022441029548645], "prob": [0.9999357461929321]}, {"target": [2], "doc": ["they be all slightly different proposal", "# <number> want a syntax for mark type parameter as \" to be infer \" , # <number> want to enforce a distinction between normal type parameter and those with default , and only infer the latter", "this issue be about simply make exist syntax have different semantic .", "i do n't want any new keyword or syntax  , i just want the syntactically valid <tag> to also be semantically valid , and not produce the \" expect <number> type argument , get <number> \" error", "what exactly the semantic change should be i 've try to outline above with a mapping to typescript code that be valid today", "if it help you track thing , i be fine with you fold this issue into either one , i just want to clarify what i be propose be distinct from those proposal"], "issue_sim": [0.10000339150428772, 0.5611737966537476, 0.4253102242946625, 0.5996233224868774, 0.41988900303840637, 0.20290419459342957], "prob": [0.0003998622705694288, 0.1885019689798355, 0.47001707553863525, 0.07590040564537048, 0.005491833668202162, 0.07514474540948868]}, {"target": [3], "doc": ["@ryancavanaugh not follow you", "you be already able to call <tag> today , nothing prohibit that", "i be also not propose that that behavior of that should change in any way that i can think of", "the semantic of the change i be propose be identical to add a <tag> to each generic function , and replace all explicit application of type argument with application of a dummy value <tag> .", "could you make a full snippet i can stick in playground"], "issue_sim": [0.023741550743579865, 0.18919819593429565, 0.2304094135761261, 0.5617456436157227, 0.049150124192237854], "prob": [0.014220328070223331, 0.14007516205310822, 0.12373306602239609, 0.5942065119743347, 0.0027396983932703733]}, {"target": [1], "doc": ["look at it again , i really do n't see a difference between this and # <number> that do n't imply a massive breaking change", "<tag> can be write cromulently either in the presence of a true inference source  , or as a curried function , or with # <number> .", "i do n't see any other path forward on this"], "issue_sim": [0.24053740501403809, 0.34209010004997253, -0.0014426615089178085], "prob": [0.4501824378967285, 0.861266553401947, 0.0005057410453446209]}, {"target": [0], "doc": ["it be a small difference , but <tag> would be much nice than <tag> .", "i see the consistency with <tag> , too"], "issue_sim": [0.0926331877708435, 0.04939350113272667], "prob": [0.9301676154136658, 0.003185780020430684]}, {"target": [0], "doc": ["as a workaround , you can use identity function to coerce string and number literal to literal type :"], "issue_sim": [0.5343176126480103], "prob": [0.9997937083244324]}, {"target": [2], "doc": ["it be more one use case : <url>", "it do n't work with jsdoc type without <tag>", "i use json schema in most of my backend and i have to create jsdoc type for payload manually every time ."], "issue_sim": [0.08697456866502762, 0.34237006306648254, 0.3438006639480591], "prob": [0.003323961980640888, 0.012838286347687244, 0.9157510995864868]}, {"target": [8], "doc": ["i like the idea of allow reference to be force ' local ' , but for a different use - case : when i have a test-something", "ts , that file be intend to be run with mocha", "however , if i currently put a <tag> in it , the <tag> and <tag> become available in the whole program , which be not what i want", "however , i would prefer to not have to write these <tag> line anymore", "although they be acceptable for the mocha - case  , it seem redundant to manually specify where the", "ts file be to be find , when i already do an <tag> and can have the compiler search for the typing", "also , have a <tag> line in the", "ts file of a library make it no long suitable to use as an ' isomorphic typing '", "it be indeed a solution for solve the ' accidental global ' , but i think # <number>  solve it more elegantly by basically automatically decide to apply your ' localize ' set when import .", "and we still need a solution for the ' intentional global '"], "issue_sim": [0.41431236267089844, 0.3278001546859741, 0.21545466780662537, 0.07978028804063797, 0.24721992015838623, 0.41299164295196533, 0.00546606257557869, 0.29606181383132935, 0.37297624349594116, 0.10214439034461975], "prob": [0.28551843762397766, 0.0020199057180434465, 0.20560646057128906, 0.002351843984797597, 0.06224929541349411, 0.029341664165258408, 0.0010094885947182775, 0.02199103869497776, 0.32334211468696594, 0.00427292101085186]}, {"target": [3], "doc": ["@poelstra thank for your comment", "let i address each one", "that depend entirely on how the definition file be write , i suppose", "if it only define <tag> and <tag> as part of <tag> then that would n't be an issue .", "this be a fundamental issue with how most definition be write today", "sure , that be just for example purpose here", "i would expect ideally that typescript would use some magic lookup logic like in your proposal if there be an <tag> , unless you really do want to reference a file", "that be not true", "the definition file itself can do anything it want", "it be only definition that it _ reference _ that be restrict", "this also relate back to # <number> , which be that ideally we should n't be write isomorphic definition file this way anyways", "instead we should be split they into multiple file so that program author can choose how they plan on use it", "what if the definition file that be be import use the legacy mode use <tag> to another definition file that declare a global", "now that global have leak", "this proposal guarantee no leak down the entire dependency chain", "btw , this be n't just a hypothetical", "yet again , see # <number> : smile :", "this already solve intentional global", "definition file that you reference from your program still have the full power that they have today to create global", "it be only _ dependency _ of those definition file  that would not have the power to create global , which be a good thing", "if your program need access to a global that be create by a dependency in js - land , then simply include the definition file for that dependency as well and the global will be make available", "- promiselib // in js - land , this create a global , but in ts - land it would not", "- promiselib // if you want access to the global in ts - land , simply reference it yourself"], "issue_sim": [-0.03645741567015648, 0.03685041889548302, 0.3712286949157715, 0.3242444396018982, 0.265433669090271, 0.06733173877000809, 0.4953150749206543, -0.031401701271533966, 0.38998347520828247, 0.2684401571750641, 0.49895280599594116, 0.21768932044506073, 0.6120411157608032, 0.0723225399851799, 0.17750662565231323, 0.0408499538898468, -0.04259254038333893, 0.1287994384765625, 0.3820158839225769, 0.4625471234321594, 0.5719342231750488, 0.24484892189502716, 0.2753765881061554], "prob": [0.005812006536871195, 0.009154853411018848, 0.004897245671600103, 0.11939166486263275, 0.023441525176167488, 0.0010118597419932485, 0.06925288587808609, 0.00035532034235075116, 0.00023698956647422165, 0.0002368230780120939, 0.008148604072630405, 0.0041260672733187675, 0.022620148956775665, 0.00011499971151351929, 0.00029575038934126496, 0.00021201110212132335, 0.00043113535502925515, 0.0001395475264871493, 0.003841306082904339, 0.004546859301626682, 0.05317693576216698, 0.011432559229433537, 0.007277082186192274]}, {"target": [0], "doc": ["no , <tag> and <tag> be ' real ' global . you do n't explicitly <tag> or something , they simply be magically available  .", "i do n't like this kind of automagic , but that be what we have today", "but today , when i add that reference line to make they available for _ one _ file in the project , they automatically become available for _ all _ file in the project", "your opt - in localization would help with that", "hmm , but if a typing make a ' real ' global available  , and i then include it with <tag> , the global basically get ' degrade ' into a local thing in the typing , but it be still a ' real ' global in the js", "so it will explode at runtime when you use it as a ' global '", "that be a lot of work for the type author , be n't it", "then all of these will recursively have the same trick apply", "and yes , i run into the issue you mention in # <number>", "it regularly happen that i forget to <tag> , compiler do n't complain , runtime explode :-/", "they will still create the global at runtime", "the fact that you be hide the typing for it do n't mean it be n't there", "so it will still conflict at runtime", "suppose there be two  package : <tag> and <tag> that both make a global <tag> available , and both mylib1 and mylib2 try to use ' their ' <tag> :", "in your proposal , <tag> would ' locally ' include <tag> , so compiler wo n't complain", "same with <tag> , no complaint from compiler", "however , at runtime , this still explode , because the real <tag>  can only be either <tag> or <tag> 's <tag>", "by allow the ' real global ' escape , the compiler can know that the presence of <tag> from <tag> be conflict with that of <tag>", "note : both our proposal suffer from this problem , which i believe can only be ' solve '  when we additionally implement this explicit global escape"], "issue_sim": [0.14847025275230408, 0.05333808436989784, 0.35894548892974854, 0.17953401803970337, 0.344713032245636, 0.2079540193080902, 0.005540132522583008, 0.0064094774425029755, 0.06385906040668488, 0.19022847712039948, 0.1547614336013794, 0.10227298736572266, 0.1529707908630371, 0.2600049376487732, 0.29626473784446716, 0.18997329473495483, 0.13990242779254913, 0.3771228492259979, 0.3241840600967407], "prob": [0.08862544596195221, 0.0006257635541260242, 0.053521838039159775, 0.010052082128822803, 0.019423160701990128, 0.0003892410022672266, 0.00010043416841654107, 0.0007893528672866523, 1.4413213648367673e-05, 0.011847433634102345, 1.476827856095042e-05, 0.00047910705325193703, 2.5853278202703223e-06, 0.17559880018234253, 0.0013510340359061956, 5.785558096249588e-05, 0.012994918040931225, 0.01849505864083767, 0.011132892221212387]}, {"target": [8], "doc": ["ah , i see what you be say", "but since it be not available in ts - land as a global , you would n't be reference it as a global", "it be , but", "this be an area that i be passionate about since i help maintain the definition for react", "i really want ts to improve in this area", "i be n't clear on this point", "if that be the case then it be actually a whole lot like this proposal", "again , i think the right approach here be for ts to not complain", "it be not a guarantee that the global will conflict  and it just seem like it would be really hard to somehow tell ts to not spew a bunch of error in this situation even though you know the runtime wo n't conflict ."], "issue_sim": [0.04608860984444618, 0.23189085721969604, 0.06387794762849808, 0.20118576288223267, -0.02830716222524643, 0.031560249626636505, 0.16261282563209534, 0.03470705449581146, 0.1907423734664917], "prob": [0.0002745224046520889, 0.21008974313735962, 0.0012363060377538204, 0.0048525528982281685, 0.0004646854940801859, 1.502752820670139e-05, 0.00011516675294842571, 0.0002516258100513369, 0.913262665271759]}, {"target": [0], "doc": ["that be exactly what i be say , and implement in ts - land by \" hide \" all of the global except for the one you actually directly pull into your program ."], "issue_sim": [0.2895212173461914], "prob": [0.9999655485153198]}, {"target": [0], "doc": ["i guess that it reflect syntax for define object literal .", "also string\\numeric literal as name in property be allow in typescript long before es6 support be add"], "issue_sim": [0.42502525448799133, 0.4680159091949463], "prob": [0.9616904854774475, 0.045255329459905624]}, {"target": [1], "doc": ["weird - vscode 's syntax highlighter do n't even think it be valid :", "like , i feel like the square bracket  should certainly be correct syntax in ts , even if the old interface syntax be still valid - just because it work for symbol , so it feel like it aught to work for other primitive ."], "issue_sim": [0.3358718156814575, 0.6046947240829468], "prob": [0.03698877617716789, 0.9486855864524841]}, {"target": [1], "doc": ["both of those form be valid in class", "would be reasonable to support both in interface for consistency sake ."], "issue_sim": [0.10070466995239258, 0.3684290647506714], "prob": [0.027621978893876076, 0.9116089940071106]}, {"target": [0], "doc": ["i suggest this at first , but then i realize the behavior be pretty good if we just make sure the _ first _ tab stop be in the method body .", "then a user can tab into the parameter if need , or can hit the escape key to remove those tab stop", "there   an item open in # <number> to make the method body both the first _ and _ the last tab stop as an additional improvement", "i agree i do n't often want to edit the parameter name / type , but as long as they do n't stop i from get to the method body , they do n't bother i", "from our conversation in the editor sync , i think @danielrosenwasser like have the tab stop , so this seem like a good compromise to i"], "issue_sim": [0.5423380136489868, 0.44021791219711304, 0.5014089345932007, 0.3241669535636902, 0.31238096952438354], "prob": [0.4424190819263458, 0.04523458704352379, 0.06507711112499237, 0.5067901611328125, 0.02093641832470894]}, {"target": [1], "doc": ["yes i remember we discuss this", "after try it myself though , i really do n't like how all the tab stop get highlight along with the code i type in the method body :", "i end up press <tag> right away to cancel out of the snippet right away"], "issue_sim": [-0.002149653621017933, 0.5711275935173035, 0.24811770021915436], "prob": [0.027351832017302513, 0.8156187534332275, 0.0526852160692215]}, {"target": [0], "doc": ["the highlight be pretty much my only concern with place the tab stop"], "issue_sim": [0.3832588493824005], "prob": [0.9995120763778687]}, {"target": [1], "doc": ["same , but i find i get easily distract by completion pop up when i be try to think , so i already have a habit of press <tag> quite a lot to get rid of visual noise , so this one do n't bother i", "i really do n't have a strong opinion here , but i think the most valuable place to have placeholder be on the <tag> type annotation on an overload implementation signature , because a user be pretty likely to want to change that .", "on the other hand , the fact that we produce <tag> there be already something we 'd like to improve in the future", "@danielrosenwasser 's big concern with decision around the placeholder be not disrupt user ' muscle memory for get to where they be try to end up , but i tend to think that concern be mitigate by the fact that we be land the cursor in the method body right away now", "but this be perhaps something we do n't want to flip flop on and confuse user , so it would be nice if we can reach a consensus we feel good about before 4"], "issue_sim": [0.2845308184623718, 0.4105352759361267, 0.07709850370883942, 0.43787088990211487, 0.15019814670085907], "prob": [0.3714805841445923, 0.2843357026576996, 0.06978607177734375, 0.0023288705851882696, 0.29935285449028015]}, {"target": [2], "doc": ["my primary concern be  real - world usefulness and  consistency", "for i , @mjbvz 's actual user experience trump most other consideration", "i be fine with never have tab - stop ; i 'd be reluctant to have tab - stop conditionally unless it be _ really _ clear when you should expect they ."], "issue_sim": [0.00966600514948368, 0.006373686715960503, 0.36669808626174927], "prob": [0.1183462142944336, 0.015449604950845242, 0.8181808590888977]}, {"target": [2], "doc": ["@jacksonkearl @jrieken on the vs code side , do you currently have any plan for how to make a readonly view of the workspace content available to other extension", "initialize ts with a single blob seem like it would be the easy approach for we .", "if the majority of workspace only have a few mb or so of code , for the first iteration we could even skip use a <tag> too and instead send typescript a simple json tree structure that contain all the file and their content"], "issue_sim": [0.5611591339111328, 0.31488698720932007, 0.6079485416412354], "prob": [0.002521554008126259, 0.8084583878517151, 0.630753755569458]}, {"target": [1], "doc": ["/cc @joyceerhl who be own the remote hub file system implementation", "for anycode this be currently opaque and it simply consume thing via <tag> .", "that make it very nice and simple for i but i actually never really know when i be benefit from blob - cache or cause individual fetch - request", "for the <tag> approach there be safari which do n't support it", "a long , long time back we use index - db to share datum between various worker since all can access datum without postmessage - call", "tho , there be still some deserialization happen"], "issue_sim": [0.23065179586410522, 0.14764079451560974, 0.1423402726650238, 0.07432273030281067, 0.3731839954853058, 0.1286933869123459], "prob": [1.5923751561786048e-05, 0.869546115398407, 0.22587257623672485, 4.9459715228294954e-05, 0.0026966999284923077, 6.142709025880322e-05]}, {"target": [1], "doc": ["from talk with @eamodio my understanding be that the tar approach we have be essentially a workaround for the limitation of the github text search api and should go away when the github search api improve", "it be not clear when the search api will be improve , but i slightly worry about whether we should really be expose that and have typescript depend on that implementation ."], "issue_sim": [0.2890530824661255, 0.37856435775756836], "prob": [0.08322016894817352, 0.8780924081802368]}, {"target": [1], "doc": ["@joyceerhl i agree we should consider if expose the whole content of the workspace to extension make sense", "with  also need this datum though , i think it would be nice to see if we can come up with a generic solution instead of have each extension / language re - implement this functionality", "i 'll keep talk with the ts team about our requirement for this", "for experimentation purpose , it sound like i may be able to hack something together use the remote hub file system provider today though", "@jacksonkearl and @jrieken   good suggestion to look into <tag>", "@joyceerhl/ @jacksonkearl   out of curiosity , be the tar store as a big binary blob in indexeddb , or do remote hub generate a more useful datum structure to work with it"], "issue_sim": [0.38484323024749756, 0.4464651942253113, 0.20057275891304016, 0.26517775654792786, 0.12056365609169006, 0.36517149209976196], "prob": [0.024161571636795998, 0.6438452005386353, 0.013207505457103252, 0.34780487418174744, 0.0001641763956286013, 0.0165118221193552]}, {"target": [0], "doc": ["the tar be originally just to deal with the lack github search apis , but they also become useful to avoid thrash the github api  when an extension use the <tag> apis  .", "imo , it would be great to leverage for this scenario as well -- though i be not sure if a tar be the \" right \" way to go or not", "as i be not sure if azure repos or other virtual fs ' could support it"], "issue_sim": [0.2593335509300232, 0.13937833905220032, 0.22001706063747406], "prob": [0.7206310033798218, 0.3099801242351532, 0.061484239995479584]}, {"target": [0], "doc": ["when i talk this over this @jrieken from the vs code team , it sound like we will need a specialized typescript server api to implement this correctly and efficiently . determine outgoing call in particular be very difficult use current tsserver apis .", "can we please revisit this for 3"], "issue_sim": [-0.006297748535871506, 0.04482138529419899], "prob": [0.9634457230567932, 0.051394764333963394]}, {"target": [1], "doc": ["a few thing that i know of :", "determine outgoing call of a function be difficult", "- use reference , we ca n't distinguish function call from other reference to that function"], "issue_sim": [0.1277921348810196, 0.032783590257167816, 0.04260926693677902], "prob": [0.0738547071814537, 0.1576225459575653, 0.9631068706512451]}, {"target": [0], "doc": ["i suppose that it would be hard to understand every call - like behavior ( tagged template , decorator , function call , new invocation , etc ."], "issue_sim": [0.010026045143604279], "prob": [0.9999885559082031]}, {"target": [1], "doc": ["@mjbvz , @jrieken : i 've be work on the tsserver api for call hierarchy , and here be what i 've come up with :", "rather than round - trip a <tag> as would be do in the vs code api , vs code would send tsserver the file and location of the declaration relate to the <tag> . we can then use that to determine the declaration from which to find incoming and outgoing call .", "i 've build a prototype of both the vs code support for the tsserver api , as well as the tsserver implementation itself , though i do have a few additional question :", "how should a <tag> be represent as a <tag>", "in ts / js , its frequently the case that the caller of a function be the source file itself :", "i be include source file in the prototype i have build , however i be not certain of the good way to represent the \" name \" of the call hierarchy item :", "the comment for the <tag> property of a <tag> indicate it should be use for something like a signature", "give that this be merely a <tag> , what be the intend format", "since ts / js function / method differ only in signature and not in implementation , do provide the signature even make sense here", "this have be bring up in <url> , but i 'll mention it here as well", "ts / js have several different call convention we should be aware of :", "* <tag>  <tag> newexpression <tag> )", "should we support call hierarchy on method signature in interface", "they obviously would n't have outgoing call , but they could have incoming call", "the vs version of call hierarchy do seem to support this :"], "issue_sim": [0.028152309358119965, 0.007167212665081024, -0.026247885078191757, -0.14715972542762756, -0.07204411923885345, -0.02295532450079918, -0.0664033591747284, -0.020481616258621216, -0.014496136456727982, 0.1289336383342743, 0.06091419979929924, -0.04490957036614418, -0.12478725612163544, 0.052024975419044495, 0.032272860407829285], "prob": [0.06891031563282013, 0.49276819825172424, 0.12739306688308716, 0.0037550588604062796, 0.15135769546031952, 0.1242813691496849, 0.0034758681431412697, 0.000454415479907766, 0.005936962552368641, 0.005537000950425863, 0.004191959742456675, 0.00031871689134277403, 0.004682325758039951, 0.022096944972872734, 0.003954465035349131]}, {"target": [1], "doc": ["we actually do the same - internally each item be associate with an id and only that go over the wire", "for the api we want to be more expressive and give implementor a chance to store datum subsequent request in an item .", "that be a good question", "i think the base - filename , e", "g <tag> and <tag> would be a good start", "maybe put the rest of the path as detail", "not sure tbh - the detail field be a bit of a free form field for extension to add \" something \" useful", "we have the same for outline and there ts be n't use it , some extension be", "generally , it will be render as be , no md format or so", ": +1 : i think that be useful in order to see how an interface be be use", "for call each item could just be a call but when start / prepare it be a little more trick", "we might need to evolve our api so that prepare can return n item"], "issue_sim": [0.09862195700407028, -0.09029848873615265, 0.10830646008253098, 0.12306363880634308, 0.025029174983501434, 0.1433180272579193, -0.056608784943819046, 0.12766432762145996, -0.009567290544509888, -0.013386406004428864, -0.011246586218476295, -0.0942830741405487], "prob": [0.03292993828654289, 0.722222626209259, 0.00011260416067671031, 0.003140769898891449, 0.004353896714746952, 0.002910303883254528, 0.050335414707660675, 0.004318499006330967, 0.009699949994683266, 0.009145751595497131, 0.03206207975745201, 0.0014198118587955832]}, {"target": [1], "doc": ["i think it be easy to read if you inline and shrink the type :", "the problem be that , even with control flow analysis , the compiler still do n't do much \" type math \" .", "all control flow will do be narrow -- that is , throw out member of a union", "what need to happen here be for the compiler to reach inside the intersection , throw out the nested union member , then create a new intersection type", "i will go see if there be other issue relate to this", "i think it come up every couple of week"], "issue_sim": [0.22800719738006592, 0.24278119206428528, 0.173536017537117, 0.33753353357315063, 0.021531779319047928, -0.10438060760498047], "prob": [0.025399908423423767, 0.5231725573539734, 0.033066604286432266, 0.38698065280914307, 0.0033581340685486794, 0.004824681207537651]}, {"target": [0], "doc": ["the intersection type do n't really have anything to do with the behavior here .", "we currently report an error because <tag> be not present in _ all _ constituent of the union type", "this be the reason for the error in the original example", "we might consider an alternate behavior in <tag> mode", "we could say that the set of property be _ every _ property in every constituent , with type of similarly name property unione together and with <tag> add to their type unless the property be present in _ all _ constituent", "this would make the original example work", "so , for purpose of property access , the type", "and it would require type guard to access the value in <tag> and <tag>"], "issue_sim": [0.2506667673587799, 0.25324487686157227, 0.15305067598819733, 0.1992289274930954, 0.23054629564285278, 0.0685989111661911, 0.10982402414083481, 0.17615383863449097], "prob": [0.05497914180159569, 0.1001102551817894, 0.02075532265007496, 0.01616998203098774, 0.7127587199211121, 0.004557290114462376, 0.0058928378857672215, 0.026545194908976555]}, {"target": [0], "doc": ["that kind of type guard be very error - prone since it depend on the other type in the union not have a property with the same name as an implementation detail :", "allow this would mean you could no long add or rename an object 's internal property without worry about whether it might conflict with a union somewhere"], "issue_sim": [0.4151889979839325, 0.39011892676353455], "prob": [0.8654906749725342, 0.16590020060539246]}, {"target": [6], "doc": ["i know , but the comment still stand - typescript would error on <tag>", "edit : i see your concern", "i just try out some test", "edit <number> : i know it be probably a bit of work , but maybe it could work with exist flow control then", "<tag> and warn on other usage of it like <tag>", "edit <number> : give all this , i be not sure it be relevant now", "i do n't think there be anything stop it from happen today . if you want to use one side of the union today , you 'd need to rely on type coercion which remove type safety already .", "how be you use type like the one you mention above in today 's code"], "issue_sim": [0.46396297216415405, 0.027200084179639816, 0.03980901837348938, 0.2335650771856308, 0.29700177907943726, 0.103550024330616, 0.2777481973171234, 0.26707789301872253], "prob": [0.009248725138604641, 0.0016537810442969203, 0.004921258892863989, 0.0861029103398323, 0.00483930017799139, 0.001828900189138949, 0.9818096160888672, 0.0038479482755064964]}, {"target": [2], "doc": ["i believe this be classify as unsound unless there be be a recent change to type checking for the <tag> property", "i understand there 'd be no other way to represent this safely today , unless we get <tag> type", "the only other thing i can think of be have property that be n't know be an <tag> type so <tag> could work with flow control but <tag> would fail with <tag> type ."], "issue_sim": [0.37710660696029663, 0.1564519703388214, 0.4716465175151825], "prob": [0.38325223326683044, 0.07545773684978485, 0.6243645548820496]}, {"target": [1], "doc": ["this be allow today with the  clear <tag>", "we 've discuss it a bunch and still do n't want to allow truthy check on possibly - unpresent property from union ."], "issue_sim": [0.16966375708580017, 0.30762356519699097], "prob": [0.020222796127200127, 0.9443893432617188]}, {"target": [1], "doc": ["discuss this in the room , there be some interesting implication and point of disagreement", "i personally often rename an import identifier and expect it to cascade to the module where i export  , so i be happy with the current behavior .", "but some folk be in agreement with you that this be a local identifier and should be aliase by a rename , and you should have to rename at the definition to cascade throughout the project", "perhaps we need two operation here", "there be some other interesting related point to this", "for example , rename that impact a", "again , i often hand - author one to describe type i want to use throughout a project , so i expect my rename at a use point to rename in the", "however , as you point out , a", "ts file may be generate , and thus do a rename in it simply get overwritten when it be next generate", "there be no way to tell currently if a", "ts be generate or hand - write", "you could make a similar argument for other scenario too - e", "if a class implement an interface and you rename an implement member , then do you intend to rename the member on the interface", "or just rename the method on the class", "again , seem like there be really two operation here  , and have both may be more obvious / intuitive than require folk go to the declaration point and rename if the intent be for a _ global _ rename", "add ' in discussion ' until we arrive at a conclusion"], "issue_sim": [0.048020265996456146, 0.6841304302215576, 0.5505603551864624, 0.05478199943900108, 0.0036372970789670944, 0.2935526371002197, 0.4730380177497864, -0.04136473685503006, 0.4554327130317688, 0.10224489867687225, 0.027520261704921722, 0.06673330068588257, 0.4454234838485718, 0.3121984601020813, 0.4415661692619324, 0.003625389188528061], "prob": [0.0041746217757463455, 0.2205270379781723, 0.6879784464836121, 0.0005859697121195495, 4.675338277593255e-05, 0.0005316213937476277, 0.14209644496440887, 6.931908865226433e-05, 0.008796208538115025, 2.401151868980378e-05, 0.00035349579411558807, 0.00013919646153226495, 0.0033386966679245234, 1.2141895240347367e-05, 0.35721781849861145, 0.00024802659754641354]}, {"target": [2], "doc": ["@billti   the problem that the global renaming prevent to find reference locally to import part", "because renaming rely on \" find all reference \" behaviour", "the question be it useful in a current module to click on import part to find all reference and obtain the reference for the import type in the whole project instead of only in the current module .", "to find local reference be very frequently use operation , but i can not do it with current behavior and i be stick with the \" find and replace \" dialog to look for the text", "and implement my suggestion the bug # <number>"], "issue_sim": [0.5531449317932129, 0.34239843487739563, 0.5223609805107117, 0.3554948568344116, 0.06918330490589142], "prob": [0.004583979025483131, 0.016757680103182793, 0.600182831287384, 0.48355308175086975, 0.0021478680428117514]}, {"target": [1], "doc": ["i would say most of the time module import should be not be rename", "this make it easy to follow the logic , specially with reexport  .", "in that spirit , a rename should be a global operation rather than a local one", "the api have an entry point for local reference , which be occurrence , it be visible in ide today in the form of highlight the text", "i would expect your request for a new gesture to make a local rename , be expose in the ide", "support this new api on the ts side should be trivial", "i just do not think that we should change the behavior for all user of the exist rename api"], "issue_sim": [0.6129880547523499, -0.06139866262674332, 0.335231214761734, 0.3091878592967987, 0.4603523313999176, 0.23804296553134918, 0.37520772218704224], "prob": [0.006424150429666042, 0.9619311094284058, 0.0054053617641329765, 0.029867684468626976, 0.00833125039935112, 0.00011204839393030852, 0.004272913094609976]}, {"target": [0], "doc": ["my most problem that i can not do local \" find all reference \" .", "it produce a bunch of reference in the whole project", "i suggest it to fix this issue", "i think all of the user would be greatful if you implement this", "because it be correct behaviour and very much expect"], "issue_sim": [0.1060212254524231, 0.13316959142684937, 0.12680982053279877, 0.012824175879359245, 0.10841630399227142], "prob": [0.23676562309265137, 0.012563809752464294, 0.00037410695222206414, 0.008286622352898121, 0.7648187279701233]}, {"target": [1], "doc": ["this match the intend design", "this type have the scope of a class / interface , and be not instantiate on every call . this have be discuss before in <url> ."], "issue_sim": [0.11330460011959076, 0.4233536124229431], "prob": [0.004270697943866253, 0.9590860605239868]}, {"target": [10], "doc": ["thank you very much for the link", "i miss that in my search to see if it have be discuss before", "please forgive my lack of expertise , but i be struggle to understand the explanation give on that link issue", "if you  have time , could you please :", "- explain what be mean by \" the type that be instantiate by the reference \"", "- give an example show why this be require \" to support property declaration use type this \"", "i should also point out that  the semantic i desire be possible use non - member function", "in the below code snippet , the variable have the type i expect :", "<tag> <tag> v2 <tag> a & b <tag> <tag>", "<tag> <tag> d <tag> extendable & b & c <tag> <tag>", "however , \" this typing \" appear to be largely motivate by \" fluent api \" and the above code remove this syntactic nicety .", "particularly the second example get ugly quite fast without method chain", "do i understand correctly that \" function declaration this type support \" would allow i to get the fluent api syntax with the semantic i desire", "this be a not - yet - implement feature , right"], "issue_sim": [-0.032739121466875076, 0.05317440629005432, 0.01732884719967842, -0.08326372504234314, 0.2764679193496704, 0.3904373049736023, 0.3230603337287903, 0.4748607873916626, 0.34899020195007324, 0.32190564274787903, 0.39881807565689087, 0.045899897813797, 0.49306824803352356, 0.21484960615634918], "prob": [0.03241702541708946, 0.2782476842403412, 0.23582373559474945, 0.002929446753114462, 0.012214147485792637, 0.011861573904752731, 0.0661669671535492, 0.0032115948852151632, 0.0015323752304539084, 0.0014543788274750113, 0.07161761820316315, 0.0009586777887307107, 0.08092434704303741, 0.006308118347078562]}, {"target": [6], "doc": ["i be work on this - type for function right now , but it be not do", "the proposal at # <number> link to the branch where i be work on it", "to explain why <tag> need this feature , let 's annotate the invisible <tag> type parameter on <tag>", "notice that <tag> have two parameter <tag> and <tag> , whereas <tag> only have one , <tag>", "<tag> be suppose to be equivalent to <tag> to allow you to chain call", "unfortunately , it be not -- it be bind on <tag> instead of the method <tag>", "so when you use it , the return value of the first call do n't get to infer the <tag> type for the second call .", "here , i 'll annotate the type parameter of the usage explicitly :", "notice that call <tag> do n't give we <tag> because it be the original <tag> method", "it be the same method as before", "this - type for function  should solve this by let you specify <tag> per function - call", "notice that the declaration look even close to the non - chain declaration :", "this type bind the type of the _ call object _ of <tag> to <tag> , and be infer fresh for each call to <tag>", "this contrast with the original chain version that bind <tag> to the type of <tag> and keep it there"], "issue_sim": [0.42520254850387573, 0.15494129061698914, 0.44059011340141296, 0.4108189642429352, 0.36616963148117065, 0.29418423771858215, 0.33393263816833496, 0.4246326684951782, 0.2647038698196411, 0.05026289075613022, 0.4568215608596802, 0.18230178952217102, 0.4743759036064148, 0.2500801086425781], "prob": [0.0006654411554336548, 0.0038050375878810883, 0.01355323102325201, 0.005832384340465069, 0.0009196994360536337, 0.0008972323848865926, 0.03175313025712967, 0.00014106155140325427, 0.0022720666602253914, 3.770925832213834e-05, 0.0011902576079592109, 7.858905883040279e-05, 0.07900416851043701, 0.0022713637445122004]}, {"target": [0], "doc": ["i call this a workaround because your original solution return <tag> do n't work & mdash ; ideally the language would never surprise you and you could just write the program you want to write in the first place .", "@hoqhuuep good to know it be work as desire", "i 'll close the issue"], "issue_sim": [0.33575439453125, -0.03583550080657005, 0.023532148450613022], "prob": [0.9641228318214417, 0.02502049319446087, 0.027184907346963882]}]}
