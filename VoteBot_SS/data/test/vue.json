{"dataset": [{"target": [1], "doc": ["can you build a specific scenario in which you need a template with multiple root node", "i 've be use bootstrap and table with vue since the beginning and have never need multiple root node ."], "issue_sim": [0.4580230414867401, 0.5218466520309448], "prob": [0.17993023991584778, 0.8023367524147034]}, {"target": [2], "doc": ["fyi you can use <tag> and <tag> to easily pass down thing to the element you want", "you can have multiple root element in functional component :", "personally , i actually like the fact that we only have one root as it clear out the question you just list because there be only one possible answer"], "issue_sim": [0.45512285828590393, 0.44717472791671753, 0.274333119392395], "prob": [0.30292099714279175, 0.13020366430282593, 0.4194541275501251]}, {"target": [13], "doc": ["on my very specific table use case i have a <tag> component that i would like to contain two <tag> root element", "in the first <tag> i will show the category information , in the second <tag> i will list all the category items with its detail", "and the main category body will control the visibility of the second one", "i want it to look something like this :", "now i know i could move they to two separate component and have they communicate , but they really belong together , they have compute property and method they will share , and yes i can move those to a mixin , but that just make everything a bit more complex", "now , regard bootstrap , i recently stumble on this :", "i be use an <tag> and i need to have something like this :", "now , the input / vue - numeric pair be reusable , i actually have quite some logic around those two , so i want to reuse they , but the input - group itself be not reusable , since in some place i do n't need an input group or the input group be very different", "now when i move the <tag> and the <tag> into its own component i be force to use <tag> and <tag>", "unfortunately , that cause a whole lot of other problem , i need both element to be mount at all time , and work around it be n't fun , my problem would be go if i could just have they both mount and just <tag> they as necessary", "of course , i find a way to work around it , but it be n't the clean simple approach i want and that i can achieve in other framework", "i truly love vue , this be really just neat picking", "it would just be nice to have the option", "the nice thing about this feature be that if you do n't want to you do n't have to use it even think about it , just keep wrap everything in a div ."], "issue_sim": [0.5633262395858765, 0.22131052613258362, 0.0840955302119255, 0.07078516483306885, 0.38907191157341003, 0.2865602672100067, 0.22585250437259674, 0.2775980830192566, 0.32633447647094727, 0.2674866020679474, 0.30530035495758057, 0.035789310932159424, 0.13513383269309998, 0.4273713231086731], "prob": [0.37935012578964233, 0.13764625787734985, 0.00985975656658411, 0.003342482028529048, 0.10140444338321686, 0.0009988648816943169, 0.01082533784210682, 0.062323421239852905, 0.011796827428042889, 0.022440094500780106, 0.01160832867026329, 0.0007004351355135441, 0.00042325822869315743, 0.0986403152346611]}, {"target": [1], "doc": ["honest question here ,", "why do we even need to wrap everything on a single root element , be this a technical limitation or an arbitrary decision ?"], "issue_sim": [0.06367071717977524, 0.3384034037590027], "prob": [0.0066337320022284985, 0.9962862730026245]}, {"target": [1], "doc": ["technical , due to how the diff algorithm be write", "it be obviously possible to update it , but it take significant change to the current algorithm  ."], "issue_sim": [-0.09364981204271317, 0.11387366056442261], "prob": [0.057444747537374496, 0.8904381990432739]}, {"target": [0], "doc": ["the technical challenge be not with the conversion of template to render function , it be with the implementation of the virtualdom which the render function build node for .", "each child component be represent in its parent virtual   dom by a single <tag>", "in the current implementation , the diffing algorithm  can rely on the fact that every vnode of a child component have a single matching html element in the real dom , so the next vnode in the virutaldom after the child component vnode be guarantee to match the next html element in the real dom", "allow fragment require significant change to that algorithm , since we now would somehow have to keep the parent inform at all time about how many root nod the child be currently manage in the real dom , so when the parent re - render , it know how many html - elements it have to \" skip \" to reach the next html element that do n't belong to the child component ,", "that be a * very * intricate / complicated piece of code at the heart of vue , and it be critical for render performance - so it be not only important to make it work * correctly * but also to make it * highly performant *", "that be a pretty hefty task", "as evan mention , react wait for a complete re - write of its rendering layer to remove that restriction"], "issue_sim": [0.29585421085357666, 0.4145929515361786, 0.5200686454772949, 0.5455837845802307, 0.2616090178489685, 0.05716610699892044, 0.2463228404521942], "prob": [0.24338828027248383, 0.013822509907186031, 0.7479966282844543, 0.3462008535861969, 0.3394477665424347, 2.2874282876728103e-05, 0.00988271739333868]}, {"target": [0], "doc": ["no . i be say that the current virtualdom diff&patch algorithm heavily rely on the fact that each child component always have exactly one root element , so it would break completely with more than one root node in a child component .", "and i be say that make it work with more than one root component be more complicated , it add additional logic , so it be a challenge to make this change without negatively impact render performance in the current implementation"], "issue_sim": [0.5601705312728882, 0.3207992613315582], "prob": [0.6926623582839966, 0.5616918206214905]}, {"target": [2], "doc": ["i be still not convince that multiple root be even need", "if the core team be currently work on support it then that be great , but i do n't feel like they should if it be not on the roadmap already", "every time i 've think _ \" hey i might need multiple root node for this , \" _ it put i on a dangerous path of add too much complexity to a single component .", "i * always * end up with a well , simple solution that live well within the single root node paradigm", "most of my solution for the above usually rely on _ scope slot _", "i highly recommend learn how to use they well", "you will never need to think about multiple root node again"], "issue_sim": [0.2306932806968689, 0.3541067838668823, 0.4694085121154785, 0.31252986192703247, 0.13832440972328186, 0.0188603475689888, 0.2625805139541626], "prob": [0.08270683139562607, 0.579574704170227, 0.7719327807426453, 0.0855884924530983, 0.01716335117816925, 0.01189663726836443, 0.004104022867977619]}, {"target": [0], "doc": ["compute property be not reusable ."], "issue_sim": [0.21934780478477478], "prob": [0.9999674558639526]}, {"target": [0], "doc": ["almost everything be reusable through a mixin .", "you can use a function that generate a mixin", "this way you can bind a the", "i can not put that example on a fiddle now", "but i would do it asap", "however , i agree it be a very common use case for input to have", "a proper api or at least an explanation on the", "on tue , <number> sep <number> , 18:48 francisco loureno , notifications@github"], "issue_sim": [0.2147018313407898, 0.35385799407958984, 0.07673217356204987, 0.16946770250797272, -0.009227696806192398, 0.09456180781126022, 0.13127614557743073, -0.09029915928840637], "prob": [0.7999749779701233, 0.005931268446147442, 0.001719623920507729, 0.004258942790329456, 0.003217941615730524, 0.02458580583333969, 0.02411460317671299, 0.0850224643945694]}, {"target": [1], "doc": ["put in another way , compute property be not reusable", "you can use factory function + mixin as a * * work around * * , but the usability and readability do n't compare ."], "issue_sim": [0.3045859932899475, 0.38923200964927673], "prob": [0.00972434226423502, 0.9323793649673462]}, {"target": [1], "doc": ["for my project , i badly need this feature so i use the recommend custom input approach :", "in my opinion , this approach be very convenient and i decide not to use any v - model modifier at all include <tag> ."], "issue_sim": [0.32612544298171997, 0.3520103096961975], "prob": [0.5152705907821655, 0.47660622000694275]}, {"target": [1], "doc": ["the idea of this feature proposal be to take advantage of the exist <tag> directive , which already work with every <tag> element", "to save the work of write _ inputcustom.js _ in every project , because that have be do already in <tag> , have only to write the equivalent of _ inputtext.js _ in a custom modifier , which contain all the logic which need to be modify most of the time .", "the fact that <tag> already ship with modifier prove that it be an intuitive and desirable pattern", "it be only natural to facilitate the creation of custom modifier , to save the work of create custom element and have to implement dom / model bind manually", "if it make sense from the api perspective , would be interesting to know what be the technical limitation which be drive the decision of not implement this feature"], "issue_sim": [0.3047908842563629, 0.4915139675140381, 0.14510416984558105, 0.39909428358078003, 0.31592121720314026], "prob": [0.3252921998500824, 0.20452576875686646, 0.012752674520015717, 0.12999288737773895, 0.1257910281419754]}, {"target": [3], "doc": ["any chance we can get this issue reopen", "a common use case for i be the need to automatically format datum in a field as it be be type in", "something like take ' <number> ' and turn it into ' 10/12/16 '", "be able to create a custom v - model modifier would greatly simplify my code since i could write v-model.date instead of have to build a custom input component with prop and event ."], "issue_sim": [0.07230917364358902, 0.23775134980678558, 0.15582603216171265, 0.49075546860694885], "prob": [0.008579351007938385, 0.7125433683395386, 0.030992761254310608, 0.6057819724082947]}, {"target": [0], "doc": ["after use vue js for a while now in my project , i think this issue should indeed be reopen", "at least we need an <tag> modifier ."], "issue_sim": [0.2522246539592743, 0.31969329714775085], "prob": [0.9386940002441406, 0.025837281718850136]}, {"target": [1], "doc": ["i agree that this issue should be reopen", "not sure what <tag> be suppose to do , but i would like a <tag> modifier that set my variable to <tag> in case the input 's trim value be an empty string .", "i 'd love to be able to do that myself in a straightforward way"], "issue_sim": [0.10797066241502762, 0.39694273471832275, 0.10634397715330124], "prob": [0.012831569649279118, 0.9702660441398621, 0.005929690785706043]}, {"target": [0], "doc": ["write custom component be fine but if you want to use a 3rd party custom component like <url> there be no straight forward way to sanitize the masked input to model value except use compute property ."], "issue_sim": [0.4986901879310608], "prob": [0.9995600581169128]}, {"target": [2], "doc": ["+1 for custom modifier", "seem like a no brainer , unless there be a good reason not to", "mask input and parse the value for application use be a very common practice , and make some \" syntatic sugar \" like v - model.lazy.currency=\"amount \" would be amazing !"], "issue_sim": [0.29207494854927063, 0.03939209133386612, 0.30585727095603943], "prob": [0.006732012145221233, 0.07190792262554169, 0.9717150330543518]}, {"target": [3], "doc": ["+1 for custom modifier", "i come from an angular background , and just start with vue , and see this thread", "i feel it would really help have something like angular 's parser and formatter , in vue too", "if i could do something like v - model.dateformat and result in something like mm / dd / yyyy , it would be really cool .", "edit : look like it reiterate on what @restored18 say", "+1 to you too"], "issue_sim": [0.29207494854927063, 0.19699138402938843, 0.30557122826576233, 0.23432396352291107, 0.03441085293889046, 0.04673713445663452], "prob": [0.0014983339933678508, 0.07951588183641434, 0.3725087344646454, 0.6686357259750366, 0.00806890707463026, 0.003676644992083311]}, {"target": [3], "doc": ["+1 for custom v - model modifier", "in my case i loop over a few nested object retrieve in json , and use a single html template", "in this case i believe compute property do n't work", "i be currently put in custom conversion method between the server format and v - model format when fetch and send datum , but would love for something just \" build - in \" that i could pass the function to ."], "issue_sim": [0.357003778219223, 0.3088836371898651, 0.1318599283695221, 0.4047952890396118], "prob": [0.0445132851600647, 0.24067705869674683, 0.010880249552428722, 0.8345556855201721]}, {"target": [2], "doc": ["it use to be available before 2", "you could access the property through ,", "it be remove with the addition of custom model input value , but be a very useful feature and should be back in the framework ."], "issue_sim": [0.11804743111133575, 0.0029658712446689606, 0.41732192039489746], "prob": [0.022569656372070312, 0.08902666717767715, 0.8860195279121399]}, {"target": [0], "doc": ["it be a necessary feature for dry code in my opinion .", "right now i have to create <number> watcher that do the same thing for a form with a lot of input", "a custom modifier would solve everything"], "issue_sim": [0.11892721056938171, 0.23544570803642273, 0.2512589693069458], "prob": [0.6860487461090088, 0.28943273425102234, 0.0023572854697704315]}, {"target": [1], "doc": ["i have already +1 this , but want to throw a note for people who need something ow", "while modifier be way more effecient , i have be able to achieve the same effect use a transparent input / component with a compute getter / setter field .", "i can share an example if someone need it"], "issue_sim": [0.04178132861852646, 0.42935478687286377, 0.13618788123130798], "prob": [0.027121642604470253, 0.9898747205734253, 0.003230463480576873]}, {"target": [2], "doc": ["we do not implement this because there be many thing to be consider in this seemingly easy feature :", "- the build - in modifier be in fact compile - time hint that generate different compile code", "custom modifier likely need to be define use a runtime config , which be a different mechanism .", "- for runtime config , what kind of api should we expose for this", "- we have two - way filter in the past", "a two - way value transform require the user to implement impeccable logic so that the two - way binding can stabilize", "otherwise you risk put your entire app in an infinite loop for edge case", "- the reason we have <tag> and <tag> be because they be in - fact one - way transform  and thus guarantee to stabilize", "- how should custom modifier behave when <tag> be use on a component", "- how should custom modifier behave on non - text input type , e", "<tag> , <tag> and most importantly , <tag>", "all of these question be unanswered and make the request more complex than it seem", "this be why i agree it would be a good candidate for a proper rfc that cover all these if anyone really want this feature", "until then , more +1s do n't move it forward in any way"], "issue_sim": [0.3029661476612091, 0.2902703881263733, 0.4047727584838867, 0.33183228969573975, 0.30371320247650146, 0.3896191716194153, 0.07108903676271439, 0.23199039697647095, 0.44646066427230835, 0.42137837409973145, 0.17428608238697052, 0.030961740761995316, 0.22090312838554382, 0.016949227079749107], "prob": [0.3136127293109894, 0.010814409703016281, 0.1610744595527649, 0.013446363620460033, 0.0008713770657777786, 0.05583760887384415, 0.0041428133845329285, 0.0324615053832531, 0.031294871121644974, 0.0029430300928652287, 0.0005677416338585317, 0.01206523273140192, 0.0059309909120202065, 0.001314610242843628]}, {"target": [0], "doc": ["hmm , i do n't know about that but for component like that i think you could use jsx or <tag> to spread prop ."], "issue_sim": [0.45054465532302856], "prob": [0.9999562501907349]}, {"target": [1], "doc": ["for we this would be a great", "we wrap all input in a label for styling and ux purpose .", "i agree that we could drop down to jsx instead but the template be so much easy for everyone to follow"], "issue_sim": [0.02931755594909191, 0.19179269671440125, 0.3353261351585388], "prob": [0.0025099175982177258, 0.9919113516807556, 0.06440208107233047]}, {"target": [1], "doc": ["i like this feature personally", "but it seem to break the consistency of the v - bind behavior , like sometimes i still need to bind <tag> property for the root element .", "so how about use a pair of directive as getter and setter like :", "inside the component , define a <tag> anchor :", "when use it :"], "issue_sim": [0.03970607370138168, 0.3963088095188141, 0.2624313533306122, 0.3081445097923279, 0.010915594175457954], "prob": [0.013279227539896965, 0.8342878818511963, 0.162812739610672, 0.07285826653242111, 0.012019983492791653]}, {"target": [0], "doc": ["that look awesome , but again , that look like a basic spread and with potential problem like how would you define <tag> ?"], "issue_sim": [0.08912026137113571], "prob": [0.9999697208404541]}, {"target": [0], "doc": ["you ca n't just <tag> , that mean you 'd have to keep all modifier like <tag> and <tag> in the runtime"], "issue_sim": [0.20921942591667175], "prob": [0.9999724626541138]}, {"target": [2], "doc": ["i personally use <tag> or you can filter those out to exclude the prop you do n't want to apply", "this way you can apply multiple prop at once on an input", "indeed v - expose might be useful because for wrapper component such as input you have to specify all those html prop", "cane be reduce to <tag> or <tag> where filteredprop might be some compute property"], "issue_sim": [0.24675673246383667, 0.23043157160282135, 0.42978888750076294, 0.11062534153461456], "prob": [0.17742392420768738, 0.018682174384593964, 0.12762697041034698, 0.013824728317558765]}, {"target": [5], "doc": ["@chrisvfritz how would that work in render function", "i think maybe it would be well to :", "* provide an option to disable auto - inheritance of attribute for the root node", "* expose those attribute as <tag> , for example", "* use v - bind to add they wherever you like , much like we already show to do with <tag> :", "that would have the add benefit of work practically identical in jsx / render function"], "issue_sim": [0.2113887071609497, 0.022898592054843903, 0.5013191103935242, 0.29989808797836304, 0.21722814440727234, 0.32684260606765747], "prob": [0.013467988930642605, 0.015502152033150196, 0.25620028376579285, 0.009892825037240982, 0.4156038165092468, 0.00863460823893547]}, {"target": [2], "doc": ["@linusborg i like the way you think", "your way be much more intuitive", "as a sidenote , i think with this api in place , the next major version of vue could even remove attribute auto - inheritance altogether , so that cross - component communication could remain explicit on both side ."], "issue_sim": [-0.030186599120497704, -0.02065572887659073, 0.4951931834220886], "prob": [0.0015005763852968812, 0.05308406054973602, 0.9610018134117126]}, {"target": [0], "doc": ["the main purpose i have in mind be to make work simple for ui component author  .", "there be currently a lot of case where something like this be necessary :", "a new <tag> property could shorten it to this :", "though then i suppose it 'd still be nice to have some way of also expose event", "maybe an empty <tag> directive could forward all event listener on the parent to this element", "or if there do end up be multiple concern we want to bundle , we might be back to something like <tag> :", "this have turn into a broad discussion of how to simplify the building of ui component , rather than a specific feature request , so i 'll relabel this issue"], "issue_sim": [0.2483278214931488, 0.14196434617042542, 0.1833527386188507, 0.07480763643980026, 0.5420500040054321, 0.1888878047466278, 0.27370697259902954], "prob": [0.047359880059957504, 0.05210566520690918, 0.026005860418081284, 0.027624445036053658, 0.05406584590673447, 0.4017985165119171, 0.4295039176940918]}, {"target": [1], "doc": ["come from an argument about api surface in another issue , i must repeat that i be not a fan of the <tag> idea", "it introduce another \" way thing work \" , and do n't work for jsx without also implement something special there , etc .", "one thing i respect about react folk be their commitment to a slim api and use the language 's feature as much as possible", "in that spirit , re - use a pattern we already have for prop for attribute seem much well than introduce another abstraction"], "issue_sim": [0.20864051580429077, 0.30519771575927734, 0.1654113531112671, 0.3699612617492676], "prob": [0.016092929989099503, 0.5905725955963135, 0.05722861364483833, 0.16970635950565338]}, {"target": [0], "doc": ["in general , i 'd say for low - level component lib , render function should be prefer when template be get awkward to work with .", "but i agree that the following would be valuable :", "disable the default behavior of \" auto apply binding that be not find in prop as attribute to the root element \"", "expose an easy way to \" inherit \" external binding on the component onto an inner element that be n't necessarily the root", "ideally with consistency between template and render function"], "issue_sim": [0.4447266161441803, 0.054939787834882736, 0.5389582514762878, 0.5466353893280029, 0.20674024522304535], "prob": [0.9675746560096741, 0.014493853785097599, 0.029691580682992935, 0.016175396740436554, 0.0028403284959495068]}, {"target": [1], "doc": ["a duplicate of <url>", "you could use something like this :. <tag> <tag> <tag>", "where <tag> be your function"], "issue_sim": [-0.044201143085956573, 0.48471203446388245, 0.1307343989610672], "prob": [0.14941197633743286, 0.8038984537124634, 0.0970926582813263]}, {"target": [0], "doc": ["similar issue open all the time and and people insist that they can not justify implementation well people want to use it that be one justification i can also list the bazillion of issue close that ask the same thing xd", "i also find one that justify the use - case really well and refer to es6 specification when it come to map order ->still close ."], "issue_sim": [0.10994075238704681, 0.3459722399711609], "prob": [0.8693235516548157, 0.24924050271511078]}, {"target": [0], "doc": ["it be important to be able to iterate over iterator in loop .", "that seem plainly obvious", "it be a fundamental feature of the language", "the reason for support it be :", "<number> ) iterator , maps , and set be all valid es6", "refuse to support they mean limit yourself to es5 , which be a decision become less and less justified over time", "<number> ) i be build an application that have internal datum store in maps and set", "instead of make they available to the ui , i now need to keep the datum sync between the two manually , or write boilerplate and import it into my template to do the conversion whenever the datum be need", "this be exactly what vue be intend to avoid"], "issue_sim": [0.3128010034561157, -0.007402496412396431, 0.02378757856786251, 0.023790137842297554, 0.26509466767311096, 0.09138324856758118, 0.17754650115966797, 0.4170292615890503, 0.03801129758358002], "prob": [0.8698936700820923, 0.002637160010635853, 0.0027770271990448236, 0.0005164149333722889, 1.129051270254422e-05, 0.010953609831631184, 2.4205237423302606e-05, 0.21085244417190552, 0.0006714892806485295]}, {"target": [0], "doc": ["just <tag> be probably not solution you want because of lack of reactivity  .", "as mention early , set and maps be not observable by vue", "in order to use those", "either in <tag> , or in compute property , method , watcher , template expression , etc", "ou need to create a serializable replica of this structure and expose it to vue", "here be a naive example which use a simple counter for provide vue with information that set be update :", "<tag> <tag> mysetchangetracker <tag> mysetchangetracker <tag> <tag>", "this illustrate a kinda hacky but <number> % working method for make non - observable datum reactive", "still , in real world case i end up with serialize version of sets / maps  , so no artificial counter / hack be involve", "i personally think this be a fair solution to a problem , but it definitely deserve some official documentation   therwise it be impossible to justify this as non - hacky way of deal with vue internal"], "issue_sim": [0.35711923241615295, 0.08268644660711288, 0.04173095151782036, 0.22829732298851013, 0.31609266996383667, 0.2560756206512451, 0.39520007371902466, 0.36039578914642334, 0.2687060832977295, 0.2620600461959839], "prob": [0.04580939561128616, 0.0064719729125499725, 0.002703233389183879, 0.010954435914754868, 0.0031648685690015554, 0.005508538335561752, 0.0017485885182395577, 0.021615443751215935, 0.007520473096519709, 0.5308663845062256]}, {"target": [1], "doc": ["@alexsandro - xpt , sorry , i be wrong , compute will be hacky as @inca say ,", "another hacky solution would be use <tag> with a method", ", here be an example"], "issue_sim": [0.05072511360049248, 0.3903799057006836, 0.01977022923529148], "prob": [0.10041435807943344, 0.7157641053199768, 0.029053201898932457]}, {"target": [1], "doc": ["i be not quite see the argument against add support for <tag>", "<tag> itself can be cleanly polyfille , and unless i be miss something , it seem like vue 's approach for add reactivity to array could very easily be extend to set .", "we 'd only need to wrap <tag> , <tag> , and <tag>"], "issue_sim": [0.3365051746368408, 0.4174787402153015, 0.28013893961906433], "prob": [0.04596913605928421, 0.45675769448280334, 0.1803051233291626]}, {"target": [8], "doc": ["the current problem with the vue", "set method on a plain object be that it trigger way too many subscriber when a property be add to the object", "actually , all the subscriber of all the property be trigger when only one property be add", "the performance of the view be badly impact when a map like collection contain hundredth of key", "for example , in my project thousand of subscriber be trigger when one element be add to the map use the vue", "when i look deeply into the vue", "js code , i can see where the problem come from", "the dependency that be trigger be those of the object , which mean that if the object have one property for each key , then all the dependency of all the key be trigger when just add one key", "so use plain object to mimic a map do not look as the right solution , and therefore have support for a map in vue be more than welcome for large collection of item"], "issue_sim": [0.16090267896652222, 0.3628862500190735, 0.22402632236480713, 0.17554013431072235, 0.25024405121803284, 0.04379349201917648, 0.04544628784060478, 0.2418401837348938, 0.4687481224536896], "prob": [0.00012382354179862887, 0.03238079324364662, 0.00873614102602005, 0.0007239794940687716, 0.030059590935707092, 0.00019531903672032058, 0.00020449144358281046, 0.34703338146209717, 0.24545055627822876]}, {"target": [0], "doc": ["it look like you be look for <tag> : <url>"], "issue_sim": [0.1019224226474762], "prob": [0.9996912479400635]}, {"target": [2], "doc": ["@yyx990803 , you be right this be pretty much what i be after", "however , it be interesting to note that <tag> be compile down to <tag> directive", "it would be cool if there be a way to do the same thing where something like <tag> be compile down to <tag> and you could use clean syntax like :", "btw , i really love this framework", "you 've manage to create an elegant , well document and easily comprehensible software with an economy of feature", "i previously use angular and finally realize that despite be support by google and widely recommend it be an inelegant , overcomplicated , inefficient mess", "i be also interested in mithril but ultimately be turn off by the idea of be force to template html in javascript", "i use jade and this work well with vue", "my frontend software stack currently consist of vue", "js , jquery , jade , stylus , autoprefixer , browserify and gnu make", "this setup be work really well", "js have be a breath of fresh air"], "issue_sim": [0.04459458962082863, 0.2519400715827942, 0.47656649351119995, 0.1795336753129959, 0.024462394416332245, 0.3910292387008667, 0.38943585753440857, 0.27308598160743713, 0.06390564888715744, 0.3914113938808441, 0.04221009090542793, 0.1481589823961258], "prob": [0.006452382076531649, 0.32928842306137085, 0.6812666654586792, 0.00020074902568012476, 0.0766185000538826, 0.12476526200771332, 0.01633332297205925, 0.00019278141553513706, 0.00027854522340931, 0.17928652465343475, 0.00011191669182153419, 0.0003349195176269859]}, {"target": [6], "doc": ["i just notice that there be one significant difference between <tag> and the feature i originally propose .", "<tag> do not allow the caller to get a return value", "since the usual case be that there be only one receiver , this can be a significant disadvantage", "for example , say i 've get an <tag> callback and the child need to either confirm or reject change base on the success of the callback which may require contact the server and/or user interaction", "this can be easily handle by the parent return a promise when the <tag> callback be call", "however with <tag> this be not possible", "grant this could be solve by the parent respond with a broadcast event but then you need more event handler , a context and possibly a way to differentiate child of the same type"], "issue_sim": [0.1663384735584259, 0.2384110987186432, 0.046826690435409546, 0.43950188159942627, 0.5984212160110474, 0.13345053791999817, 0.5351928472518921], "prob": [0.29327070713043213, 0.03595941141247749, 0.019780809059739113, 0.4834653437137604, 0.017072850838303566, 0.005289736669510603, 0.46381792426109314]}, {"target": [1], "doc": ["it actually do : <url>", "additional argument provide to <tag> will be pass on to the callback ."], "issue_sim": [0.050303131341934204, 0.19815069437026978], "prob": [0.07356160134077072, 0.9465055465698242]}, {"target": [0], "doc": ["i be talk about return value ."], "issue_sim": [0.08435811847448349], "prob": [0.9998518228530884]}, {"target": [1], "doc": ["oh i see , i misread that", "the case for promise be valid but i be not sure if it be worth add a specific option / syntax for .", "on the other hand it be possible to use simple callback with <tag> :"], "issue_sim": [0.018689928576350212, 0.3624345660209656, 0.48237940669059753], "prob": [0.010736707597970963, 0.8045287132263184, 0.04663099721074104]}, {"target": [2], "doc": ["ok , callback be not a bad option", "i still like the idea of a <tag> option", "it could really simplify parent / child interaction with out couple they ."], "issue_sim": [0.214296355843544, 0.12088741362094879, 0.212915301322937], "prob": [0.0012101356405764818, 0.007628359831869602, 0.9859440326690674]}, {"target": [0], "doc": ["i understand your reluctance to add feature but it do parallel the way <tag> and <tag> work together .", "ignore the ability to return datum , <tag> would be just like <tag> but for <tag>"], "issue_sim": [0.27808916568756104, 0.3302309513092041], "prob": [0.9577425122261047, 0.02333325520157814]}, {"target": [0], "doc": ["i agree with keep vue.js simple but plugin require extra boilerplate code and increase page startup time due to load of extra .js file .", "they also do n't follow the same release schedule and so create an add maintenance headache", "then there be the issue of keep plugin up to date which have become a problem in every project i 've ever use which have a significant number of plugin"], "issue_sim": [0.38350892066955566, -0.015290153212845325, 0.10662487894296646], "prob": [0.5845082998275757, 0.010588697157800198, 0.6444411277770996]}, {"target": [0], "doc": ["the propose way look good , but it would impose some restriction to event name", "right now i can use complex event name like \" namespace", "eventname \" or \" action : submit \" etc", "with <tag> those be not possible i guess", "though it may be a good thing", "i agree with @jcoffland , have something like <tag> would be nice"], "issue_sim": [0.18630670011043549, 0.37083423137664795, -0.008842159062623978, 0.12566277384757996, 0.024949051439762115, 0.14136198163032532], "prob": [0.36691781878471375, 0.01831698976457119, 0.0032513008918613195, 0.0021839451510459185, 0.003177141770720482, 0.003181909443810582]}, {"target": [0], "doc": ["look like the community prefer to stick with current syntax . i think it be worth give <tag> a well , clear name  , but we be not go to move forward with the <tag> prefix ."], "issue_sim": [0.3101745843887329], "prob": [0.999962568283081]}, {"target": [2], "doc": ["i agree with stick with the <tag> prefix for vue", "js directive but what about the original feature request", "the user can already create their own component parameter , not in the <tag> namespace , via <tag> .", "this issue ask for the ability to create user define callback in a similar manner , perhaps use a component option name <tag>"], "issue_sim": [0.1563206911087036, 0.44406554102897644, 0.38148409128189087, 0.5558828115463257], "prob": [0.002524277660995722, 0.004882491193711758, 0.8961054682731628, 0.054810717701911926]}, {"target": [1], "doc": ["actually there be another , simple way how you can handle this case", "you can pass compute property with your listener object  to <tag> , example : <url>"], "issue_sim": [0.1551416665315628, 0.29467666149139404], "prob": [0.11864738166332245, 0.4593512713909149]}, {"target": [1], "doc": ["yes , @sqal 's solution be a good one and with inline like @yyx990803 's show be close enough to what i have in mind", "this lead i to a deep issue though : if a rebind happen  and upon evaluation the condition change  , exist event subscription be * * not * * clean up . they will still  be dispose at the end of the component 's lifecycle but not when they ' should ' which be when v - on rebind .", "this may be an edge case that do not have a large impact for most scenario but just for reference :", "in my scenario i have a complex svg and need to  attach mouse over / out handler to specific element base on some logic", "the component be a long live one and the underlie data change lead to rebind where i need to attach the event handler to different element at each rebind - hence my need to dispose of the previous subscription so they do n't dangle orphan and sad and drink memory", "a typical solution - and what i be go to end up do - be to set up one ' top level ' event listener  and let event bubble up to it   but to explain my motivation for try it the vue way first , there be quite a bit of processing that have to happen in my handler which i have intend to pre - calculate   and bake right into the event subscription itself so that the handler have less to do  and be not invoke at all for element that do n't require it"], "issue_sim": [0.19868941605091095, 0.5219120383262634, 0.16592496633529663, 0.388480544090271, 0.5258738398551941, 0.5987983345985413], "prob": [0.1267833113670349, 0.5150677561759949, 0.030709579586982727, 0.04382331669330597, 0.05338800698518753, 0.24688312411308289]}, {"target": [0], "doc": ["you may want to wrap with inline function if you be call a handler with custom datum ."], "issue_sim": [0.4270527958869934], "prob": [0.999993085861206]}, {"target": [0], "doc": ["in my case , i be try to do this on a disable button element  , but apparently chrome do n't fire the necessary event , and the element should be wrap in a div or similar to catch the event ."], "issue_sim": [0.5216368436813354], "prob": [0.9999377727508545]}, {"target": [1], "doc": ["we already have this as an option on our roadmap", "however , we will   pospone this until 2.0 be out of the current post - release phase and all work we have leave in the ecosystem for 2.0 be do , because this will involve a considerable amount of work to get right , test and so on", "thank for the poc , seem helpful"], "issue_sim": [0.11411672085523605, 0.13152968883514404, -0.0440194346010685], "prob": [0.01850929856300354, 0.9821277856826782, 0.001694351900368929]}, {"target": [1], "doc": ["i be look at exactly that", "for i , render function be too overwhelming and \" feel \" disjointed from the overall feel of single file component ."], "issue_sim": [0.00408470444381237, 0.43887126445770264], "prob": [0.000639607198536396, 0.9978886246681213]}, {"target": [0], "doc": ["this be go to make functional component so much easy to use !"], "issue_sim": [0.27675867080688477], "prob": [0.9993690848350525]}, {"target": [1], "doc": ["i think if it be a nice to have feature , since the default way to write component be use the template", "and imho decouple all the rendering function from the component  would be great ."], "issue_sim": [0.5366089344024658, 0.43329161405563354], "prob": [0.262119859457016, 0.3953591287136078]}, {"target": [0], "doc": ["the problem be that the scope of use template functionally be limit , much more than use jsx / render function .", "i think at the point of build functional component , the constraint and design pattern do n't fit a template model", "this feature require a small amount of extra runtime  and will never have the same performance as pure render function", "enable this feature will assume well performance , comparative to pure render function this be not true", "my stance on the feature at the moment , be that it will only empower template to be use functionality but give no true reward"], "issue_sim": [0.5657802820205688, 0.4361429810523987, 0.4681898355484009, 0.39182013273239136, 0.3748176097869873], "prob": [0.903934121131897, 0.044432491064071655, 0.10761769860982895, 0.0057687340304255486, 0.11107606440782547]}, {"target": [0], "doc": ["there currently be n't a way to implicitly pass down prop .", "- explicitly pass down prop be n't clean for object like store for your application state", "- plugins kind of solve the issue , but they can only be apply globally", "- <tag> be an option , but then you be force to set the datum on the root component"], "issue_sim": [0.2875635027885437, 0.45497822761535645, 0.29780882596969604, 0.3741776943206787], "prob": [0.2584162950515747, 0.13161934912204742, 0.00981284398585558, 0.11385234445333481]}, {"target": [0], "doc": ["possibly interesting alternative to context : plugin / mixin that apply to a component and all of it 's descendant , instead of globally"], "issue_sim": [0.610931396484375], "prob": [0.9990629553794861]}, {"target": [0], "doc": ["functional component already have this context feature .  though currently normal component do n't .", "i guess it can be useful if normal component can get access to it too"], "issue_sim": [0.4069520831108093, 0.4055534601211548], "prob": [0.9881282448768616, 0.0018598403548821807]}, {"target": [0], "doc": ["context in functional component only provide datum from the direct parent  , it do n't solve the problem of pass datum to deep descendantswhich be what context in react do , it be the same name for something different ."], "issue_sim": [0.5865412354469299], "prob": [0.9999809265136719]}, {"target": [1], "doc": ["i think this feature be nice to have in vue", "because some library actually implement this behavior  their own global mixin .", "and also , there be a use case on userland , e", "pass an event bus instance to all descendant"], "issue_sim": [0.33045971393585205, 0.37647902965545654, 0.18405699729919434, 0.3172498643398285], "prob": [0.0174097903072834, 0.785630464553833, 0.009101570583879948, 0.004744596779346466]}, {"target": [1], "doc": ["to get the ball rolling ;", "i need this feature in a recent project , and solve it by write two mixin : <tag> and <tag> .", "you 'd apply <tag> to a parent component , and it would create an <tag> object on the vm with whatever datum you want", "next , call <tag> on a child component would recursively look for a parent component that expose a certain property , and set it on the child component"], "issue_sim": [0.01139834150671959, 0.42264360189437866, 0.5613902807235718, 0.48653483390808105], "prob": [0.012475013732910156, 0.39973610639572144, 0.06448498368263245, 0.26957446336746216]}, {"target": [2], "doc": ["that would be the same as pass prop", "i be still unsure about the utility of a context on vue", "to i it look like the context issue be either solve with a state management library or by inject something to every instance .", "be a plugin that inherit the context from the parent override property what you be look for @sebastiandedeyne"], "issue_sim": [0.25593262910842896, 0.26198774576187134, 0.4488731324672699, 0.36800745129585266], "prob": [0.01696839928627014, 0.21117277443408966, 0.812041163444519, 0.045494455844163895]}, {"target": [3], "doc": ["let 's say that , hypothetically , vuex would n't be implement as a global plugin , but as something that can be apply on a per - component basis", "- pass down the store as a prop to every single child component would be counter - intuitive", "- there be no other way to inject an object that be set on a specific component instance", "i be look for a mechanism to have a property base on something that * * a * * parentan ancestorcomponent define , not necessarily the direct parent ."], "issue_sim": [0.46738719940185547, 0.5785551071166992, 0.5256704092025757, 0.2805961072444916], "prob": [0.8624972105026245, 0.044993773102760315, 0.03349862992763519, 0.03644736111164093]}, {"target": [0], "doc": ["of course we can do the same thing by explicitly pass value to prop but i think we sometimes need such implicit data propagation .", "in my case , for example , i be write  and it have component for shape  render on canvas", "the shape component have to be descendant of context component that have canvas dom element", "when the datum of shape component be update , i have to notify to context component through an event bus to re - render the canvas", "to do so , i need such react 's context - like feature to propagate an event bus because <number> ) it be quite verbose to write prop for all shape component , <number> ) it need its own event bus instance for each context component instance and <number> ) i do n't want to manage this on global state management as this be local view 's concern"], "issue_sim": [0.4212888181209564, 0.4066038429737091, 0.4320693612098694, 0.3969384431838989, 0.5726454257965088], "prob": [0.6582786440849304, 0.01406839583069086, 0.007423920091241598, 0.1017807349562645, 0.38816744089126587]}, {"target": [1], "doc": ["context be a convenient construct for library author and couple components", "for a library , it be quite strange and lame to encapsulate library local context in a separate global store .", "library author might be able to take the burden of pass prop all over , but component may also be an interface for end user", "@ktsn have a good example and good argument for context feature", "but i have some question about after read react 's context document", "it seem the cooperation of <tag> and <tag> be not a problem in vue because context be also reactive", "so there be no need to workaround context update as describe in this", "but i still have question on how context should be find", "for example , should context only be find as a child 's parent", "or only close ancestor", "if we resolve context as ancestor , how can we handle context key conflict", "it seem react 's context implementation only choose the close ancestor", "and this will easily cause problem when multiple library provide different context with the same name , say , one component receive context from another library component", "or we can collect all context property from ancestor and pack these property into an array or a map", "also , should context in parent component be visible to all its child , in template and slot", "or only to child in its template", "or only to child in slot", "or provide an option for user to choose"], "issue_sim": [0.35041654109954834, 0.3524964451789856, 0.3470005393028259, 0.20969119668006897, 0.30937516689300537, 0.234066903591156, 0.3326900601387024, 0.17231270670890808, 0.3305145502090454, 0.03558310493826866, 0.3636434078216553, 0.3597415089607239, 0.37276357412338257, 0.3170226216316223, 0.4952206313610077, 0.1747818887233734, 0.12861189246177673, 0.06898599863052368], "prob": [0.015032614581286907, 0.19382546842098236, 0.21546471118927002, 0.03590678423643112, 0.010378711856901646, 0.0723058432340622, 0.003428150899708271, 0.0029052968602627516, 0.0010741953738033772, 9.607290121493861e-05, 0.0029156783130019903, 0.0003609485866036266, 0.016330165788531303, 0.0037640624213963747, 0.02350720390677452, 0.0002611605741549283, 0.0016700434498488903, 0.0012996133882552385]}, {"target": [12], "doc": ["i start to think this feature should be desirably support by official", "the usage be quite different from those mention above", "in testing , i want to replace some dependency import from other file", "now the vue - loader official doc recommend to use inject - loader", "however , it depend on specific build system like webpack", "and inject - loader be quite of black magic", "if context feature be support , it can act like a dependency injection system , naturally", "and in test we can inject mock into component easily and universally , without hack build system", "another issue be discover in ssr", "currently bundle - render use <tag> module to evaluate code in sandbox", "this might be performance bottleneck", "on the other hand , we can not use global state in non - bundle render", "context feature can be the recommend way to manage global state .", "new state can be inject for every new request"], "issue_sim": [0.12556906044483185, 0.03356757387518883, 0.23694615066051483, 0.3346131443977356, 0.3759433627128601, 0.11852896213531494, 0.42322468757629395, 0.3433288633823395, -0.0406639501452446, 0.34301429986953735, 0.07545387744903564, 0.27246910333633423, 0.31204670667648315, 0.22604405879974365], "prob": [0.07865841686725616, 0.2802903354167938, 0.6038627028465271, 0.021040543913841248, 0.0037370072677731514, 0.005559759680181742, 0.010815665125846863, 0.013684200122952461, 0.0006406920147128403, 0.029346097260713577, 0.002461216412484646, 0.05932500958442688, 0.13381271064281464, 0.01205422542989254]}, {"target": [0], "doc": ["why not something like the"], "issue_sim": [0.09538891911506653], "prob": [0.9983128309249878]}, {"target": [0], "doc": ["it be possible to trigger a css transition on your demand at any time with a smil style vue - component .", "you define a custom transition component ,", "lie it inside the directive you want to perform the transition", "inject the component 's <tag> method into its <tag> component", "then you can call the transition whenever you like", "i 'll finish such a component and publish it in a few day if i 've time"], "issue_sim": [0.5596370100975037, 0.46318644285202026, 0.3565964102745056, 0.3207967281341553, 0.30684205889701843, 0.1044539138674736], "prob": [0.9264256358146667, 0.1697484850883484, 0.002725680125877261, 0.07557214796543121, 7.089953578542918e-05, 0.0012226402759552002]}, {"target": [0], "doc": ["it be a nice idea but in my opinion the javascript transition object be a really powerful feature because you can can hook each state of the animation , pause it etc .", "i do n't know enough vuejs , do you think it be a big effort to implement an extension of transition in order to apply it on any property"], "issue_sim": [0.5016634464263916, 0.5404763221740723], "prob": [0.5558772087097168, 0.3598545789718628]}, {"target": [1], "doc": ["a v - swap for change element would be a killer feature", "so that you can trigger a \" refresh \" on something like : src if you want to trigger animation when change stuff ."], "issue_sim": [0.3160362243652344, 0.43460533022880554], "prob": [0.04424713924527168, 0.8236480355262756]}, {"target": [0], "doc": ["i need this feature too , i be get around create simple array with one item to force vuejs transition but this solution be a bit messy", "every time <tag> change , the transition will be use. it would be awesome to have something simple and a bit less \" hacky \""], "issue_sim": [0.6020972728729248, 0.5906865000724792], "prob": [0.5904546976089478, 0.29298606514930725]}, {"target": [3], "doc": ["one area where i really miss transition be css class change", "it would be great to be able to assign transitional <tag> and <tag> class , when a certain css class change , like in angular <number>", "this would be a great help when , let 's say , you be build a responsive site , and you want to hide the mobile sidebar with transition on mobile , but be it always visible on desktop", "today , you can not do that : if you use <tag> , the content disappear  , and if you only use pure css transition , then you can not apply <tag> to the element .", "so yeah , i would love to see the ability to add transition - class to css class change"], "issue_sim": [0.6246109008789062, 0.5853590965270996, 0.4987449645996094, 0.6074151992797852, 0.6357108950614929], "prob": [0.008617319166660309, 0.35886335372924805, 0.34320324659347534, 0.3177747428417206, 0.006444653030484915]}, {"target": [0], "doc": ["the transition could play nicely with state change of vuex ."], "issue_sim": [0.5195456743240356], "prob": [0.99979168176651]}, {"target": [0], "doc": ["i would love to see something like  implement as a general transition component , either in core or as a helper library ."], "issue_sim": [0.511734664440155], "prob": [0.9991747736930847]}, {"target": [0], "doc": ["yep same for i at the moment i do use a custom directive like :. <tag>"], "issue_sim": [0.3381940722465515], "prob": [0.9999845027923584]}, {"target": [0], "doc": ["would it make sense to always call <tag> on certain event ?", "<tag> on <tag>and <tag> on <tag> in particular", "be there any legit use case where you * * do n't * * want to preventdefault for these three case"], "issue_sim": [0.3548884093761444, 0.15456920862197876, 0.2824222445487976], "prob": [0.9590652585029602, 0.0016289225313812494, 0.054240040481090546]}, {"target": [1], "doc": ["hmm nice suggestion , +1 for attribute modifier", "i think it should call <tag> automatically and if you want the opposite :. <tag> <tag> <tag>"], "issue_sim": [0.2734764814376831, 0.5177260637283325], "prob": [0.1788879632949829, 0.6735928654670715]}, {"target": [0], "doc": ["look good , but the problem be that event like \" click \" will not bubble by default , while event like mouseover should bubble in most case .", "so default will be different for different event type , which do not look good for i"], "issue_sim": [0.36962294578552246, 0.37803903222084045], "prob": [0.9855355024337769, 0.002878280822187662]}, {"target": [0], "doc": ["actually i do like the idea , but i would call it <tag> because it add aditional value in scope that be already create by <tag> ."], "issue_sim": [0.4393605589866638], "prob": [0.9998583793640137]}, {"target": [0], "doc": ["it be well to create a component for that and compute there only once the heavy operation you need"], "issue_sim": [0.36339932680130005], "prob": [0.9992984533309937]}, {"target": [1], "doc": ["@posva this be actually intend for one off computation you wo n't need anywhere else", "it be simple , quick , and offer more readability .", "for more complex and reusable computation and functionality , i always use the approach you mention"], "issue_sim": [0.1780785471200943, 0.03596215322613716, 0.3852784335613251], "prob": [0.0021917587146162987, 0.9867664575576782, 0.009938164614140987]}, {"target": [2], "doc": ["it be quick to add once you know the syntax , but it be one more thing to know and add another way of do the same thing", "that say , i see the benefit and simplicity of it ,", "i simply think it be well to use a component , even if it be just declare on one component , because if you know that way you know a more powerful way of abstract thing , and will probably understand well how to use component"], "issue_sim": [0.2600516974925995, -0.016123715788125992, 0.46176132559776306], "prob": [0.44853001832962036, 0.009555329568684101, 0.8852633833885193]}, {"target": [2], "doc": ["@posva , for compute one property such as i do in my example , i would probably use @nickmessing 's suggestion , * currently *", "if i need more complexity / functionality , i tend to use component for that", "i agree with you that component be the most powerful option  ) , but for some case it might feel a bit overkill .", "- one or maybe two computation : <tag> or <tag>", "- two or more : @nickmesse 's suggestion", "- more than a few property , use of any other view model functionality  , own template , etc : component"], "issue_sim": [0.46179330348968506, 0.3456892967224121, 0.25780412554740906, 0.10424937307834625, 0.03196042776107788, 0.2980222702026367], "prob": [0.01765810139477253, 0.008035527542233467, 0.47403088212013245, 0.0005778998020105064, 1.77394679212739e-06, 0.028952840715646744]}, {"target": [0], "doc": ["ok , still simple to use a component for all case", "on sat , <number> mar <number> , 15:59 carlos gonzales , < notifications@github"], "issue_sim": [0.31593257188796997, -0.1328476220369339], "prob": [0.7494678497314453, 0.049277763813734055]}, {"target": [0], "doc": ["i think <tag> would n't really work because what happen if something other than an object be return , right ?", "it could instead be something like :"], "issue_sim": [0.3208439350128174, 0.12809115648269653], "prob": [0.9638966917991638, 0.004700645804405212]}, {"target": [0], "doc": ["actually , you can , the tbody can be a component"], "issue_sim": [0.24789778888225555], "prob": [0.9997391104698181]}, {"target": [0], "doc": ["in fact the above method do not solve all the situation , i think add <tag> in template be a well way"], "issue_sim": [0.37282055616378784], "prob": [0.9998015761375427]}, {"target": [0], "doc": ["i feel it may over complexify the * template * syntax . any of compute property , method and component can solve these problem easily ."], "issue_sim": [0.44211921095848083], "prob": [0.9999924898147583]}, {"target": [0], "doc": ["i be afraid <tag> way be hardly scalabe .", "consider the trivial example above , it already have be quite verbose to specify <tag>", "readabilty and conciseness be objective , but at least for i the propose solution be n't the sweeti syntax", "a large component will probably worsen it", "for example , you also want to show the attendant 's meeting note in the component", "more logic be cram to <tag> directive", "the template will soon become unreadable and atrocious to modify", "note : we do n't have , sadly , a decent syntax / type checker for expression in template", "to reduce the complexity of template one will move the logic to vm / script , which be contrary to   the point of this proposal", "the predicate in <tag> directive will also become more complex", "consider : you want to display a person in meeting , but only if they be available accord to their schedule", "the function become <tag> , and it will become more complex with project grow and requirement change", "a large team will also worsen it", "a programmer want to skip a compute property , so do another programmer", "in team work a <tag> directive will , base on my own observation , promote more logic in template because one easy<tag> directive add initially will grow to a huge code blob by different team member", "we be always too lazy to add abstraction"], "issue_sim": [0.00583444070070982, 0.4445713758468628, 0.3067592978477478, 0.17139917612075806, 0.1545831710100174, 0.007725278846919537, 0.05217031389474869, 0.22813543677330017, 0.2638109028339386, 0.03225401043891907, 0.11708760261535645, 0.11472869664430618, 0.025059837847948074, 0.1679631769657135, 0.30139070749282837, 0.08993978053331375], "prob": [0.16129930317401886, 0.01281056459993124, 0.024820832535624504, 0.00032576199737377465, 0.004714361857622862, 5.687031080015004e-05, 0.0017206153133884072, 0.002178959082812071, 0.006895656231790781, 0.0006092234398238361, 0.0004597743973135948, 0.001226718071848154, 7.096001354511827e-06, 0.00014627889322582632, 0.7793657183647156, 0.0012442499864846468]}, {"target": [0], "doc": ["and another shorthand i 'd like be to allow to skip the value , like the es6 object shorthand :. <tag> <tag> <tag>"], "issue_sim": [0.463909387588501], "prob": [0.9998705387115479]}, {"target": [0], "doc": ["i be not convinced about that one , while it be handy , it make the template less readable .", "and i think vue", "js excel at readability", "i be not against it , actually i really like it , it be sexy : dancer : , i want people to discuss about it"], "issue_sim": [0.2723448872566223, 0.02702736295759678, 0.10178042948246002, 0.15850825607776642], "prob": [0.7400982975959778, 0.019400671124458313, 0.011624722741544247, 0.6103554964065552]}, {"target": [0], "doc": ["it would be very useful , especially with some kind of a cms , where all the relevant component would be send with json asynchronically , and the whole composite tree would be build up at runtime with dynamic component ."], "issue_sim": [0.5474347472190857], "prob": [0.999994158744812]}, {"target": [3], "doc": ["i just spend some time confuse by this , because the doc seem to indicate that it should work already", "it work on element , just not component  )", "would be great if this be implement", "a use case beyond write less code be write a reusable <tag> function for use in unit test :", "currently have to write an individual mount function for every single component because of this lack of functionality :("], "issue_sim": [0.17971321940422058, 0.46189334988594055, 0.17597562074661255, 0.33974000811576843, 0.36282116174697876], "prob": [0.4750135540962219, 0.08660481125116348, 0.0013207646552473307, 0.2592819929122925, 0.4885381758213043]}, {"target": [0], "doc": ["this feature will be very helpful when port react component to vue ."], "issue_sim": [0.5050874948501587], "prob": [0.9999363422393799]}, {"target": [0], "doc": ["the documentation say that for 1.x , too - it be only for element , not component .", "this feature request be valid in vue <number> , as well"], "issue_sim": [0.43661484122276306, 0.28280726075172424], "prob": [0.8494011163711548, 0.035717785358428955]}, {"target": [0], "doc": ["meta information for seo purpose do n't need to be dynamically update if at all .", "this be due to service mechanism to query your website , for a page url they will index by the initial synchronous request", "that mean that even if you update via js , search engine will most likely not index this way probably wo n't ever as this be indeterministic", "the good way to optimize for seo purpose be to statically generate your content for consumption by web crawler", "or manipulate the head with the correct meta content , at server level", "this be fairly simple to achieve by inject the content into the head of the serve document", "the only real exception for user experience be to dynamically update the title of the document", "other than that there be no true benefit of update the title dynamically", "there be exception such as addthis which will require manipulation via there client api to ensure that on use the client functionality that the content be set as prefer", "plugin that manipulate the while ' head ' of the document be generally fairly expensive for there purpose", "there be probably no reason you should be update the head completely to regenerate the meta data client side", "that say , it be certainly on our agenda , to provide some more information for good practice when it come to this common scenario", "we be plan to form a cookbook to provide this sort of information", "perhaps ask in the vue forum may be of aid , as there may be other that could provide there opinion in this subject"], "issue_sim": [0.33510053157806396, 0.3085663318634033, 0.27002429962158203, 0.25502729415893555, 0.16981929540634155, 0.2508288025856018, 0.3795495629310608, 0.2207108736038208, 0.4668542146682739, 0.23378175497055054, 0.4463759660720825, 0.18439102172851562, -0.006745580583810806, 0.04568099230527878], "prob": [0.4007467031478882, 0.0033042568247765303, 0.17634615302085876, 0.02002255618572235, 0.0016324857715517282, 0.005145105998963118, 0.004162982571870089, 0.0008983241277746856, 0.20708809792995453, 0.002994076581671834, 0.0035037475172430277, 0.014464633539319038, 0.0022721984423696995, 0.03433582931756973]}, {"target": [0], "doc": ["my good advice if you be concerned with provide meta content to the head would be :. . - add place holder to the html document template like <tag>. - create a store for seo , update with correct datum. - when serve the head of document ect , replace the placeholder with correct datum .", "if use any client base tool , you can use the store datum and update the title as necessary", "if you have any more question or concern let i know"], "issue_sim": [0.45871037244796753, 0.22216001152992249, 0.050701409578323364], "prob": [0.961857795715332, 0.37138739228248596, 0.0018605865770950913]}, {"target": [0], "doc": ["consider mine be an spa , and vue 's main use case be probably spa , i do think it be important to reactively update the title for a well user experience .", "as you put it , it sound fairly straightforward , so we can also assume that it would n't take much to integrate such a capability into vue itself , then"], "issue_sim": [0.2938315272331238, 0.28023505210876465], "prob": [0.8561230897903442, 0.3686319589614868]}, {"target": [0], "doc": ["for user experience , in a spa it be as simple as update the title on a route change .", "however , it be not deterministic when it may be need to update", "for example some use case could dictate open a model window be enough to change the title", "this be simple javascript , inevitably create an abstraction in vue to just change the document title be too much", "as say if use as a spa , which now day be become and   consider an anti - pattern , then your only real focus on meta data be the title for the ui experience", "which be simple to do and even a plugin would not cater for many use case , and will essentially be a wrapper to change the document title", "the real problem with dynamic meta information , fall to the server level", "at server level many tool can be use , many template engine and many other variant", "thus , suggestion and advice to a simple solution be good imho", "if vue dictate a setup or we officially stamp approval on a plugin , it will prevent choice of tooling out of scope of vue", "thus these be problem domain that be subject to what tool you use , which vue should avoid create friction with"], "issue_sim": [0.3268558382987976, 0.11830437183380127, 0.19371986389160156, 0.37323594093322754, 0.2933116555213928, 0.41648608446121216, 0.26639991998672485, 0.20696759223937988, 0.0443820096552372, 0.18573309481143951, 0.25316619873046875], "prob": [0.30551573634147644, 0.0034347432665526867, 0.015226038172841072, 0.0030046661850064993, 0.052855461835861206, 0.010596688836812973, 0.0005387040437199175, 0.00015231582801789045, 0.0002596860867924988, 0.017641987651586533, 0.0015564706409350038]}, {"target": [4], "doc": ["my current project have a modal , and yes , the title and other metadata  need to change depend on what the modal be show", "it do n't matter that it be just a modal , and vue should n't care that it be just a modal", "it be declare as a child in vue - router just like any other child", "i should be able to just include the require metadata change in the component declaratively , kinda how vue - meta work", "as you say , change something like the og image be obviously important to be handle by the server , but vue do n't offer a _ clear _ way of go about that .", "as for say spa be an anti - pattern , well that be just go with the current wind of javascript trend , which change every few month", "as evan point out in a recent tweet : \" people like different thing , you know", "i wish more programmer understand that too", "\" and in many project , an spa make the most sense"], "issue_sim": [0.3549104332923889, 0.2566896080970764, 0.2261386215686798, 0.4131568968296051, 0.4892629384994507, 0.24875898659229279, 0.06845910847187042, 0.16216212511062622, 0.10368575900793076], "prob": [0.29084599018096924, 0.08410578966140747, 0.00044795384746976197, 0.031735338270664215, 0.26122644543647766, 0.03191264718770981, 0.0024053880479186773, 0.0003293335612397641, 0.0005092669161967933]}, {"target": [2], "doc": ["on the client , what depend on the og image meta datum", "if a spa it be very unlikely that search engine / <appname> ect will pick up the correct meta information if you be dynamically update", "as this update will be asyncronous , clever search engine will attempt to but if you be rely on request datum after page have load then this will not be pick up .", "could you explain you use case in more detail", "so i can understand how a tool like vue - head / vue - meta make sense to your application"], "issue_sim": [0.15900340676307678, 0.2723798453807831, 0.27571654319763184, 0.12105225026607513, 0.26244938373565674], "prob": [0.0002044052234850824, 0.05436765030026436, 0.6669482588768005, 0.0004817374574486166, 0.09993960708379745]}, {"target": [5], "doc": ["yes , that be why i say :", "that be only important for when something like <appname> get this information from the page", "it do n't matter on the client", "the title and theme be two example of metadata that _ do _ matter on the client", "this be why it be important that handling of metadata be correct _ both _ on the client _ and _ on the server", "project like vue - meta matter because they prevent many devs \" reinvent the wheel \" of have declarative updating of page metadata , which be handle in a consistent way both on the client and with server - side rendering .", "for example , if you have a list of item and when a user click on one you want a page with more detail to open , you want it to open instantly since you already have the datum  or very quickly because you just need to grab a couple of small bit of datum", "but , you also want this data page to be directly - accessible", "in a ssr app the user would get this page pre - render with all the correct page metadata , which should be the same as if the user get there instantly from click a list item", "in that case , the page should also have the correct metadata apply", "that be just one example"], "issue_sim": [-0.03629300743341446, 0.18789324164390564, 0.1388544738292694, 0.21433889865875244, 0.39776450395584106, 0.5878556370735168, 0.2335626780986786, 0.10338827222585678, 0.39927127957344055, 0.3396615982055664, -0.08085940778255463], "prob": [0.06186472252011299, 0.021080084145069122, 0.0057711550034582615, 0.02305656298995018, 0.11645327508449554, 0.41370829939842224, 0.16629277169704437, 0.0008603204623796046, 0.05741391330957413, 0.002325605833902955, 0.000373171700630337]}, {"target": [0], "doc": ["it do n't make sense to i that vue have an excellent way of keep the url in sync with these navigational change but do not have a sensible way to keep metadata in sync along with it ."], "issue_sim": [0.452825665473938], "prob": [0.9999730587005615]}, {"target": [0], "doc": ["the ability to change the title seem to i the basic and thus fundamental feature .", "i have a site develop with php and now i be do a kind of practice to re - write it with react  and vue so that i can assess how convenient it would be", "my site be a book collection site , so to change the title of my dynamic page  to reflect the book title this page be on be quite useful", "i also need to update the <tag> and <tag> section to include the title , author , publisher , tag , etc", "just a piece of my thought"], "issue_sim": [0.0270056314766407, 0.39612793922424316, 0.34905028343200684, 0.3170977830886841, 0.00043783336877822876], "prob": [0.11413507163524628, 0.5559134483337402, 0.15385231375694275, 0.0315442830324173, 0.0045674932189285755]}, {"target": [0], "doc": ["change title and meta be really important for professional website , ca n't live without it .", "vue team should take this as high priority and make this happen", "how could this simple feature make unavailable to vue"], "issue_sim": [0.260639488697052, 0.2161141037940979, 0.1333768665790558], "prob": [0.9916315674781799, 0.004976741038262844, 0.007034312933683395]}, {"target": [9], "doc": ["i be surprised there be so much discussion whether the ability of change meta tag or title be an important feature", "i be manage a large application", "content marketing , seo , share on social medium be important marketing tool", "it be no question to i , whether it be a need feature or not", "i go through available plugin", "there be always something miss", "i be use <tag> to serve complete application", "it be already work fine , i take the example from <tag> template", "what i would like to do now , be to change the meta tag , directly from component", "every route have a coresponding page , most of they be dynamic page , for example <tag> .", "when a page mount , i be fetch corresponding datum from api , in this example the <tag> informaiton", "from the same endpoint i would like to serve meta - data", "which mean * * one api call per page * *", "other solution propose to fetch datum on server level", "that would mean that i have to modify the componenet , to use this datum", "or to make two api call", "it seem overly complicated to i , while the setup already be insanly complex", "for the propose solution to work , i would have to change the meta tag from component level", "- @jqemprendedorve i 've try your solution , but the meta end up in the body as <tag>", "- i 've try to use <tag> , which expose <tag> , except it do n't expose it in my case , i be not sure why and how to fix it", "- i 've try <tag> , which be not work , not to mention the entire <tag> package have completely different architecture , to \" simplify \" thing , which in my case would be much additional   work fix nuxt bug or develop workaround", "do anyone have a solution to modify the < meta > tag from component level"], "issue_sim": [0.259483277797699, 0.18209697306156158, 0.1022956445813179, 0.16680440306663513, 0.1370280385017395, 0.09918810427188873, 0.23988153040409088, 0.24492809176445007, 0.3750154972076416, 0.2675215005874634, 0.26772090792655945, 0.2509397864341736, 0.25250300765037537, 0.1936107575893402, 0.02674224227666855, 0.13847407698631287, 0.16488873958587646, 0.33619144558906555, 0.16386261582374573, 0.3595292568206787, 0.432528555393219, 0.317658007144928], "prob": [0.24514175951480865, 8.026415889617056e-05, 0.00027095494442619383, 0.0011815796606242657, 6.898762876517139e-07, 9.263041533813521e-07, 1.583705125085544e-05, 2.8980979550397024e-05, 0.0005484366556629539, 0.011712022125720978, 6.307789135462372e-07, 2.6779196559800766e-05, 5.281120252220717e-08, 2.8496134518718463e-07, 1.220193735207431e-05, 2.4203605789807625e-05, 0.00039795110933482647, 0.016604868695139885, 4.456478848169354e-07, 0.12064093351364136, 0.3279835879802704, 0.0006847713957540691]}, {"target": [0], "doc": ["technically , you should be able to do this by use a function that return the vnode and render use what vue already export  .", "not sure of the utility of a feature like this", "fyi you can use <url>"], "issue_sim": [0.4043526351451874, 0.03331689164042473, 0.10621890425682068], "prob": [0.9957097768783569, 0.010136445052921772, 0.0026328405365347862]}, {"target": [3], "doc": ["the issue be , the <tag> can not be pass to the server , besides by put it in the template  .", "you ca n't use complex function in template bracket , as they be single - expression only", "* * note * *", "it can not be render within the <tag> function inside the <tag> file because rendering be an async operation , which mean it can not assign a variable to <tag> safely , as <tag> be synchronous"], "issue_sim": [0.2446449100971222, 0.20099280774593353, -0.007002390921115875, 0.49667346477508545], "prob": [0.43080854415893555, 0.10593561828136444, 0.0007248572655953467, 0.5318169593811035]}, {"target": [0], "doc": ["if i have access to the propose function , i would be able to pass it to the server easily via the <tag> variable"], "issue_sim": [0.36859384179115295], "prob": [0.9999446868896484]}, {"target": [1], "doc": ["and i understand the use - case may be rare , but this be something that can and will increase server - side adoption and would be even useful for nuxt", "this would finally allow a head management system to exist in the html / template section of sfc and would make ssr , seo and head management much easy", "if this be not possible , do you know a way to find a solution to this issue"], "issue_sim": [0.22243767976760864, 0.3130052983760834, 0.1998339742422104], "prob": [0.7711508274078369, 0.5464732050895691, 0.03017500415444374]}, {"target": [2], "doc": ["i think i originally misunderstood the request when i add it to 2", "6 - after look at it in more detail i think this can be do in userland", "there be a few thing that i have concern about land this in vue itself :. - this method can not be expose on the <tag> runtime , since it be a server only utility", "- it be well expose on <tag> as an inject helper", "- the <tag> expose by <tag> can only be async because there may be async component or async data prefetch function down the tree", "we can not expose a sync api because it will not work correctly in all case", "in comparison , it be much easy to write a simple vnode - > string render function that only handle predictable <tag> content", "the use case also seem niche , so i think we 'd be well off to test an implementation in userland first"], "issue_sim": [0.10686678439378738, 0.047795865684747696, 0.35290348529815674, 0.3327706456184387, 0.28659510612487793, 0.33271387219429016, 0.5341252088546753, 0.2142741084098816], "prob": [0.008177144452929497, 0.02027035877108574, 0.3773302137851715, 0.003203504951670766, 0.08896085619926453, 0.002268892480060458, 0.0882706567645073, 0.03303593769669533]}, {"target": [1], "doc": ["i 'd be happy to implement this in userland , but the issue be that there be no expose api that i could use to render vnode to a string", "the reason you * * ca n't use * * <tag> be because the operation be async , and the bundle renderer wo n't wait for promise in the <tag> operation", "async function rendervnodes {", "// create bundle renderer for the head", "// return render string", "// error because template ca n't handle promise value", "//pass $ ssrcontext the vnode renderer"], "issue_sim": [0.5333244800567627, 0.37392890453338623, 0.2300141453742981, 0.4377868175506592, 0.46336042881011963, 0.2789574861526489, 0.2829328775405884], "prob": [0.874647319316864, 0.7733579277992249, 0.00015762861585244536, 0.025862133130431175, 0.0007093861349858344, 0.07191525399684906, 0.011026431806385517]}, {"target": [3], "doc": ["from study the internal , it seem the two option be :", "make the lodash template compiler able to handle await ( which would probably mean implement a custom template compiler for the <tag> set", "expose an api for synchronously render vnode in the <tag>", "the simple option would be rewrite the template compiler for the <tag> to allow <tag> expression , this would also remove the lodash template compiler dependency"], "issue_sim": [0.026529695838689804, 0.3624208867549896, 0.5556252002716064, 0.36110424995422363], "prob": [0.06548751890659332, 0.14285947382450104, 0.009514854289591312, 0.42850181460380554]}, {"target": [3], "doc": ["i think this overcomplicate the problem", "it be quite straightforward if what you need be just sync rendering of head element", "vnode be just object in the shape of <tag>", "you be essentially write a function that serialize a few such object into html string ... it probably be just <number> line of code without have to patch anything in vue itself ."], "issue_sim": [0.04603923484683037, 0.2836899757385254, 0.1959688514471054, 0.5080708265304565], "prob": [0.039194755256175995, 0.043447062373161316, 0.0039938450790941715, 0.8340854644775391]}, {"target": [3], "doc": ["you be right , i will probably just do that", "but i still actually like the function - base template", "it allow async operation in the template", "- make the bundle renderer easy to use , and more js templating  instead of <tag>", "- the documentation could be simplify", "- could potentially remove / deprecate string - base lodash template dependency", "* * with template function * *", "< html$ { context", "' ' + context", "htmlattr : '' } >", "$ { await context", "$ { result }", "< script>$ { bundle", "client } < /script >", "< /html > <tag> <tag>", "* * vs string template * *"], "issue_sim": [-0.007392385043203831, 0.18308715522289276, 0.2084241509437561, 0.5938445329666138, 0.16549333930015564, 0.37277498841285706, 0.1188562661409378, 0.09497296810150146, 0.07182592898607254, 0.026298832148313522, 0.034409262239933014, 0.017514387145638466, 0.06729623675346375, 0.20443511009216309, 0.41933247447013855, 0.15971913933753967], "prob": [0.017298715189099312, 0.3184420168399811, 0.02051668055355549, 0.1994694173336029, 0.0026162711437791586, 0.011299570091068745, 0.0055541968904435635, 0.0004324073379393667, 0.00015689143037889153, 0.0005038948147557676, 8.92876269062981e-05, 0.00026166089810431004, 0.00028601576923392713, 0.003269698703661561, 0.00894936267286539, 0.0006297781364992261]}, {"target": [1], "doc": ["@alucidwolf what be you try to accomplish", "you should n't be render html code from a server , if you need a dynamic menu , send the menu datum as the datum , and let your .vue file render it"], "issue_sim": [0.06270056962966919, 0.4658828377723694], "prob": [0.0034854323603212833, 0.9673781394958496]}, {"target": [3], "doc": ["i would love to see that happen", "i be try to use vue", "js with nashorn too", "it will be great if vue.js ssr add interface such a filesystem or engine to externalize. some functionality that be bind to node.js", "i 've make some research :", "<tag> in all place can be abstract", "currently use <tag> , <tag> , <tag> , <tag>", "<tag> in all place can be abstract too", "currently use <tag> , <tag>", "only one usage <tag>", "accord to doc and soruce code this only wrap script code with", "so this be can be replace with function if we be not on node", "<tag> , <tag> use in create-bundle-runner", "this file can be somehow abstracted :) not sure how and what interface could look", "<tag> , <tag>   todo   :)", "i make small modification in source code to get rid of <tag> and <tag>", "only createrenderer  and remove path and stream require", "after browserify - > <number> kb", "after browserify run - > <number> kb", "after browserify - > <number> kb"], "issue_sim": [0.0346798449754715, 0.07193118333816528, 0.3759760856628418, 0.6021412014961243, -0.07873515784740448, -0.0024474896490573883, 0.20439749956130981, 0.0423111729323864, 0.15959620475769043, -0.059462569653987885, 0.10438863933086395, 0.353973925113678, 0.070371113717556, 0.26716873049736023, 0.1128242015838623, 0.1914081871509552, 0.1879648119211197, 0.3830956816673279, 0.38455966114997864, 0.3830956816673279], "prob": [0.08646313846111298, 0.000558986677788198, 0.003091330174356699, 0.526953935623169, 0.020477304235100746, 0.0014517486561089754, 0.021213650703430176, 0.012457176111638546, 0.0025156354531645775, 0.0035648662596940994, 0.041783176362514496, 0.005942049436271191, 0.006385881919413805, 0.021995816379785538, 0.004251755308359861, 0.04101618379354477, 0.004165796097368002, 0.0007592270849272609, 0.0018409527838230133, 0.0042991433292627335]}, {"target": [2], "doc": ["you can find \" my \" code here :", "package / vue - server - renderer - nashorn / vue - nashorn", "js - > complete js file with all require dependency and polyfill for nashorn", "i try to do modify vue source as less as possible", "people can build vue for nashorn typing <tag>. for jasmine test in nashorn type <tag>", "currently only <tag> work", "<tag> have some issue with thread but should be resolve soon", "<tag> be currently comment because first i must resolve issue with <tag> but on my todo :)", "if you have any question i 'll try answer :)"], "issue_sim": [0.046856749802827835, 0.5128636956214905, 0.5626949071884155, 0.20180772244930267, 0.49642783403396606, 0.060655247420072556, 0.17224258184432983, 0.19656981527805328, -0.04588007181882858], "prob": [0.23833169043064117, 0.08709295094013214, 0.17060838639736176, 0.030003594234585762, 0.06606537103652954, 0.0015649959677830338, 0.026637695729732513, 0.0721825361251831, 0.007859532721340656]}, {"target": [3], "doc": ["the result be consistent to what i try use react", "benchmark use jmh framework show that typically nashorn version server side render be <number> % slow than node", "i think of waste time in <tag>/<tag> nashorn context", "since vue.js use <tag> module and react.js not , i expect well performance ssr use vue.js .", "run ssr in nashorn be more robust than in node", "thread - control , ability to terminate render at any time , cache across thread", "@wojtask9 how about share your benchmark code to see if something can be optimize"], "issue_sim": [0.2557671070098877, 0.573532223701477, 0.09719717502593994, 0.49196261167526245, 0.4680754244327545, 0.16616880893707275, 0.1872972846031189], "prob": [0.017547057941555977, 0.24443528056144714, 0.08722616732120514, 0.9005585312843323, 0.00450098654255271, 0.09963525831699371, 0.00277334195561707]}, {"target": [0], "doc": ["i honestly think this be simply because v8 produce much well optimize machine code than nashorn ... not much can be do in vue / react to solve that :/"], "issue_sim": [0.3755558729171753], "prob": [0.9999934434890747]}, {"target": [2], "doc": ["nashorn directly map js to jvm bytecode , implementation now may not great enough as v8", "i believe thing will get well", "it be valuable to make vue.js ssr not bond to a specific javascript runtime .", "define some abstract interface and provide node", "js implementation as default will be great"], "issue_sim": [0.519963264465332, 0.03375136852264404, 0.4332432746887207, 0.24210982024669647, 0.42811107635498047], "prob": [0.035523172467947006, 0.06933522969484329, 0.9138070344924927, 0.010960026644170284, 0.023722384124994278]}, {"target": [0], "doc": ["that be probably what we will do in the future - but for now we want to focus on provide a good , stable and performant node - base ssr solution first ."], "issue_sim": [0.30575329065322876], "prob": [0.9999209642410278]}, {"target": [0], "doc": ["for now , it can be implement with render function , by pass the render vnode to another component .", "here be a basic example : <url>", "i 've be use something like the above in production for some time , and it seem to work well"], "issue_sim": [0.4541149139404297, 0.07264132797718048, 0.16524308919906616], "prob": [0.838433563709259, 0.03185928240418434, 0.17640772461891174]}, {"target": [4], "doc": ["fyi , i be currently play with this idea as well , and on a big scale , with a target anywhere in the dom", "you can see my progress here :", "as far as i have test it , it work pretty well , but i do n't think i have catch all edge case and i be not sure that this work in all case", "it work like this :", "so far , this only work with the <tag> component , but i be play with the idea of a kind of <tag> prop that will make the <tag> create a target component anywhere"], "issue_sim": [0.38655000925064087, 0.014696165919303894, 0.1633620709180832, 0.10342834144830704, 0.5766369104385376], "prob": [0.06203923374414444, 0.0077974372543394566, 0.6887882351875305, 0.0006261581438593566, 0.5041559934616089]}, {"target": [0], "doc": ["close this as i believe it be possible to implement portals in vue 2.x in userland with current feature set .", "if anyone be interested in it , keep an eye on @linusborg 's repo"], "issue_sim": [0.4864043891429901, 0.08638361096382141], "prob": [0.8320791125297546, 0.07773812115192413]}, {"target": [1], "doc": ["be there any chance that we support portal natively in vue", "although  be work nicely in most case , it still have side effect like leave an empty wrapper element thus may interfere with something  rely on dom structure like <tag> or <tag> .", "if the <tag> and <tag> can just work as abstract component it would be great", "imo we can not eliminate the empty wrapper but still get everything right unless the feature be support by vue 's core"], "issue_sim": [0.48402848839759827, 0.32696786522865295, 0.3248218297958374, 0.19858890771865845], "prob": [0.15078677237033844, 0.5348263382911682, 0.06354386359453201, 0.31808778643608093]}, {"target": [0], "doc": ["i still think this should be implement natively into vue because this be one of the most common thing that library implement their own way of do it and it result only in code bloat , bug and increase bundle size .", "in other word , it would stop people from reinvent the wheel"], "issue_sim": [0.3152391016483307, -0.057069480419158936], "prob": [0.9195960760116577, 0.03991575166583061]}, {"target": [0], "doc": ["just as an example , a user import different \" select \" , \" tag \" , \" dropdown \" and he himself use vue - portal , now what that mean be that there be now <number> instance of custom \" portal \" code .", "could we re - evaluate the necessity of this feature"], "issue_sim": [0.5601820945739746, 0.06061992049217224], "prob": [0.9832870960235596, 0.0032225295435637236]}, {"target": [2], "doc": ["that can be say about many , many thing / feature", "look at react , where the core lib come with even less feature than vue  , like no transition system , the community simply come up with a bunch of solution , eventually one of those lib become a de - facto - standard", "it be not the goal and mission of vue to provide a core feature for every common need in web development - the goal be to provide the basic toolset to build solution that satisfy these need .", "and while portal - vue do n't have thousand of star , it be gain in popularity and could solve the problem in that way - all of the above solution would converge on use portal - vue in that case", "even if that do n't happen , the code involve to build a bare - bone portal solution for a single library like a drodown be very small , so i do n't see a big overhead here", "that be say , we might add portal at some time in the future , when we work on vue <number> , rewrite the virtualdom and simply do that in a way that keep portal in mind as a core feature", "right now the problem can be solve elegantly enough in userland , so there be no immediate need to put a lot of work into a core implementation", "* disclaimer : i be the author of portal - vue and a vue core team member , so there may be some conflict of interest , but at the same time , i know both perspective *"], "issue_sim": [0.008573033846914768, 0.38611161708831787, 0.2515650689601898, 0.4098658561706543, 0.3838610053062439, 0.4354405999183655, 0.10940022766590118, 0.3614198863506317], "prob": [0.0022984733805060387, 0.3463640511035919, 0.06783533841371536, 0.47042983770370483, 0.22052080929279327, 0.16657081246376038, 0.03165000304579735, 0.12165495753288269]}, {"target": [5], "doc": ["i understand that , but as i do try write a portal'ish logic in a couple different way  , there be n't many way you can do that to avoid dom mess where it should clean up but leave stale element , or if the component be standalone , there be no \" portal - target \" thing , i just need it to add the dropdown to the body , so the solution be not that elegant and become hacky - like the whole portal functionality feel at the moment", "i know we all have different mindset what \" portal \" should do , but in my mindset , it should not deal with \" element by i d \" or allow drop part of component into another component etc", ", that just allow user instead of structure a data drive codebase , to turn it into a mess that be hard to manage and could be solve in more traditional and simple way", "it should be simple , allow drop into specified dom element - <tag> , <tag> etc", "and just work with transition while clean up what s need on component removal which at the moment the only guarantee seem to be when each portal'ed element be wrap into a component , or be a component that do the cleaning , but at the end of the day - a wrapper be a wrapper , and we hate wrapper", "in theory the portal thing sound easy than it actually be , for example , if the portal be as a directive , it need to know if the element have transition , otherwise you get big fat error when the transition itself try to remove the element and many other small detail that you come across when try to implement such thing .", "so a somewhat support solution would solve many headache and unexpected outcome"], "issue_sim": [0.6368973255157471, 0.485118567943573, 0.30945003032684326, 0.3820708692073822, 0.38671842217445374, 0.5693893432617188, 0.017015472054481506], "prob": [0.4240155816078186, 0.37279072403907776, 0.0800812691450119, 0.0031276470981538296, 0.10362382233142853, 0.21801947057247162, 0.0013567892601713538]}, {"target": [11], "doc": ["i be not sure what the api for that should be if you do n't want it to be do with a wrapper component", "from your description i have get a good picture about how you imagine this to work", "i be not sure who you refer to as \" we \" , but i can say that we from the vue team do not hate wrapper - much to the contrary , encapsulate behaviour in wrapper component be a concept we use for many such thing , like <tag> , <tag> or <tag> , <tag> and <tag>", "i bet if we implement a portal functionality in core , it would use some sort of wrapper as well , just with a deep integration with the underlie virtualdom , probably", "if you want to create a feature - rich solution for many scenario , that be right", "if all you need be to move a modal to the end of the <tag> , that be not really hard", "well , implement it with a directive - which be aware of transition in vue by design - would approach this at the wrong level of abstraction", "directive be mean for low - level dom access which vue 's transition be highly abstracted - that be part of why i * do * solve it with a component", "back to the top a bit :", "i do n't take it as an attack , no worry", "you raise a valid critisism against use portal - vue excessively - that can indeed happen if user do n't approach their app with a data - centric mind", "but that do n't invalidate the whole concept to be useful for solve the specific problem that it * do * solve nicely , like move modal , dropdown menus etc to the end of <tag> ."], "issue_sim": [0.47823137044906616, 0.023329131305217743, 0.31761783361434937, 0.4353777766227722, 0.07136667519807816, 0.13909399509429932, 0.3882310390472412, 0.5392017364501953, 0.015958260744810104, 0.013359695672988892, 0.3089694082736969, 0.23632264137268066], "prob": [0.40143853425979614, 0.10700380802154541, 0.06762421876192093, 0.22910231351852417, 0.0014456588542088866, 0.045930322259664536, 0.055024195462465286, 0.12035345286130905, 0.0002929654438048601, 0.000697435112670064, 0.030424077063798904, 0.12246719002723694]}, {"target": [6], "doc": ["should 've be more clear , by a wrapper , i do n't mean a wrapper component , but rather a wrapper element , which introduce a headache when use with buy template  that be not framework base , where there be a lot of direct child selector and a wrapper element can cause the theme to break", "it be true , but at the end of the day it kind of achieve the same result", "most common component base portal usage be implement in the follow way :", "while directive equivalent be similar :", "which both work for what they be worth while keep they without wrapper element , keep inject / provide work etc", "though directive will have problem when the transition be not on the <tag> element without advanced lookup , yet most big component library use both , yet more directive base approach", "the nice thing about component base approach be that it keep transition work and clean up the element , and with the undocumented <tag>  , the separated element be not display in the component tree .", "maybe it be not as bad as i make it seem to myself , maybe i just need to step back and think it over again", "edit : i remember evan say this should n't be do , maybe that be why i feel bad about it"], "issue_sim": [0.38839125633239746, 0.022559422999620438, 0.43071722984313965, 0.09006934612989426, 0.23236984014511108, 0.3865355849266052, 0.3944835066795349, -0.025642748922109604, 0.09996750950813293], "prob": [0.8892633318901062, 0.0031925386283546686, 0.0027456125244498253, 7.173162885010242e-05, 0.003418745705857873, 0.09569741785526276, 0.18247011303901672, 0.01701786182820797, 0.0033106955233961344]}, {"target": [0], "doc": ["the _ ! important _ level be already use in some component to purposely override vue v - show behaviour .", "the current level as inline style be the most appropriate", "just put the condition on your _ visible- _ class instead of use v - show", "it make no sense to have a hidden element with some _ visible- _ class anyway"], "issue_sim": [0.5255794525146484, 0.145119309425354, 0.4349862337112427, 0.4634072184562683], "prob": [0.8968055844306946, 0.012251395732164383, 0.05581343546509743, 0.005891921930015087]}, {"target": [1], "doc": ["as @sylvainpolletvillard say ,", "if you want to apply <tag> you should create a class for it ."], "issue_sim": [0.005561094731092453, 0.265847384929657], "prob": [0.0006715740310028195, 0.9961113333702087]}, {"target": [3], "doc": ["@posva v - hide do not apply a class to the element when hide", "if it do this would be a non - issue", "would n't a class have to be apply via v - bind", "seem like a contrived way to go about hide an element and would make v - hide completely useless when do responsive design in a popular css framework ."], "issue_sim": [0.44354432821273804, 0.11306679993867874, 0.20260277390480042, 0.6123372316360474], "prob": [0.018117625266313553, 0.05750982090830803, 0.014220256358385086, 0.70085608959198]}, {"target": [0], "doc": ["<tag> do n't exist but you can create your own use the  as a reference .", "you can even publish it to npm a post it here", "yes , the class have to be apply with a v - bind"], "issue_sim": [0.03896709531545639, 0.05553139001131058, 0.17596344649791718], "prob": [0.989912211894989, 0.0008839835645630956, 0.021693890914320946]}, {"target": [4], "doc": ["it would still be <tag> vs <tag>", "<tag> be the nuclear bomb of css specificity : there be nothing above it", "bet on a double <tag> conflict for the application layout be a terrible idea imo", "i do not know the reason why bootstrap <tag> class use <tag> in the first place , but by make this decision , it imply that bootstrap claim the priority on the element visibility state", "vue should not interfere in this priority war , otherwise we would have the opposite problem where a user want to override the style in css but ca n't because of vue ."], "issue_sim": [-0.015498939901590347, 0.3346322178840637, 0.2641924023628235, 0.6294387578964233, 0.554523229598999], "prob": [0.004683331120759249, 0.02870892733335495, 0.028054049238562584, 0.2520252764225006, 0.45590195059776306]}, {"target": [3], "doc": ["@posva yeah i understand what that mean", "like i say before i think that seem like a contrived way to do it and would defeat the purpose of have <tag> for those that use responsive class .", "i be remark on the philosophy of the design choice", "if the design be to allow component to override the show directive i argue that be a poor design choice if support for popular css framework be intend", "this issue will return many time in the future from folk use responsive class since it will simply look like <tag> be not work", "i agree with @codysherman in that vue should take precedence over something like a responsive class since the model should represent a more accurate picture of display intent"], "issue_sim": [0.05069165304303169, 0.23931854963302612, 0.06236747279763222, 0.5681039094924927, 0.4179733991622925, 0.5122193694114685], "prob": [0.009875515475869179, 0.5397406816482544, 0.00426301546394825, 0.41324377059936523, 0.04680730402469635, 0.010763725265860558]}, {"target": [0], "doc": ["yes it will , because inline style have the high specificity"], "issue_sim": [0.258998304605484], "prob": [0.9998843669891357]}, {"target": [3], "doc": ["i personnally use this for @media print query", "i have some layout handle with <tag> that i want to be always visible or hidden when print", "my usecase be a form compose of multiple step , one visible at a time on computer , but they all need to be visible when print", "with this change , it wo n't be possible to do this anymore since you ca n't override inline <tag> with medium query .", "i be sure there be other valid use case where override in css be necessary", "something like <tag> look like the right thing to do here"], "issue_sim": [0.11291292309761047, 0.36348891258239746, 0.32154580950737, 0.1534157246351242, 0.5182628631591797, 0.07216157764196396], "prob": [0.0018504569306969643, 0.21796320378780365, 0.23380224406719208, 0.31352299451828003, 0.0043551442213356495, 0.0018281019292771816]}, {"target": [1], "doc": ["i would say this be not vue 's problem , but bootstrap 's problem", "it be bootstrap use ! important that force everyone into this specificity war .", "if i be you i 'd not use static css that have", "important unless for very specific reason like printing", "and i do n't think this be a common case"], "issue_sim": [0.4426971971988678, 0.45380330085754395, 0.3575122356414795, 0.17851108312606812, -0.001470433548092842], "prob": [0.32907816767692566, 0.5961208343505859, 0.017532655969262123, 0.010683401487767696, 0.02839818224310875]}, {"target": [0], "doc": ["here be a pure css solution that might help anyone catch in this dilemma out :"], "issue_sim": [0.31832611560821533], "prob": [0.9998319149017334]}, {"target": [1], "doc": ["@yyx990803 it could be a bootstrap 's problem , but at the same time bootstrap also  to use <tag> on display property", "vue should n't change the default behaviour , and bootstrap ca n't remove <tag> from its utility", "but i still like @posva suggestion of add an option like <tag> for those who want to use it .", "another option could be add a * * new global configuration property * * for this :"], "issue_sim": [0.564566969871521, 0.44600605964660645, 0.09819847345352173, 0.17653195559978485], "prob": [0.028549188748002052, 0.36789435148239136, 0.4623371660709381, 0.022389870136976242]}, {"target": [0], "doc": ["curious - could n't this just be do with custom two - way filter ?", "maybe i be miss something"], "issue_sim": [0.11251376569271088, 0.0161688644438982], "prob": [0.9509015083312988, 0.011581326834857464]}, {"target": [0], "doc": ["it seem like a date transform for the date / datetime input type would be useful .", "however , i be more interested in be able to register transform", "- momentjs transform instead of a potentially build in date transform"], "issue_sim": [0.4640752077102661, 0.369577556848526, 0.6155221462249756], "prob": [0.9236017465591431, 0.09837259352207184, 0.1188545823097229]}, {"target": [3], "doc": ["@rpkilby i think two way filter work out pretty well for this", "the guide actually talk about this <url>", "maybe a more explicit example show <tag> in the doc help out", "i do n't think a modifier be need because two way filter already address this issue"], "issue_sim": [0.04295529052615166, -0.0603618323802948, 0.2561034560203552, 0.16712579131126404], "prob": [0.01753537356853485, 0.06807775795459747, 0.11782099306583405, 0.23703892529010773]}, {"target": [15], "doc": ["@posva - yes , and we currently do this", "i guess my problem be that i have vague  dissatisfaction with the api for deal with various datum type", "i have some thought that have n't really form into anything cohesive", "- boolean value and array selection be handle magically for input of <tag>", "- number value be * * not * * handle magically for input of <tag> , and require a <tag> paramater", "- any other data type require a two - way filter", "the result of all of these leave we with :", "- give that checkbox have magical behavior , it be understandable that someone would expect that number would have magical behavior as well", "- forgetting to add the <tag> parameter be an easy source of bug", "- why do <tag> get special treatment anyway", "should it be replace by a filter", "- filter seem like they should be use for * * value * * transformation , while this request be more about * * type * * transformation", "- i also do n't like the idea of pollute the filter namespace with type transformation filter", "out of a form context , they do n't make much sense", "at the very least , it be great that vue have global and component - local registration , so this be n't really an issue", "regardless of opinion on the above , i do think it would be good to add a section on two way filter to the form doc as a way of handle type conversion .", "- also , really want to reemphasize that these be very minor consistency / api nitpick", "vue have be a huge boon and the exist form binding * * work * *", "- one downside to the proposal be that there would be some overlap between two - way filter and v - model type transform", "- i apparently like bulleted list"], "issue_sim": [0.07823222875595093, 0.21028056740760803, -0.006489522755146027, 0.1714634895324707, 0.1061473935842514, 0.08657529205083847, -0.07572963833808899, 0.11913470178842545, 0.17978620529174805, 0.060639820992946625, 0.15703432261943817, 0.5694157481193542, 0.4191136956214905, 0.04624968022108078, 0.2056826800107956, 0.3368327021598816, 0.19277355074882507, 0.1338220238685608, 0.2224307656288147, 0.08085516095161438], "prob": [0.00014464346168097109, 0.0030478108674287796, 0.004198439884930849, 0.004907868802547455, 0.05010121315717697, 0.00042684501386247575, 7.270537935255561e-06, 0.035612836480140686, 0.006933347787708044, 4.0847575291991234e-05, 0.0002087010070681572, 0.0027832125779241323, 0.004053801763802767, 9.183577640214935e-05, 0.004390038549900055, 0.23602434992790222, 0.0012025204487144947, 5.9236568631604314e-05, 0.026534901931881905, 6.957042933208868e-05]}, {"target": [0], "doc": ["ditto , remove filter seem to beg for some hook on v - model to accomplish type / value transformation ."], "issue_sim": [0.369684636592865], "prob": [0.9999610185623169]}, {"target": [1], "doc": ["the problem with other type transformation other than <tag> be that the conversion from the value back to string be not straightforward", "e.g. for a date transformer , if you programmatically set the bind value to a <tag> object , there be no way for vue to know how to display it as text in the input box .", "then again we be back to similar concept as two - way filter", "type transformation also by definition make the view out of sync with the underlie state", "my take on this use case be that instead of the implicit magic conversion , let <tag> just sync what the user actually input with an underlying value  , and then build * * derive * * value separately base on that value", "for example , you can perform these transformation only when you need to send it to the server for persistence", "or , use compute property base on the bind value if you need to display it elsewhere in a different format"], "issue_sim": [0.4753280282020569, 0.5013867616653442, 0.04447054862976074, 0.4339803457260132, 0.36862045526504517, 0.48573416471481323, 0.3718761205673218], "prob": [0.25890758633613586, 0.527638852596283, 0.012044734321534634, 0.002633269876241684, 0.39507752656936646, 0.011613334529101849, 0.01745907962322235]}, {"target": [9], "doc": ["_ preface : upon reread , it be unclear if you be talk about remove the <tag> directive or not , but my argument can be apply to any sort of transformation between a form 's datum and what be store in a model , not just numeric input", "for simple use case , this may be sufficient", "however , i have a use case with about <number> <tag> field", "a rare case , admittedly , but it be what i 've get", "since i need to perform math operation on the user input , i would end up with significantly more than <number> compute property for those operation , and then the code to save to the server would be an annoying  merger of the compute property and the underlie data object", "i agree in principal with \" let <tag> just sync what the user actually input \" , however my contention be that when a user be present with a <tag> field the user 's intention be to input a number , so vue should store it as a number .", "the user do n't know that html5 's spec for number input be weird ; they be ask for a number , so they input a number", "i be fine if i have to do _ some _ work somewhere  , but i do n't want to have to define <number> + compute property and then write code to try and merge those compute property with another object just so i can turn it into json to send to my server", "it feel like an inelegant solution , compare to other framework", "my use case be numeric input , but be a little more pedantic , you could apply the same logic to the value for check box  , date field , radio button , etc", "any time you have a large number of property that need special handling , you 'll run into this problem", "i just do n't think that ' use a compute property ' scale well", "i 'd be a lot more sanguine if it feel like there be a clear path forward that have the same elegance i be use to in the rest of the framework"], "issue_sim": [0.3919811248779297, 0.18012839555740356, 0.16599929332733154, -0.008089026436209679, 0.3519194722175598, 0.24776986241340637, 0.06038060784339905, 0.3465622067451477, 0.10189331322908401, 0.2986266613006592, 0.14716026186943054, 0.2295612096786499, 0.14296391606330872], "prob": [0.11896425485610962, 0.0054497928358614445, 0.005940618924796581, 0.0025648768059909344, 0.264519065618515, 0.1929289549589157, 0.00722276559099555, 0.23406140506267548, 0.0007866300293244421, 0.3040904998779297, 0.0014603487215936184, 0.0013042333303019404, 0.3313933312892914]}, {"target": [1], "doc": ["@morgul <tag> be still available because the conversion from a number to a string be very straightforward", "that be not the case for other arbitrary type , e.g. date ."], "issue_sim": [0.3695084750652313, 0.3087981343269348], "prob": [0.0005771977012045681, 0.9989898800849915]}, {"target": [8], "doc": ["hmm , there be many problem at the moment to implement that", "the syntax be not currently possible", "_ note that space be not possible , so that would be a common source of error that we want to avoid ( people will want to use they between event for readability _", "we could use other character like <tag> though", "a more realistic version with current syntax", "would n't work because there be only one arg for directive and that would lead to this modier object :", "so , to put it in a nutshell , a syntax like :", "could be possible but it be a new syntax that people will need to learn to replace something that be already feasible :", "personally , i think the second version be more straightforward and easy to read so imo we should pass on this but i think it be worth listen to other ' opinion"], "issue_sim": [0.17696210741996765, 0.17865394055843353, 0.3846150040626526, 0.0941472202539444, 0.1735987365245819, 0.36845922470092773, 0.1298934519290924, 0.271079421043396, 0.20311076939105988], "prob": [0.013002375140786171, 0.01691412553191185, 0.8294736742973328, 0.005586473736912012, 0.0005043769488111138, 0.01290402002632618, 0.008627606555819511, 0.015909405425190926, 0.22960831224918365]}, {"target": [6], "doc": ["why be space not possible", "be that a limitation from the parser or from html perhaps", "if it be the former case , could it be possible to modify the parser so it accept those space in that particular case", "i really do not like that version :", "since it be really hard to read", "perhaps with a character that be more visible", "i think i would prefer the <tag> character since it be unlikely to be use in a custom event name , whereas <tag> could more likely be .", "indeed , it be already possible but more verbose and less legible in my opinion", "my solution would be a bit like use <tag> instead of <tag> ;)", "anyway , thank for take the time to review this"], "issue_sim": [0.0624617375433445, 0.22559987008571625, 0.2833824157714844, 0.00043342728167772293, 0.00788916926831007, 0.10419946163892746, 0.3587648868560791, 0.18291041254997253, 0.39200592041015625, -0.023271432146430016], "prob": [8.402395178563893e-05, 0.00023021329252514988, 0.08693252503871918, 0.00011546031601028517, 0.0005749947158619761, 8.772384171606973e-05, 0.591250479221344, 0.02014440856873989, 0.6976990103721619, 6.556548760272563e-05]}, {"target": [0], "doc": ["this would somehow inverse the current <tag> order that we all know .", "i be not sure have it reverse just so we can use multiple callback be the way to go", "it 'll likely confuse the user"], "issue_sim": [0.23841652274131775, 0.3970181941986084, 0.019575662910938263], "prob": [0.9848002195358276, 0.012719596736133099, 0.0026199736166745424]}, {"target": [3], "doc": ["if the syntax i have mention above be possible :", "1/ the bracket will let user know that this kind of event handling will be inverse ,", "2/ i think this syntax be clear since as @posva say , space be not possible in the attribute part ,", "so why do n't we put all of that event and modifier to the value part and the only one function call in   bracket or something like that   so user will know the difference ."], "issue_sim": [0.2553196847438812, 0.31153425574302673, 0.3467051386833191, 0.34041792154312134], "prob": [0.002852905774489045, 0.06975606083869934, 0.04984590411186218, 0.9052229523658752]}, {"target": [1], "doc": ["this would be a totally different syntax but what if you could just add all the event in a single attribute , like this :", "i be not sure this be realistic since there might be some conflict with the normal syntax , but i think this be a lot more readable and to grasp than add a extremely long attribute"], "issue_sim": [0.5284823179244995, 0.3190697133541107], "prob": [0.09463860094547272, 0.672332227230072]}, {"target": [3], "doc": ["this seem to be a topic that a few people be passionate about and that be great , and there a some really creative idea about how to tackle this , which also be great", "however for i personally , every syntax proposal so far still seem too complicated , too \" abstract \" , too far away from html & js", "it be great to save keystroke and get rid of repetition , but not at the cost of an easy to grok syntax", "and generally , i be increasingly oppose to any new syntax , at least any that do n't bring new * feature * with it because in my opinion ,   our api surface be big enough as it be .", "i would rather see that we get <tag> work with modifier :", "then it would be trivial to write a helper method like this :", "and we can keep all of those listener definition out of the template"], "issue_sim": [0.1635752171278, 0.2715887129306793, 0.30741745233535767, 0.24892288446426392, 0.29612016677856445, 0.3417883515357971, 0.14121857285499573], "prob": [0.5974620580673218, 0.30239972472190857, 0.0982055589556694, 0.7122662663459778, 0.03246519714593887, 0.008055849932134151, 0.004418798256665468]}, {"target": [0], "doc": ["so what do you think about extend the <tag> directive to accept a array of object , just like the one pass to <tag> in my", "i think its quite nice to have the listener definition in the template"], "issue_sim": [0.4115809500217438, 0.27909404039382935], "prob": [0.8677858114242554, 0.005733046680688858]}, {"target": [9], "doc": ["i be not sure to follow @linusborg , do that syntax mean that for multiple event , we would have something like that", "if that be the case , then you have the same problem that today , which be a lot of duplication", "<tag> have the advantage to just go to the point , without any repetition", "i think take the listener out of the template prevent you to get a full picture of what be go on when look at it", "with this , you 'd have some listener define in the template , other elsewhere", "that seem not optimal", "about the * long attribute * , this notation would just be a shorthand for what already exist", "if you prefer to use one line per event and duplicate the handler name , that be fine", "if the handler definition be too long , you can just use the non - shorthand definition format", "i guess if you have <number> event that call the very same handler , you could perhaps divide those in the template on multiple line too ."], "issue_sim": [0.4640340209007263, 0.2824794054031372, 0.13904280960559845, 0.28918468952178955, 0.18103821575641632, -0.08550822734832764, 0.28683289885520935, 0.4401821196079254, 0.29747313261032104, 0.6321286559104919], "prob": [0.14299987256526947, 0.07577019184827805, 0.009180564433336258, 0.1124405488371849, 0.0024062872398644686, 0.0002702142228372395, 0.01662367209792137, 0.0044024791568517685, 0.01484632957726717, 0.06913090497255325]}, {"target": [0], "doc": ["i be say that once the v - bind syntax that i show be work  , then it be trivial to write a helper function like the one i show , which * create * that object for v - bind .", "that would mean that   we do n't have to introduce new template syntax and can instead solve this with about <number> line of js"], "issue_sim": [0.5439268350601196, 0.2762887477874756], "prob": [0.9119098782539368, 0.15648230910301208]}, {"target": [0], "doc": ["have all the event there , in one place , in the template give you a good idea of what the component react to .", "i be not sure put some logic elsewhere will help achieve that goal", "sorry for shoot down the idea :x"], "issue_sim": [0.35926878452301025, 0.10277003794908524, 0.01127837598323822], "prob": [0.8925632834434509, 0.046834394335746765, 0.027474112808704376]}, {"target": [0], "doc": ["i be just think that you might need to listen to the same set of event in multiple place so this could help to avoid repeat yourself which could cause a lot of other problem .", "put it in in the global config would also make it informant of component", "if you want you could also give they more declarative name like <tag>", "also be the goal here to easily pass multiple event the same function"], "issue_sim": [0.4201759099960327, 0.2389647364616394, 0.24737252295017242, 0.5451861619949341], "prob": [0.9591506719589233, 0.12713254988193512, 0.00506588164716959, 0.010165436193346977]}, {"target": [4], "doc": ["the goal here be indeed to be able to use the same function for multiple event , without have to copy / paste the function name x time in the template", "if you * \" need to listen to the same set of event in multiple place \" * , then this point be moot since the goal be to call the same function * * within * * that same component", "if you need to do :", "then just do :", "on the other hand , if you be think about call the <tag> function from multiple component , then i think it be out of this feature request scope .", "for this i would just use a <tag> in order to keep <tag> dry"], "issue_sim": [0.5893006920814514, 0.45466357469558716, 0.026416398584842682, 0.005266101099550724, 0.5516890287399292, 0.2455342710018158], "prob": [0.18364162743091583, 0.4927629828453064, 0.00012805379810743034, 0.0007283940212801099, 0.6304749846458435, 0.0008874727645888925]}, {"target": [0], "doc": ["we be in general try to avoid add more alternative syntax to the template system , and in this case the benefit  really be n't worth the addition imo .", "- the fact that you can not use space in an attribute name make most of the proposal impractical", "- what @linusborg suggest might be the good solution", "however , many of the modifier be actually compile into code during the compilation phase , thus make it costly to add runtime support for they", "i think the good path forward would be a userland library that expose the <tag> method and implement the runtime behavior for each modifier internally"], "issue_sim": [0.20858076214790344, 0.1665683090686798, 0.08865856379270554, 0.21654394268989563, 0.39869266748428345], "prob": [0.35234853625297546, 0.06479252129793167, 0.0007046293467283249, 0.2940281927585602, 0.03237249329686165]}, {"target": [1], "doc": ["i be think more of how we currently have <tag> and <tag> that do the same thing", "there be in my opinion not so much difference when do <tag> for avoid repetition .", "yes , if there be no way around it , then this solution be a bit * ' dead in the water ' * :/", "i still think have this kind of repetition make the component behavior hard to comprehend :", "or perhaps i be create too complex component or just not the right way"], "issue_sim": [0.2546727657318115, 0.17887632548809052, 0.11886152625083923, 0.24948449432849884, 0.18298491835594177], "prob": [0.4071614444255829, 0.30481740832328796, 0.19975599646568298, 0.012758167460560799, 0.005258094519376755]}, {"target": [0], "doc": ["i find that concatenate all the handler with dot and ampersand everywhere be pretty hard to parse when read that template ."], "issue_sim": [0.5000514984130859], "prob": [0.999922513961792]}, {"target": [0], "doc": ["i would say for the first question , i do n't care if it work automatically , but that it at least do n't require another abstraction to accomplish .", "it should basically work close to how it would work if there be no component", "this be a huge part of the problem for i", "i have n't be able to solve it because of a few case where i want to use enum constant  in option value", "value <tag> be always a string , and thus , this solution would not work where the type of the value prop should be literal / expression :", "maybe it would be possible to make <tag> v - model=\"$attrs \" <tag> work similar to <tag> v - bind=\"$attrs \" <tag> and be smart enough to not warn about direct prop mutation", "what be really need be some way of get the prop attribute , why be we only allow to get access to the non - prop one"], "issue_sim": [0.25458234548568726, 0.2628692090511322, 0.00712154246866703, 0.2518325746059418, 0.3907148838043213, 0.3985426723957062, 0.38742923736572266], "prob": [0.3279615342617035, 0.030737871304154396, 0.0015044399769976735, 0.40405187010765076, 0.2506043612957001, 0.1733858436346054, 0.1679188460111618]}, {"target": [1], "doc": ["@nickmesse thank so much ,", "that do seem to work , but i ca n't seem to make the follow work without a vue warn about directly mutate the <tag> value <tag> prop .", "ideally i would n't want to and do not want to add another <tag> value <tag> to the data section or similar as it would seem redundant", "be there a way of achieve this simple component without get too verbose"], "issue_sim": [-0.047297023236751556, 0.4507349729537964, 0.27118465304374695, 0.4191102683544159], "prob": [2.2479649487650022e-05, 0.9361003637313843, 0.28922298550605774, 0.001363404211588204]}, {"target": [0], "doc": ["you could experiment with implement option <number> just for your component , like in  ."], "issue_sim": [0.39138534665107727], "prob": [0.9999707937240601]}, {"target": [4], "doc": ["i be not sure this be desirable", "first off , <tag> and <tag> be add to make it easy to pass on these thing from a parent component to a child component , to improve the situation for hoc - like component", "make this work with <tag> be not a goal in this original discussion", "secondly , if we somehow make this work - that you can use <tag> on a component with <tag> on an element * in * that component , it feel to i like we essentially recreate inter - component two - way binding which we originally drop in vue <number> for good reason", "yes , under the hood it be technically still send event and update in the parent , but what happen under the hood never be the problem with <tag> .", "it be that it make data flow hard to follow", "do we re - create this weekness by allow for a seamless <tag> chain through many component down to some nested element in a form", "it feel like we would to i"], "issue_sim": [0.04074708744883537, 0.3683382570743561, 0.27755966782569885, 0.5385492444038391, 0.2598077654838562, 0.0006305351853370667, 0.31837138533592224, 0.004354361444711685], "prob": [0.023780042305588722, 0.32107535004615784, 0.008993343450129032, 0.2212742418050766, 0.04083188995718956, 0.002254370367154479, 0.13015621900558472, 0.0006879221182316542]}, {"target": [1], "doc": ["@linusborg i think you might misunderstand the proposal", "there be no state sync between component , as <tag> be only use on the parent component . check out the example in the  , which  should work in another issue .", "suggest what you 'd like to avoid , with state be maintain in both parent and child , but his use case and proposal be n't relate to this feature request"], "issue_sim": [0.09393279254436493, 0.4552047848701477, 0.257244348526001], "prob": [0.004182151518762112, 0.8767672181129456, 0.6581323146820068]}, {"target": [5], "doc": ["<tag> work differently for component and native element : <url>", "therefore , i guess make <tag> \" smart \" be not trivial", "the input event probably need to be modify manually from the inner component to the outer component <tag>", "in my app , i be wrap a third party component and just add custom style", "i think it should work with <tag> , but i notice that add <tag> be also require", "i think it be a bit weird that a component with a declare <tag> have <tag> in <tag> but do n't have <tag> in <tag> .", "think about it twice , i guess this be because <tag> be automatically add to the accept <tag> due to <tag> , and thus it be not include in <tag>  anymore", "however , <tag> do not exist unless <tag> be specifically declare", "perhaps <tag> could be add to <tag> if it be not manually specify as a prop"], "issue_sim": [0.4196678102016449, 0.08960874378681183, 0.4890572428703308, 0.4858842194080353, 0.4784018397331238, 0.5702641010284424, 0.3918316960334778, 0.1701297014951706, 0.44923314452171326], "prob": [0.0011511262273415923, 0.007463695481419563, 0.06988582015037537, 0.002939544152468443, 0.049494486302137375, 0.11469872295856476, 0.08109869062900543, 0.009217078797519207, 0.02429768815636635]}, {"target": [0], "doc": ["well , if the child properly declare the prop , i would expect to see it in $ prop , not $ attrs , and that be what be happen ."], "issue_sim": [0.22124865651130676], "prob": [0.9999866485595703]}, {"target": [0], "doc": ["i think @frandiox be suggest he be see <tag> _ automatically _ register as a prop on a child component due to the use of <tag> on a parent .", "i have n't notice that behavior personally"], "issue_sim": [0.4042735695838928, 0.1009344682097435], "prob": [0.7178860306739807, 0.03457818552851677]}, {"target": [1], "doc": ["definitely something i want / need", "look like the increase popularity of hoc have make this a necessity ."], "issue_sim": [0.043543193489313126, -0.028516720980405807], "prob": [0.011135472916066647, 0.9292905330657959]}, {"target": [7], "doc": ["so , i finally give this proposal a proper investigation , and it end up be more complicated than it seem", "the problem lie within consistency between different input type", "the current implementation in # <number> assume a text input and ignore non - input event", "while this simplify wrap plain text input field , it make the whole thing inconsistent and feel like a special - case convenience hack", "i manage to make it work with <tag> , which require the component to specify the <tag> option , and then inject the event type and prop type back into the component <tag> handler", "it be already messy than i hope - but even if this work , it become prohibitively complex to mimic the full behavior of native <tag>", "at this point i feel the implementation cost and the inconsistency outweigh the simplification this change would bring", "take a step back , the whole idea of component <tag> be open up fine - grained control over the two - way binding of form input , not simplify it .", "its job be expand the sugar consistently into a pair of input and output , and let you fill in the detail", "mix that up with <tag> and <tag> feel like magic where it do n't belong"], "issue_sim": [0.03831404075026512, 0.04586969316005707, 0.39898568391799927, 0.34268176555633545, 0.6018095016479492, 0.2914625406265259, 0.16177934408187866, 0.47101855278015137, -0.02347496896982193, 0.18142595887184143], "prob": [0.11667169630527496, 0.0015998566523194313, 0.02683689258992672, 0.023061135783791542, 0.14622154831886292, 0.06579654663801193, 0.008236085064709187, 0.08845052868127823, 0.0018197159515693784, 0.001970275305211544]}, {"target": [0], "doc": ["should n't be possible to autorun over the blaze datum and then just affect it to the vue instance  ?"], "issue_sim": [0.4384336471557617], "prob": [0.9999439716339111]}, {"target": [0], "doc": ["oh , just to support non - prop attribute  .", "i would like to fully support what you can do in vue : <tag>"], "issue_sim": [0.09416458010673523, 0.36191195249557495], "prob": [0.6464794278144836, 0.189896821975708]}, {"target": [0], "doc": ["so that user can set attribute without developer of the component know about those .", "i would like to support it in blaze as well , if possible", "but it be not a big deal", "but if vue would have such a function , which would allow programmatically to set  prop and attrs like you can from template language , that would be very easy to do"], "issue_sim": [0.3270305395126343, 0.2691843509674072, -0.035843126475811005, 0.5050499439239502], "prob": [0.44159021973609924, 0.06279019266366959, 0.009633622132241726, 0.7407445311546326]}, {"target": [0], "doc": ["it be generally to use non - vue library , but you will most likely write at least one vue component to wrap it that should expose its feature through prop and event  ."], "issue_sim": [0.5203095078468323], "prob": [0.9999704360961914]}, {"target": [1], "doc": ["i do n't get the fr", "you can already programmatically create vue instance  . share an object as the state  will allow you to reuse the same datum in multiple instance if need .. to trigger function when thing change , use watcher ."], "issue_sim": [-0.03720574453473091, 0.5075129270553589], "prob": [0.005949830636382103, 0.9981104135513306]}, {"target": [0], "doc": ["so how would you programmatically create a component which would be equivalent to <tag> , without know which prop a component be accept , so that all which it be not , become attribute ?"], "issue_sim": [0.49644726514816284], "prob": [0.9996141195297241]}, {"target": [1], "doc": ["this be tricky than it seem", "if you use render function , then you can not modify anymore <tag>  afterwards , because it be not a top - level component anymore ."], "issue_sim": [-0.02750452235341072, 0.5623103976249695], "prob": [0.03890453279018402, 0.9446172118186951]}, {"target": [1], "doc": ["sorry , that comment be a bit rude", "you can modify the prop you pass down .", "i feel like you have n't dig enough your problem but at the same time , to i , it look like you understand more than the average user", "have you ask on the forum or discord to get further help"], "issue_sim": [-0.11997924745082855, 0.20863625407218933, 0.01437750831246376, 0.04907859116792679], "prob": [0.035796716809272766, 0.06963291764259338, 0.4666292667388916, 0.018804192543029785]}, {"target": [0], "doc": ["fyi , you can get the normalize prop metadata of a component via <tag> ...", "you can then group the raw args from blaze into prop and raw attribute base on that metadata", "if i be not mistaken , that should solve the desire use case"], "issue_sim": [0.48346012830734253, 0.49360236525535583, 0.21389034390449524], "prob": [0.639329195022583, 0.04858110845088959, 0.08590154349803925]}, {"target": [0], "doc": ["i do n't think we can support arbitrary array - like object - the line between a actual \" object \" vs. \" array - like \" be blurry .", "we will stick to <tag> in this case", "but we can and should support array subclass", "also - since subclasse array be a es6 + feature , we will likely implement this when we re - implement the reactivity system with proxy"], "issue_sim": [0.5790789127349854, 0.03737371414899826, 0.34966182708740234, 0.3932127058506012], "prob": [0.804454505443573, 0.018245719373226166, 0.023510443046689034, 0.364422470331192]}, {"target": [0], "doc": ["btw , all that seem to be necessary to qualify interpret an object as an array  in v8 seem to be a numerical <tag> and a function in <tag> : <tag>"], "issue_sim": [0.3516623377799988], "prob": [0.9999940395355225]}, {"target": [0], "doc": ["as an alternative we could use iterator protocol which work with way more iterable structure than just array and array - like"], "issue_sim": [0.586639404296875], "prob": [0.9999938011169434]}, {"target": [0], "doc": ["that difference be still there so it will introduce some break change , also the browser compatibility constraint mean we will only do it for v3 ."], "issue_sim": [0.2678956389427185], "prob": [0.999996542930603]}, {"target": [1], "doc": ["offtopic : @yyx990803 ,", "if that be already a plan maybe it be a nice idea to have a v3 discussion issue about possible break / browser compatibility change ?"], "issue_sim": [0.030179288238286972, 0.12559673190116882], "prob": [0.002524235751479864, 0.9723339676856995]}, {"target": [1], "doc": ["@nickmesse currently the only plan change in v3 be the reactivity system and browser compatibility", "the break change would be minimal  and the api will remain the same ."], "issue_sim": [0.22164295613765717, 0.3031321167945862], "prob": [0.06458945572376251, 0.945720374584198]}, {"target": [0], "doc": ["that be not true subclassing - see  for more detail .", "only es6 + support something like <tag>"], "issue_sim": [0.1697029173374176, 0.3241361379623413], "prob": [0.9968152642250061, 0.004952029325067997]}, {"target": [1], "doc": ["iteration protocol do not ensure that iterator can be rewind  , which mean it will break when render function be call again", "also , array - like generally do n't simply read value from memory but do some extra work which should n't be repeat on each render .", "that be say i do n't think you would need to be able to iterate through array - like or custom object directly", "instead , you need array representation of underlying value  , which will always be a native array", "or possibly other build - in iterable , when they be support"], "issue_sim": [0.3619133234024048, 0.41116076707839966, 0.5867984890937805, 0.598510205745697, 0.16724476218223572], "prob": [0.1049027070403099, 0.6885237693786621, 0.08486323803663254, 0.004805265460163355, 0.010923541150987148]}, {"target": [0], "doc": ["i like the idea ... maybe we can simply make normal <tag> accept return a promise ."], "issue_sim": [0.29030662775039673], "prob": [0.9995741248130798]}, {"target": [0], "doc": ["as long as that do n't break exist code , i be all for few keyword / name to remember ."], "issue_sim": [0.17240232229232788], "prob": [0.9998639822006226]}, {"target": [3], "doc": ["@herringtondarkholme very good point", "after think about it , i almost think all these issue you mention would be well solve with rx", "with  the original example can be write as :", "the rx version be obviously more verbose than the simple promise version , but here we get almost everything @herringtondarkholme list : default value , throttling and side - effect subscription", "if fetching be commonly use , with a little helper the above can be far simplify :", "to sum up , i think while the async compute pattern be simple and elegant for the basic use case , it may not be sufficient to deal with the full scale complexity of async operation .", "while we can shoehorn the async compute pattern to deal with these case one by one , at that stage you 'd probably be well off just go with rx", "so unfortunately , i be close this", "note this be not say that this be a bad idea - i think it be still a good idea to let the <tag> library evolve on its own and maybe land on a good balance , but it be probably not the good idea to do that in core"], "issue_sim": [-0.028242524713277817, 0.22721394896507263, 0.060896988958120346, 0.3004131615161896, 0.26957735419273376, 0.4265151023864746, 0.33366382122039795, -0.06685659289360046, 0.23554405570030212], "prob": [0.00474953930824995, 0.19537007808685303, 0.009190455079078674, 0.18966780602931976, 0.00674555404111743, 0.0603962168097496, 0.03810828551650047, 0.0003661954833660275, 0.11689203977584839]}, {"target": [5], "doc": ["please refer to <url>", "we strive to keep api surface small", "<tag> can be implement in user land without hack", "it be n't hard for user to use it in exist project", "i would also argue that a half - bake <tag>", "fully implement it might introduce no simple concept nor small code size for async compute than for rx and its vue binding .", "your use case might be do without async at all", "probably you can store value in another field and define one <tag> property to extract value", "handle async be just set the value in callback"], "issue_sim": [-0.036776140332221985, 0.07247127592563629, 0.19074156880378723, 0.047233037650585175, 0.0664781928062439, 0.4493045508861542, 0.33239883184432983, 0.3028285503387451, 0.41817155480384827], "prob": [0.03886482119560242, 0.08260473608970642, 0.02225833386182785, 0.09746919572353363, 0.014277148991823196, 0.38298073410987854, 0.004598100204020739, 0.4196179211139679, 0.006480971816927195]}, {"target": [8], "doc": ["drive - by impression :", "come over from aurelia and durandal i 've find this to be bizarre", "i expect it to just work", "surely update datum from api response query base on user input be a common use - case for compute property", "would the cache of a compute not be desire in these type of use", "why would you be force to re - roll all these feature from scratch when you have a structure which update base on input   and cache the result until they change again", "see a few suggestion to use a hook once at startup to fill datum", "in contrast to my experience where most use - case for these type of update property be the other way around", "you be often query small set out of much large datum - set which would be impractical to load at startup .", "edit : i realise <tag> exist and probably suit these case too", "find it be angularjs style clunky though"], "issue_sim": [0.0037604719400405884, 0.32730379700660706, 0.009939039126038551, 0.4037367105484009, 0.13439816236495972, 0.2374207079410553, 0.08622466772794724, 0.3019125461578369, 0.16800202429294586, 0.025402406230568886, 0.3167582154273987], "prob": [0.0015861019492149353, 0.12299427390098572, 0.002455588895827532, 0.0011434024199843407, 0.008463201113045216, 0.5593352913856506, 0.0017534784274175763, 0.0037990740966051817, 0.05435684695839882, 0.00041828045505099, 0.0004038248735014349]}, {"target": [6], "doc": ["+1 for a native solution", "even if a promise - base implementation of throttle event make sense in particular scenario , imho it be tangential to the main use case here", "it would be sufficient to add a minimal core implementation that let you asynchronously fetch datum with the absolute minimum amount of boilerplate - then see what other clever and unexpected  use people put it to", "can you provide a scenario where this be necessary - as oppose to normal vue - agnostic use of promise", "<tag> seem a good way of do this without expand the api surface", "default value + callback on resolve be good enough for the core minimal use case", "overall vue - async - compute be a step in the right direction , and core support for this would be a major step forward , see how promise and async / await be now a core part of our language workflow"], "issue_sim": [0.19697491824626923, 0.37860625982284546, 0.4470273554325104, 0.21321818232536316, 0.18406111001968384, 0.37229621410369873, 0.41008564829826355], "prob": [1.69329832715448e-05, 0.08539947122335434, 0.7317289710044861, 0.00550819793716073, 0.0005118133849464357, 0.0004100673831999302, 0.6383500099182129]}, {"target": [1], "doc": ["i 've run into this as well", "i feel like the default should be use if a prop be not define ."], "issue_sim": [-0.03320494666695595, 0.4752674698829651], "prob": [0.10878069698810577, 0.9294987320899963]}, {"target": [0], "doc": ["what if you want to explicitly set the value to undefined ?"], "issue_sim": [0.42704471945762634], "prob": [0.9999927282333374]}, {"target": [0], "doc": ["you may have a component that be show up yet be wait for some async resource to be available .", "although null could be use too but this may be tricky for some user"], "issue_sim": [0.33308500051498413, 0.25978899002075195], "prob": [0.8841350674629211, 0.0019070670241490006]}, {"target": [2], "doc": ["the semantic of <tag> be for provide a value when the prop be absent", "this be different from provide a value , but with a value of <tag>", "as @posva mention , this could lead to unexpected result for some user , and be also a break change , which in general we should try to avoid if there be no strong benefit in do so .", "i think the use case can be cover by the suggest <tag> option though : <url>"], "issue_sim": [0.36993253231048584, 0.2771756649017334, 0.2920113801956177, 0.221012145280838], "prob": [0.13916513323783875, 0.10365007072687149, 0.5642333626747131, 0.013444127514958382]}, {"target": [5], "doc": ["i think this be debatable", "in javascript , the sole purpose of <tag> be precisely this case : explicitely say that no value have be affect", "this be the sole definition of <tag> value in the ecma specification : <url>", "it should n't be interpret as a value but as the absence of value", "this be also why <tag> will dump <tag> key but not<tag> one", "so , in my opinion , when <tag> be set as property anywhere , it should be interpret as \" no value be assign \" and in the case of vue property , it should trigger default ."], "issue_sim": [0.03323061019182205, 0.4473935067653656, 0.21262872219085693, 0.22231443226337433, 0.0970163643360138, 0.6630167365074158], "prob": [0.003779104445129633, 0.07602370530366898, 0.009367415681481361, 0.005840408615767956, 0.006518006324768066, 0.7404560446739197]}, {"target": [1], "doc": ["this be debatable exactly because some user feel the other way", "and the point be that this * * will be a break change * * , so i prefer to leave it in current state unless everyone agree it should be change ."], "issue_sim": [-0.003148086369037628, 0.23608490824699402], "prob": [0.30852431058883667, 0.7411447763442993]}, {"target": [5], "doc": ["where be we at with this decision", "in my opinion it be embed in the nature of javascript for a schema to use the default value of the property if the property be pass as undefined", "actually it be n't embed but that be how mongoose schema definition do it and it be logical in my opinion", "how else do you make a < component v - for=\"item in item \" : item=\"item \" > < /component >", "with a default item value resort to the default when you want to add a new item to item , and do so by push an undefined value into the item list", "so that the component take care of the default value , because you should n't have to put any component logic into the parent , be i right .", "what workaround be there for my use case to ensure that : item be only pass if it be not undefined", "so i can get the default value work", "thank you kindly vue team"], "issue_sim": [0.04116520285606384, 0.5954195261001587, 0.25824302434921265, 0.4582101106643677, 0.3614448606967926, 0.55146324634552, 0.45778656005859375, 0.23322582244873047, -0.07069391757249832], "prob": [0.001902743591926992, 0.17046301066875458, 0.03442796319723129, 0.005258582066744566, 0.019240256398916245, 0.22057953476905823, 0.0018082506721839309, 0.0009531515534035861, 8.514685032423586e-05]}, {"target": [0], "doc": ["i think <tag> be well because all of component 's option  be json .", "if it be <tag> , there should be change to json again maybe"], "issue_sim": [0.3341975212097168, 0.24261917173862457], "prob": [0.6272980570793152, 0.1736755222082138]}, {"target": [1], "doc": ["in this case wee represent an object as a string , which be what tostring be make for", "i believe json.stringify be only use to make pretty output or object and array when they have no nice tostring format .", "we might get around this by check if the object tostring method be the last in the prototype chain", "this way we can use tostring if we add it to the prototype ourselves"], "issue_sim": [0.399654746055603, 0.3189740478992462, 0.45285654067993164, 0.3432592451572418], "prob": [0.028437834233045578, 0.8594635128974915, 0.016287900507450104, 0.0033257007598876953]}, {"target": [1], "doc": ["@mathieutu look good , but what about use something like :", "it check if the <tag> method have be overwrite without compare value . i think this would be well for performance ."], "issue_sim": [0.17081652581691742, 0.4233659505844116], "prob": [0.028810206800699234, 0.8902536034584045]}, {"target": [0], "doc": ["i do n't know where we stand on this request  , but js make an extensive use of coercion , and when need a string it call for <tag> as in <tag>", "i think this be the proper way to go , just ask for a coercion with <tag> while render"], "issue_sim": [0.47138139605522156, 0.3560020923614502], "prob": [0.9479307532310486, 0.01505754329264164]}, {"target": [0], "doc": ["i like that idea , since <tag>/<tag> be get more common that would probably be a nice thing to have ."], "issue_sim": [0.028975557535886765], "prob": [0.9997883439064026]}, {"target": [2], "doc": ["this feature would be a great add", "here be another example of how it currently work :", "as a workaround , you can catch the error in a try / catch block .", "but i could n't find a way to trigger an error on the vue instance", "i think maybe the convention of emit an <tag> event might work", "i think that or something similar could be helpful"], "issue_sim": [0.05478938668966293, 0.023290487006306648, 0.46424365043640137, 0.3401764929294586, 0.2643529772758484, 0.014354541897773743], "prob": [0.018294062465429306, 0.0034361036960035563, 0.22475166618824005, 0.08798782527446747, 0.13445590436458588, 0.001309399725869298]}, {"target": [0], "doc": ["i always do <tag> in case i need array and it be not obvious if variable be array or not ."], "issue_sim": [0.3641451299190521], "prob": [0.9999901056289673]}, {"target": [0], "doc": ["as say in the pr , you should use plain object instead of <tag> for mixin :", "you can achieve something similar with <tag> too :"], "issue_sim": [0.28475677967071533, 0.022125985473394394], "prob": [0.7213584184646606, 0.05927237868309021]}, {"target": [0], "doc": ["ideally , the mixin should not be a component , otherwise , you can extend they with <tag> but you loose the ability to extend multiple thing at the same time"], "issue_sim": [0.2768716812133789], "prob": [0.9998694658279419]}, {"target": [0], "doc": ["i think wrap <tag> be need since it simply use <tag> on merge mixin .", "afaik , most of vue component decorator be use <tag>"], "issue_sim": [0.3810923099517822, 0.2564000189304352], "prob": [0.7698351740837097, 0.10992138087749481]}, {"target": [0], "doc": ["there may be some other factor go on here , i 've create an example that use <tag> inside a vue - router and it work in chrome  and not firefox  .", "error in firefox :", "this be actually the issue that i be have and i trace it to the code that my pr be for , however i do not see what would cause the difference between browser", "a different decorator would be a possibility , however may not be require if this issue be resolve"], "issue_sim": [0.21614202857017517, 0.22737950086593628, 0.2423636019229889, 0.2565002739429474], "prob": [0.4292397201061249, 7.474742596969008e-05, 0.34681782126426697, 0.0022772091906517744]}, {"target": [2], "doc": ["i be not sure if <tag> be the right solution for your problem , maybe you can provide a jsfiddle to well illustrate what you be try to achieve", "vue do n't have <tag> exactly because vue do n't need it", "vue 's reactivity system ensure only the right component get re - render when state change .", "think of it as react with <tag> already implement for you"], "issue_sim": [0.2854452431201935, 0.26790738105773926, 0.5250130891799927, 0.25909245014190674], "prob": [0.17503292858600616, 0.001480687758885324, 0.8374800682067871, 0.005871220957487822]}, {"target": [13], "doc": ["@yyx990803 thank for the reply ,", "i have put together a", "it contain two component", "the first show that the contenteditable updating with no caret jump", "this be because there be no html change to the state , and so vue do not re - render the component", "the second contenteditable component contain html , and when editing display the behavior i describe above", "the dom refresh and the caret jump to the beginning", "you be right that vue be correctly determine which component to re - render", "it be re - render the contenteditable div when the state change", "however in my use case i need an option to stop that automate behavior", "i would like the state to continue update , but for the component to wait to re - render until i want it to refresh", "this be where a <tag> hook would be useful", "i like that vue automate the rendering of the correct component , but i believe it make sense to have an option to circumvent that behavior if desire", "i believe expose such an option / hook would open vue up to the use of contenteditable , provide potential for performance boost , and solve my headache :)"], "issue_sim": [-0.015864143148064613, -0.06680240482091904, 0.1294875144958496, 0.384578675031662, 0.4925026595592499, 0.5457343459129333, 0.4588528871536255, 0.3357880711555481, 0.5264043807983398, 0.2281043827533722, 0.5542474985122681, 0.19803862273693085, 0.5996664762496948, 0.4103344678878784], "prob": [2.4570266759837978e-05, 1.83427837328054e-05, 0.00026474701007828116, 8.399150829063728e-05, 0.002382845850661397, 0.0019403952173888683, 0.0006900911685079336, 0.0006261463277041912, 0.0012927297502756119, 7.222148269647732e-05, 0.6188756823539734, 0.012817651964724064, 0.3344043493270874, 0.19947010278701782]}, {"target": [2], "doc": ["hi ,  might be helpful here", "if you still need more fine grained control over rendition , one more computed getter might be helpful", "for general case , compute property that get selectively update might be enough for implement <tag> .", "the only case i can conceive need <tag> be you have so many interlaced state change that manually implement compute be cumbersome", "but i wonder if such case be common"], "issue_sim": [0.03326961398124695, 0.32484763860702515, 0.3786250054836273, 0.27039045095443726, 0.022783737629652023], "prob": [0.0007553139585070312, 0.012748404406011105, 0.2845071852207184, 0.21944208443164825, 5.2309289458207786e-05]}, {"target": [6], "doc": ["@herringtondarkholme thank for the direction", "you be correct , <tag> do indeed resolve this issue for my use case", "the original jsfiddle you update do not work correctly because it be use old version of vue and vuex", "i have create another  with vue and vuex 2", "0 which demonstrate the update functionality", "your suggestion of a compute property make sense to i if i intend to display the content separately through the template , however that part of the jsfiddle be just for example purpose", "i still believe a <tag> option would be necessary for a contenteditable component that also act as the display .", "basically for anything that act as a \" text editor \"", "your <tag> solution work as long as i be ok with not re - render the component , however i could see use case where one might wish to re - render a component   <tag> or <tag>", "i be currently work on add a watcher to trigger component re - render <tag> , but have not have success", "i would still be interested in see a <tag> hook , or on a more macro scale , an option to end the lifecycle at any point without cause error"], "issue_sim": [0.01991420052945614, 0.20649777352809906, 0.4110909700393677, 0.14735782146453857, 0.060980964452028275, 0.35801130533218384, 0.5796890258789062, 0.17883585393428802, 0.5343533754348755, 0.5025556683540344, 0.35595399141311646], "prob": [0.007010920438915491, 0.043034426867961884, 0.037493761628866196, 0.0006171579007059336, 0.000598217302467674, 0.16171228885650635, 0.01748836226761341, 0.0006831053760834038, 0.05986150726675987, 0.006560185924172401, 0.062006875872612]}, {"target": [2], "doc": ["after look at your use case , i still do n't think <tag> be the correct answer to it", "what you want be essentially a way to let you explicit make the view and the state out of sync ,  and <tag> be primarily offer for performance optimization .", "the fully framework - compliant way to deal with it  be to have a separate piece of state that represent the input content , which can then be out of sync with the model state and can be update only when you want to"], "issue_sim": [0.2285059541463852, 0.27754437923431396, 0.44582533836364746], "prob": [0.10118511319160461, 0.5879741907119751, 0.502147376537323]}, {"target": [4], "doc": ["i just find a case which <tag> may make sense", "you can see the dev console", "every time you click on a tab , all other tab will re - render because they depend on <tag>", "they think they need to re - render , but in fact they do n't", "so in this case , even all the prop be the same , the component will still update itself .", "if we want to optimize the performance , <tag> or a react - like <tag> may be helpful"], "issue_sim": [0.04441859573125839, 0.08120665699243546, 0.21700367331504822, 0.14347931742668152, 0.43657636642456055, 0.36395227909088135], "prob": [0.02337067760527134, 0.013036981225013733, 0.47885623574256897, 0.02540111541748047, 0.17453521490097046, 0.047307711094617844]}, {"target": [1], "doc": ["@codincat in this case the tab be force to update because they have slot child", "technically , this mean if you implement a <tag> for your tab that solely depend on the <tag> prop , it will be incorrect because the slot child may have change and be not account for .", "it can lead to subtle bug when the slot content of your tab component change", "in react , if you use a pure component for this purpose , it will also always re - render because the <tag> prop always get new reactelement reference , so a shallow compare will consider they different", "of course , you * can * try to diff the child nod in a custom <tag> , but it be unlikely to be correct for all edge case - plus at that point it be not much different from just re - render the contain component"], "issue_sim": [0.3518494665622711, 0.27816611528396606, 0.4010264277458191, 0.484963983297348, 0.3400042653083801], "prob": [0.0005666260258294642, 0.6688970923423767, 0.01024180743843317, 0.06838325411081314, 0.10879426449537277]}, {"target": [0], "doc": ["shouldcomponentupdate might be add only to render functions & jsx section ."], "issue_sim": [0.4642036557197571], "prob": [0.9996293783187866]}, {"target": [5], "doc": ["i agree with you @jeff - hykin", "one do n't want to implement a <tag> solution", "but i think @sirlancelot 's post be suggest a workaround for a specific problem that <tag> solve", "in react , whenever state change , it trigger an update -- similar to <tag>", "and the same happen   with a <tag> update", "so in react , the assumption be the same as in vue : that when <tag> or <tag> update , the component re - render", "the question be whether or not your component can bail out of an update", "<tag> allow you to bail out base on the <tag> or <tag>", "now , throttling component update be great  , and so be render once and only once  , but what if i want to to render twice , for example", "these be the sort of totally unforeseeable  arbitrary need that compute bailout of re - render solve", "<tag> be a power tool that allow fine - grain control over component performance by allow the component to bail out of re - render base on arbitrary , compute criterion .", "and while i certainly have a lot to learn about vue and could be wrong , it seem a problem to i that it lack this kind of power tool"], "issue_sim": [-0.02173493057489395, 0.07736440747976303, 0.11995504796504974, 0.5768687725067139, 0.13922390341758728, 0.6141716241836548, 0.30251044034957886, 0.06738025695085526, 0.5149931907653809, 0.07201875746250153, 0.3084923028945923, 0.05211726576089859], "prob": [0.0017571259522810578, 0.003870920743793249, 0.0007410175167024136, 0.004033039323985577, 0.0015192152932286263, 0.12757901847362518, 0.0017825698014348745, 0.007530098780989647, 0.11473064124584198, 0.0056986575946211815, 0.10212511569261551, 0.1328110247850418]}, {"target": [0], "doc": ["yeah this kind of namespace - ing would be really beneficial and result in clean code .", "example from a personal project :", "at the moment all ui describe variable live in", "yet ui manipulator just live in <tag> and be prefix <tag> which make , imo , some , in fact consistent , yet typo prone code e"], "issue_sim": [0.333644837141037, -0.05787676200270653, 0.08955036103725433, 0.3786606192588806], "prob": [0.9819988012313843, 0.0003296246286481619, 6.131461850600317e-05, 0.5574469566345215]}, {"target": [2], "doc": ["i do n't see the point other than style preference", "what make it different from , say <tag> and <tag>", "if these method on be invoke on the instance then they should n't be nest ."], "issue_sim": [0.06118699163198471, 0.1927318423986435, 0.4065547585487366], "prob": [0.06835006922483444, 0.2750495970249176, 0.5829665660858154]}, {"target": [2], "doc": ["they be mainly for style preference , yes", "but i do have a another use case for it", "it be very convenient to pass a group of method to a child component .", "12 , i have a validation component use to show server - side validation error", "it use a component in conjunction with a mixin", "here be a water - down   version of it :", "* * component * * :", "inherit : true ,", "<tag> <tag> <tag> js", "return { servervalidation : { } }", "if  ) return true ;", "if  ) return null ;", "validationerrors || { } ;", "<tag> <tag> <tag> js", "in short , i have a component and a mixin that work hand in hand", "12 support <tag> , the component be able to utilize the validation method directly from the parent component", "fast forward to 1", "0 , and <tag> be no more", "i 'll now have to pass all those method down directly into the child component", "pass they all separately  would severely clutter up the template , so i think group they all in a single object and only pass that in would make more sense", "i might be approach this all wrong , and i 'll be happy to hear of an alternate solution", "regardless , i still think allow method to be group be a good idea"], "issue_sim": [0.11084210872650146, 0.10866547375917435, 0.3189735412597656, 0.3013659119606018, 0.22394566237926483, 0.15209683775901794, -0.039273232221603394, 0.18066903948783875, 0.375652015209198, 0.09380202740430832, 0.17467087507247925, 0.1733020842075348, 0.10374417901039124, 0.375652015209198, 0.08435700833797455, 0.29888463020324707, 0.02044159173965454, -0.07408186048269272, 0.29769375920295715, 0.3082960247993469, 0.1758633852005005, 0.24271813035011292], "prob": [0.009141489863395691, 0.017277443781495094, 0.21564742922782898, 0.0031690536998212337, 0.0006918217404745519, 0.009579958394169807, 0.0012601367197930813, 0.000989175634458661, 0.0011411079904064536, 0.0004971670568920672, 0.00043263702536933124, 0.0006573548307642341, 0.0019209067104384303, 0.0012876695254817605, 0.025275589898228645, 0.02298831380903721, 0.00226387451402843, 0.001267521409317851, 0.0018789204768836498, 0.10226825624704361, 0.006882078945636749, 0.011419190093874931]}, {"target": [2], "doc": ["i still hold the opinion that nest method be more confuse than useful", "the preferred way of connect a child and a parent method be now do so via <tag>", "if the parent and child be so tightly couple that you be use <tag> , then it be effectively the same as directly call <tag> ."], "issue_sim": [0.22238005697727203, 0.32741761207580566, 0.2891019582748413], "prob": [0.4433061182498932, 0.006529618985950947, 0.6277997493743896]}, {"target": [0], "doc": ["nested method would be useful in give mixin method their own namespace ."], "issue_sim": [0.42840468883514404], "prob": [0.9999845027923584]}, {"target": [4], "doc": ["if you be not re - set data object as plain json which will kill off their prototype ,   you could create instantiate   class base object with root / nest object method since prototype method / getter / setter be not proxie by vue , but still accessible via the $ datum  itself", "only problem be you do n't get compute cache unless you manually import those nest getter into an optionally namespace flat vue <tag> structure in order to manually proxy into they", "i have a custom haxevx compile - time macro that do this , but haxevx be n't vanilla vue", "nested accessor for vue typically would have to exist in nest   vue component or vuex module rather than object - orient nest accessor , else set up flatten \" object__propertyname \" proxy access to they", "however ,   i think use non compute nest   access of object   method be n't much of a problem for this case though , as long as you do n't reset yr datum as plain json and you do n't need cache ."], "issue_sim": [0.48219215869903564, 0.42213141918182373, 0.3011256456375122, 0.3736358880996704, 0.3457960784435272], "prob": [0.4638274908065796, 0.18771156668663025, 0.026294110342860222, 0.3836594820022583, 0.08293213695287704]}, {"target": [1], "doc": ["i 'd also like to advocate that this be implement", "use object to namespace and group function be much more convenient than prefix .", "not only be it clean , but it also allow for ide to fold the method as well", "as a workaround for now , this can be accomplish by use function instead of object :", "and then these can be use like <tag>", "not perfect , but it still give the organizational benefit", "@yyx990803 it be be a couple year , have your opinion change at all"], "issue_sim": [0.19985713064670563, 0.37182751297950745, 0.23424498736858368, 0.5666856169700623, 0.17599284648895264, 0.07834364473819733, 0.09407610446214676], "prob": [0.00924641266465187, 0.8703629970550537, 0.532676637172699, 0.06819899380207062, 0.0007455407758243382, 0.016429921612143517, 0.002294498262926936]}, {"target": [3], "doc": ["i think that add this overload to vuejs be more reasonable than try to get this add as a config option to the typescript compiler", "that be especially true since react , inferno , and other all use the variardic signature", "that is , * *", "vuejs be the outlier for jsx * * and they would have to add a library specific option to a language compiler .", "i think this should amount to three to five line of code and a small documentation change"], "issue_sim": [0.5325525999069214, 0.07239460945129395, -0.027153434231877327, 0.40822333097457886, 0.17232680320739746], "prob": [0.6787310242652893, 0.02812042646110058, 0.0010482857469469309, 0.27519717812538147, 0.010419396683573723]}, {"target": [2], "doc": ["i understand that but , even if right now vue be different from react in term of render fn args , that may not be the case in the future : other lib  have or will adapt the array syntax instead of the variadic one as it make more sense and be simple to use", "there be also other vdom engine that use the array syntax instead : <url> , <url>", "to put it in a nutshell , now that we can , we should keep the array syntax because it be well and we should throw away the variadic syntax .", "this will prevent the whole js community to keep that old bad syntax as a backwards compatibility", "javascript be already hold a lot of that , so i think it be well not to add that as well to lib while we can"], "issue_sim": [0.477092981338501, 0.22700998187065125, 0.25720226764678955, 0.2637391686439514, 0.27206888794898987], "prob": [0.6527537703514099, 0.006717420183122158, 0.40891072154045105, 0.00028777084662579, 0.010793059132993221]}, {"target": [2], "doc": ["what be the argument against variardic", "other than be ugly , i do n't know of any issue use that syntax , whereas array style i know would take a hit in garbage collection after repeat call", "that is , create an array every time render be call would have an adverse  effect on performance in a very large application .", "i be try to understand your position well , since i be suggest add an additional signature , not replace the exist behavior"], "issue_sim": [0.04721178114414215, 0.260206937789917, 0.2866041660308838, 0.2793680727481842], "prob": [0.00014150398783385754, 0.5912318229675293, 0.48915719985961914, 0.07878171652555466]}, {"target": [3], "doc": ["i 'd love to see some number on that", "what i be try to do be to understand what be well , and the array syntax be simple and more straightforward because of <number> args vs n args", "my idea be that we should try to push only one syntax forward and adapt onto that one", "keep backwards compatibility with the other one be up to the lib use it , but i think it should be avoid as much as possible because js be full of backward compatibility thing"], "issue_sim": [0.028824681416153908, 0.2765989303588867, 0.20633208751678467, 0.31786930561065674], "prob": [0.00972757674753666, 0.30950412154197693, 0.01144749391824007, 0.5620754361152649]}, {"target": [1], "doc": ["no , i do n't say that , sorry if it look like it", "it be because the array syntax be well that we should deprecate the other one and use the array one everywhere .", "about other library , i simply google virtual dom github and all lib i look from top result have the array syntax"], "issue_sim": [0.09347867965698242, 0.1895686835050583, 0.26322948932647705], "prob": [0.03531794250011444, 0.584701657295227, 0.289032906293869]}, {"target": [0], "doc": ["the 2nd argument differ from one impl to another , but the first be always the tag while the 3rd be an array of child"], "issue_sim": [0.3066398501396179], "prob": [0.9999432563781738]}, {"target": [0], "doc": ["i think it would be well if typescript + vuejs could work together directly , but i be currently happy with use the babel jsx plugin and the vue - class - component package .", "it do seem like a lot of toolchain for the job , but it appear to work with no issue", "i 've put together a starter project for single file component with those package : <url>"], "issue_sim": [0.580560564994812, 0.19003897905349731, 0.1865190714597702], "prob": [0.8189244866371155, 0.09315299987792969, 0.08461783826351166]}, {"target": [0], "doc": ["regardless of the size the directive  , anything to do more code - splitting would be nice ."], "issue_sim": [0.5097216963768005], "prob": [0.9999725818634033]}, {"target": [0], "doc": ["i need this too~~~~register async directive"], "issue_sim": [0.5416602492332458], "prob": [0.9995442032814026]}, {"target": [2], "doc": ["this feature request have be open for quite some time now , and have n't get much traction so far", "i also have n't come across a wish for this functionality in other place  so i be not sure if there be a large enough use case for this", "in my personal experience , directive tend to be rather small ever since their functionality and scope be reduce in vue 2.0 .", "i therefore tend to close this request , but we can re - open if enough people express a need for this"], "issue_sim": [0.10865417122840881, 0.18285568058490753, 0.5186291933059692, 0.13327905535697937], "prob": [0.178574338555336, 0.5582677721977234, 0.15489713847637177, 0.05729977414011955]}, {"target": [1], "doc": ["i think this need to be re - open", "especially since pwa 's be the future and incremental load of your code be a must ."], "issue_sim": [0.03518323600292206, 0.13683664798736572], "prob": [0.006769751198589802, 0.997157096862793]}, {"target": [3], "doc": ["that sound nice and catchy", "but i still have n't see any important usecase for directive that be so big that they codesplitte they into their own chunk would be useful", "they be surely not mean to be that big", "if you have big * dependency * that you import inside of your deirective , those could of course be codesplit with <tag> quite easily today .", "so i do n't see a reason for add code to the codebase for something nobody provide an acutal usecase for", "\" it would be nice \" it not a good enough reason"], "issue_sim": [0.06894122809171677, 0.4594417214393616, 0.01653841882944107, 0.272400438785553, 0.35379788279533386, 0.06899675726890564], "prob": [0.0030342857353389263, 0.38014525175094604, 0.007322334684431553, 0.29901012778282166, 0.010245177894830704, 0.00017710027168504894]}, {"target": [2], "doc": ["it be not that the directive be so big", "it be that their definition will be include in the app chunk along with kotlin which be load after the shell", "while the directive declaration will be in the shell chunk because that be where the vue instance be instantiate", "so the declaration and definition will be in two different chunk", "the shell will be download quickly , show the basic ui and a spinner or two , then when the rest of the app be load the spinner disappear and show the content as well as the rest of the ui that make the app fully functional", "in the shell chunk i be able to asynchronously load the vuecomponents define in the app chunk by create a communication layer between the two chunk and follow the instruction for asynchronous components here : <url>", "i already have that work with components", "what i be look for be the same type of asynchronous load for directive so that i can include they in my app chunk , which be the only place they will be use anyway .", "i actually may have think of a solution already since directive do n't need a render function", "i 'll be test it out today but it would be nice if vue have a build in way of do", "and if my idea do n't work then i feel that vue definitely need a build in way of do it", "so my idea do work", "i create a plain empty js object in the shell , pass it to the directive definition  which be also in the shell , then pass it to my communicator that communicate between the shell and app chunk", "when the app chunk finish load it create its own directive definition and pass it to the communicator", "the communicator match the two up base on the directive name and concatenate the directive definition object in the app chunk on the empty object from the shell chunk , which have already be register use vue", "directive in the shell", "and there we go , asynchronous directive definition load", "everything work as it should", "here be my github repo where i have it work : <url>"], "issue_sim": [0.2479386031627655, 0.32734695076942444, 0.4186539649963379, 0.14708535373210907, 0.28417664766311646, 0.4358668625354767, 0.31476539373397827, 0.5444398522377014, 0.5302571058273315, 0.15005265176296234, 0.14160998165607452, -0.029347099363803864, 0.46846815943717957, 0.45174628496170044, 0.4409513473510742, 0.35618463158607483, 0.39660513401031494, 0.0023429025895893574, 0.05622833967208862], "prob": [0.002720219548791647, 0.049069683998823166, 0.08999308943748474, 0.026823218911886215, 0.09585241228342056, 0.0576644167304039, 5.147730189491995e-05, 0.0535145103931427, 0.004404454026371241, 0.0015899345744401217, 0.0017916876822710037, 2.037428566836752e-05, 0.02616387978196144, 0.0019815745763480663, 0.021194713190197945, 1.2576488188642543e-05, 0.0004702274745795876, 8.127637556754053e-05, 0.0016240162076428533]}, {"target": [0], "doc": ["i think async directive can be useful when you be build very small spa , where time to interactive be very important .", "for example , i make order form not long ago", "in my case source code size in parsed state be about <number> kb", "and i use v - tooltip library for show tooltip", "this library give you an opportunity to add ' v - tooltip ' directive", "so as you can see the library take almost same size as my source code", "it would be great if i could make it as separate chunk and load asynchronously", "but since vue do n't support async load of directive i ca n't do that", "i be sure that i could find more lightweight alternative for the library", "but it be not cancel that sometimes you need to place directive in separate chunk"], "issue_sim": [0.60389244556427, 0.14716824889183044, 0.21817827224731445, 0.2399008870124817, 0.3600049614906311, 0.18042097985744476, 0.43108484148979187, 0.4309564232826233, 0.08262242376804352, 0.4106406569480896], "prob": [0.38038748502731323, 0.02377450466156006, 0.012750803492963314, 0.006088078022003174, 0.01639953814446926, 0.04915933683514595, 0.014719627797603607, 0.012611813843250275, 0.00507280882447958, 0.10683604329824448]}, {"target": [1], "doc": ["first of all , i really do n't think introduce a parallel composition mechanism be the way to solve this problem", "in particular , when this be use in conjunction with slot it could lead to a lot of confusion .", "your solution  , i", "a structural component that expose the outline + slot , be imo the proper abstraction for the problem - i 'd like to see an actual example where it become obtrusive as you suggest", "finally , template compilation for functional component , once support , can probably alleviate this problem to some extent"], "issue_sim": [0.15317857265472412, 0.16773110628128052, -0.0002775341272354126, 0.4794977903366089, 0.5247601270675659], "prob": [0.297798216342926, 0.14595918357372284, 0.0001615401852177456, 0.7184028625488281, 0.006131188478320837]}, {"target": [1], "doc": ["tldr : an example where structural component be verbose to proxy", "i agree that a new block inheritance will cause much confusion and that structural component should be the solution for this .", "but i also have sympathy with @simplesmiler for extend component , namely the point <number> in op 's issue", "i have a realistic example at hand", "i do n't know much about functional component with template , so i wo n't include it in this example", "consider a generic map component , say google map clone", "* it accept * * many prop :* * width , height , zoom level , lat / lng ,", "* it emit * * many event * * : onzoomin , onzoomout , onpinclicked , onmapmoved ,", "* it expose * * many slot * * : a header , a zoom control , a view type control  , some pin on map , a popup  , a legend", "the map component be very powerful", "arguably it be so powerful as to be a god component , but these feature be cohesive enough to be organize into one component", "so i choose to implement the map by structural component with default slot , rather than other method in op issue like split into small / representational component", "then user will have to proxy all the prop / event / slot", "for example , this be an imaginary implementation for component <tag>", "now , we want to create another generic map component , but for vip user : the only difference be that pin on vip map will have shiny border and filament", "it be quite verbose to proxy all event / slot", "proxying slot be error - prone , maybe due to the same name of original slot and new proxy slot", "we already have <tag> to reduce the verbosity of proxying prop , but it seem we can not concisely proxy event or slot in template", "indeed , we can sidestep tedious work by use render function and jsx", "but it go to op 's point <number> : mix template and render function be hard for understand"], "issue_sim": [0.3732934594154358, 0.44151532649993896, 0.23585858941078186, -0.0039648814126849174, 0.4370654225349426, 0.2842954993247986, 0.13703152537345886, 0.030505148693919182, 0.20504291355609894, 0.2784568965435028, 0.4158500134944916, 0.4911067485809326, 0.19227585196495056, 0.22562560439109802, 0.2860412299633026, 0.2071046531200409, 0.23970597982406616, 0.49321460723876953, 0.41538006067276, 0.3366398215293884], "prob": [0.030477307736873627, 0.3917654752731323, 7.593761256430298e-05, 2.3425993276759982e-05, 0.002426132559776306, 0.00014665017079096287, 0.0014091662596911192, 5.4159259889274836e-05, 0.013540515676140785, 5.66756125408574e-06, 0.004449119325727224, 0.0022068643011152744, 0.00011162637383677065, 8.4871549915988e-05, 0.015563253313302994, 2.5220870156772435e-05, 0.00016894712462089956, 0.01744253560900688, 0.0007363965851254761, 0.00038365586078725755]}, {"target": [0], "doc": ["with  component tend to become so granular that they end up be a div with a class , thus make the abstraction so thin that it might as well not even be there .", "that be what i mean by \" obstructiveness \"", "i would have like to avoid large example , but that would defeat the purpose , so please bear with i", "say you need to develop a panel component that would encapsulate the look of panel in the app", "generic panel have a title in the header and slot for content", "but panel may have a lot of variation :", "some panel need subtitle along with the title , some need an icon before or after the title , some need action button or other widget align to the opposite side of the title", "some panel need their header shade with color , some need header the same color as body", "some panel need their content to be pad  , some panel need their content to be flush with the panel border", "to accommodate for this variation you decide to go with granular appearance component", "your panel when use , start to look like this :", "all be good so far", "then you recognize , that among all the possible variation there be common use case", "so you decide to write component for these common use case to avoid code duplication", "this way you end up with <tag> , <tag> , <tag> , etc", "and this be where thing start to go a little bit south", "if you want to write a specialized panel that behave exactly like an exist one , but have some altered behavior / interface  then either :", "you need to put this variation into the parent component", "you need to redefine the child template completely , because there be no way to reuse parent template", "of course you could define component that encapsulate common variation of part of the panel", "but at this point you will already have three level of abstraction", "and every level require you to proxy prop , slot and event"], "issue_sim": [0.47497713565826416, -0.013313662260770798, 0.11435312032699585, 0.3728170394897461, 0.2316591739654541, 0.04230818152427673, 0.18372535705566406, 0.20730239152908325, 0.1494763195514679, 0.3204341530799866, 0.15923021733760834, -0.030952177941799164, 0.06641089916229248, 0.41855135560035706, 0.15778860449790955, -0.09757177531719208, 0.269382506608963, 0.3965303301811218, 0.5814615488052368, 0.43607574701309204, 0.15135617554187775, 0.180008202791214], "prob": [0.8180791139602661, 0.017268087714910507, 0.05571264773607254, 0.0027687931433320045, 0.00189427868463099, 0.001112976111471653, 0.14757834374904633, 0.0027624170761555433, 0.002390027977526188, 9.905279148370028e-05, 0.00012593940482474864, 1.6354661056539044e-05, 0.0003441824810579419, 9.162040805676952e-05, 0.0045006657019257545, 1.5681951481383294e-05, 0.031893063336610794, 2.5761506549315527e-05, 0.00042065823799930513, 0.0008027873700484633, 0.00021864435984753072, 0.012298437766730785]}, {"target": [6], "doc": ["i be also interested in this", "in my specific case , i do n't have very granular component , however several ' page ' where i need different ' layout '", "currently , i be solve this use _ appearance - only _ component , as op state it", "i have a <tag> which import further stuff like <tag> etc", "as well as a <tag> which have nothing but a <tag> as it be template", "composition be do with child component inside the _ vue - router _ configuration", "this ' top - down ' approach have a major drawback though : it result in a god object  which define the entire composition of the application , instead as have modular component which could inherit certain aspect of their parent  ."], "issue_sim": [-0.009275749325752258, 0.38506150245666504, 0.3313055634498596, 0.1721503883600235, 0.2993451952934265, 0.5038329362869263, 0.4976954460144043], "prob": [0.002070634625852108, 0.6844470500946045, 0.04185405373573303, 0.01101794932037592, 0.04032984375953674, 0.044114261865615845, 0.6168310046195984]}, {"target": [0], "doc": ["i still feel that have an extra composition model greatly muddle the structure of the program and only make the mental model more complex then it should be .", "although the propose solution may make certain use case a bit more manageable , i be not really convinced of the tradeoff"], "issue_sim": [0.2927398085594177, 0.29634761810302734], "prob": [0.7653355002403259, 0.3660464286804199]}, {"target": [0], "doc": ["i think that without such a mechanism , component composition via inheritance be inherently break , since it allow no affordance dry up your template .", "the fact that people be use the pug template language workaround be proof enough of this , imo", "the downside , of course , be that it introduce another dependency , and a whole new template language , just for this feature", "i would urge you to re - open discussion on this"], "issue_sim": [0.5692519545555115, 0.3192676901817322, 0.48201096057891846, 0.028854062780737877], "prob": [0.8835778832435608, 0.009726114571094513, 0.07690691202878952, 0.0017325402004644275]}, {"target": [2], "doc": ["actually i be with @simplesmiler @herringtondarkholme", "we might need a way to reuse render logic in template without mess up data context", "another parallel mechanism will definitely increase complexity but i think it be well than introduce something like <tag> to reuse template piece after all ."], "issue_sim": [-0.004586383700370789, 0.4666649401187897, 0.4334353804588318], "prob": [0.010463494807481766, 0.7563623785972595, 0.6885852813720703]}, {"target": [0], "doc": ["i prefer the explicit way , especially if your <tag> depend upon another condition :", "i 'd rather create another directive <tag> to handle that syntactic sugar"], "issue_sim": [0.27491477131843567, 0.40227165818214417], "prob": [0.6416124105453491, 0.23747140169143677]}, {"target": [1], "doc": ["@gbezyuk i be , however suggest you to create it as a separate package", "imo the benefit be not enough to include it in the core"], "issue_sim": [0.151620015501976, 0.15026094019412994], "prob": [0.0433795303106308, 0.727121114730835]}, {"target": [1], "doc": ["i would rather use the v - else with v - if", "v - empty or v - else with v - for be not that easy to understand .", "keep it simple stupid"], "issue_sim": [0.15545883774757385, 0.07217207551002502, 0.06815077364444733], "prob": [0.005936372093856335, 0.8878348469734192, 0.022945158183574677]}, {"target": [1], "doc": ["i agree with @dsonet -", "i be not fond of the idea of introduce special behavior directive when you can simply do <tag> - a dedicated directive may save a few keystroke , but at the cost of explicitness , and require you to backtrack for the corresponding <tag> to be sure of what it do ."], "issue_sim": [0.0740504264831543, 0.3561635911464691], "prob": [0.024489616975188255, 0.9639169573783875]}, {"target": [2], "doc": ["@yyx990803 i be also concerned about enlarge api for convenience , but since <tag> also handle the case of iteration through object that be n't array , i would indeed value a <tag> or <tag> directive", "g an object property do not have a direct <tag> property etc", "the fact that an iterator be empty seem very much symmetrical to v - if / v - else to i .", "in my current case , i iterate through property  without necessarily need to express in the template how the iterator be implement", "since v - for have to iterate anyway , extend it to keep a boolean  and render an ' empty ' branch if the loop content be never touch after iteration should be helpful , straightforward and more performant than call object", "length even if the template include an understanding of the iterator implementation", "empty iterator branch also have precedence in all other template language i use so far", "the current way seem quite clumsy  and it wo n't really get any well when use a component method on this either"], "issue_sim": [0.4524776339530945, 0.02258414216339588, 0.304340124130249, 0.44712743163108826, 0.43068182468414307, 0.30745449662208557, 0.4021676182746887, 0.20297642052173615], "prob": [0.0046315910294651985, 0.0027100201696157455, 0.09055505692958832, 0.06265434622764587, 0.5483203530311584, 0.008254487998783588, 0.003301431192085147, 0.022904466837644577]}, {"target": [1], "doc": ["i be actually surprised this have n't be implement", "if you look at other template language it be a common feature ."], "issue_sim": [0.11327129602432251, 0.2732926607131958], "prob": [0.06885647028684616, 0.8814065456390381]}, {"target": [6], "doc": ["i 've read through this a few time and i personally do n't think <tag> be need", "nearly every time i think i might like this , i find out that i be n't completely understand my problem", "the follow two code snippet be all that i 've ever need", "start with number one , migration to number two be very straightforward :", "when the occasion call for a proper wrapping element , you just need to change the <tag> tag to a real tag :", "every loop in every codebase i manage fall in to one of these two option", "i understand that other template language have an <tag> feature , but i feel like add more vue - specific syntax will raise the barrier of entry for newcomer ."], "issue_sim": [0.1163330227136612, 0.08681856840848923, 0.09378130733966827, 0.11611483246088028, 0.398722380399704, 0.19128373265266418, 0.3845301866531372], "prob": [0.12141815572977066, 0.18310867249965668, 0.007349634543061256, 0.029818816110491753, 0.11359699070453644, 0.004743638448417187, 0.44322511553764343]}, {"target": [12], "doc": ["this nice bit of syntactic sugar be an odd thing not to have imo", "apart from issue where it have direct utility , e", "an iteratee derive from a semi - complex expression , where the need to refer to it twice add cruft and introduce the possibility of bug if the two reference go out of sync", "an iteratee that can not be declare empty just by reference length", "it also have value as a way of nudge one towards good practice", "@sirlancelot say that any time he think he need <tag> it turn out he do n't understand the problem fully", "for i it be the exact opposite : many time i 've code up a list only to realize that the design would misdirect the user in the case where the list be blank", "i have find that a fallback be need more often than not", "and of course @sirlancelot 's ption 1", "is exactly equivalent to the function of <tag>", "it be just slightly more verbose , and hence slightly less idiomatic - look", "the idea , to i , be that if a pattern be universally consider right and good , and it come up often , that pattern ought to have the simple syntax it reasonably can", "i 'll also add that give how many template language * do * have a feature like this , the absence of such a feature in vue become confuse .", "i mean , that be how i wind up here"], "issue_sim": [0.20843243598937988, 0.013431629166007042, 0.20252910256385803, 0.09792546182870865, 0.039130352437496185, 0.12813442945480347, 0.4479355216026306, 0.1803520768880844, 0.03701930493116379, 0.10314051806926727, 0.260498046875, 0.23005974292755127, 0.4144667983055115, 0.0063560036942362785], "prob": [0.004259358160197735, 0.0061317384243011475, 0.18095196783542633, 0.011945618316531181, 0.000953810173086822, 0.0012419612612575293, 0.20870894193649292, 0.002492027124390006, 0.00024514785036444664, 0.00043888037907890975, 0.0010938876075670123, 0.07281364500522614, 0.06636081635951996, 0.004580304492264986]}, {"target": [3], "doc": ["my guess be you be have hard time update your app to the late version , while you want your code to work as it be now", "or it may be the question of a habit", "to my opinion auto - convert prop be a bit excessive", "there be at least <number> way of solve the problem : add a colon to attribute , use a custom filter , a coerce function .", "i do n't think add an extra layer of magic be a good idea", "plus there will be new edge case , plus it will affect performance"], "issue_sim": [0.28803277015686035, 0.06166418641805649, 0.3013676404953003, 0.5157928466796875, 0.11571335792541504, 0.08279872685670853], "prob": [0.3591926395893097, 0.002234470099210739, 0.00045414295163936913, 0.35028672218322754, 0.0068487985990941525, 0.011462819762527943]}, {"target": [2], "doc": ["@posva because static attribute be always treat as strings", "its nice and clear", "if you need a number but do n't want to bind it to some property just use a colon - it will be treat as an expression and will be convert into a number .", "same go for booleans", "it be nice because it be explicit", "be it hard to use a colon when you need a number"], "issue_sim": [0.21107885241508484, 0.04506659135222435, 0.49896448850631714, 0.17831945419311523, 0.09722763299942017, 0.21165111660957336], "prob": [0.012056057341396809, 0.011285428889095783, 0.6166943907737732, 0.0019850863609462976, 0.012696865946054459, 0.04878100007772446]}, {"target": [1], "doc": ["@posva also , it would be a break change", "someone may intentionally pass a number via static attribute because they want it to be a string for concatenation ."], "issue_sim": [0.07235705107450485, 0.39190536737442017], "prob": [0.0027197266463190317, 0.9935617446899414]}, {"target": [0], "doc": ["<tag> be new general thing for js"], "issue_sim": [0.16948866844177246], "prob": [0.9995785355567932]}, {"target": [0], "doc": ["i do n't think there be case where it be necessary to use <tag> or <tag> to represent ui state ;", "they be not json serializable ;", "the benefit do n't justify the amount of work need to properly support they , especially when they be not available in every browser"], "issue_sim": [0.18880224227905273, 0.15459495782852173, 0.17024767398834229], "prob": [0.8383861780166626, 0.001912845065817237, 0.6649613380432129]}, {"target": [3], "doc": ["@yyx990803 here be a valid use case that support the need for a set", "i do n't want the field to initially be display as invalid on the ui , i add a class to show an input as a valid or invalid element", "the element be only mark as valid or invalid once it be bring into focus , and mark as touch", "i do n't want to have a potentially massive array contain all the time an input have be bring into focus , so the set would be ideal ."], "issue_sim": [0.2801818549633026, 0.2610377073287964, 0.11483952403068542, 0.18292202055454254], "prob": [1.5783356502652168e-05, 0.6382432579994202, 0.0006788086029700935, 0.5090885758399963]}, {"target": [1], "doc": ["+1 for implement this", "i have a tree datum structure with an iterator , convert to array would result in large , unnecessary overhead ."], "issue_sim": [0.1822255402803421, 0.3796939253807068], "prob": [0.04627864435315132, 0.9503307938575745]}, {"target": [1], "doc": ["map / set be useful stucture .", "it be urgent to support they in vue , otherwise it 'll be inefficient to use they in vue app"], "issue_sim": [0.25572189688682556, 0.3268912434577942], "prob": [0.04991282522678375, 0.9338869452476501]}, {"target": [0], "doc": ["if you support object then it be only consequent to also support maps and set for exactly the same reason ."], "issue_sim": [0.18812304735183716], "prob": [0.9999921321868896]}, {"target": [0], "doc": ["note that vue 's prop system have its own semantic and do not aim to map strictly to the html attribute semantic .", "- i agree when a prop expect a boolean type , it make sense to map <tag> to <tag> and absence of the prop to <tag>", "- i do n't like make <tag> map to <tag>", "in html5 even if you give a bogus value a boolean attribute will be set to true , e", "the spec 's design be imo quite confuse here", "- for literal <tag> and <tag> , i do n't think it be necessary to deprecate they simply because the spec do n't allow it"], "issue_sim": [0.45128294825553894, 0.5406451225280762, 0.13463488221168518, 0.6280414462089539, 0.3158504366874695, 0.4377429485321045], "prob": [0.5043259859085083, 0.2719765603542328, 0.001497521996498108, 0.03397747129201889, 0.002797298366203904, 0.44632506370544434]}, {"target": [1], "doc": ["i disagree with this change , because i think this will create some confusion", "it be _ prop _ , not _ attribute _ .", "i like to think that prop always need to have value , so instead of <tag> , i prefer <tag>", "say , if template be partially render on server and if it come with <tag> , i would n't want that   cast to boolean , i would like to restrict that prop to boolean only", "also , vue have some \" directive param \" that be use without value , e", "<tag> , so it will be confuse again"], "issue_sim": [0.17165377736091614, 0.39420831203460693, 0.3131777048110962, 0.6040931940078735, 0.3531506061553955, 0.08828206360340118], "prob": [0.018384579569101334, 0.2681092917919159, 0.04710370674729347, 0.5114611983299255, 0.07456658035516739, 0.009102794341742992]}, {"target": [7], "doc": ["by _ legit case _ i mean a piece of code that an * * average * * programmer would write for a particular purpose", "maybe i be an optimist , but i like to believe that the average programmer have more sense than return an error instead of use the language be build in error handling mechanism", "i do n't agree that you be do newbie a favor by tolerate their mistake : eventually , designing function that behave that way will get they in trouble", "all modern language have build - in error handling mechanism for a reason : thing _ will _ fail and good code should always _ fail safe _", "technically , error can be propagate but when cross language barrier  , the propagation need to be explicit ; it be not up to any framework to do that for you unless you ask it to", "and since we be in the realm of confusion , soon or later , someone will expect regular html component to work with the true / false thing the same way i expect vue to handle boolean attribute as per the html spec :", "which would result in a checkbox that be always check", "my proposal attempt to mitigate half of the source of confusion"], "issue_sim": [0.20321907103061676, 0.28620702028274536, 0.2541138231754303, 0.22838327288627625, 0.29926878213882446, 0.5981795787811279, 0.24805226922035217, 0.0028207702562212944], "prob": [0.08701884001493454, 0.49119266867637634, 0.11280737072229385, 0.02185176871716976, 0.49968910217285156, 0.20311826467514038, 4.116286072530784e-05, 0.00032613941584713757]}, {"target": [0], "doc": ["yes , but many argue against use exception unless absolutely need .", "try / catch be a very slow operation", "also you lose much context about what", "many , include myself , prefer to deal with error where", "on mon , jun <number> , <number> at 9:09 am , azamat notifications@github"], "issue_sim": [0.09667662531137466, 0.17892923951148987, -0.026380587369203568, -0.023501228541135788, -0.03353435546159744], "prob": [0.9948676824569702, 0.001753337448462844, 0.0007771259406581521, 0.015154790133237839, 0.01022438146173954]}, {"target": [7], "doc": ["@mark - hahn i intentionally use _ error _ handle as oppose to _ exception _ handle in an effort to avoid confusion", "obviously , i have fail", "my point be that it be generally well to send error on a separate channel :", "- in c , you 'd have function that manipulate datum pointer send as argument and return an integer status code", "js ' continuation all expect to be call with <tag>", "- rust , haskell , scala use <tag> / <tag>", "- and of course , lot of language have good old fashioned propagating exception", "even when the situation mandate that error be send as result , not check the return code for those special value be equivalent to not handle error , and one can not expect a backend - agnostic mvvm - framework to do that for you ."], "issue_sim": [0.31911909580230713, 0.07007898390293121, 0.06915958970785141, 0.1718067079782486, 0.26712095737457275, 0.18437480926513672, 0.08071784675121307, 0.4171323776245117], "prob": [0.0011699728202074766, 0.005533596035093069, 0.00483221560716629, 0.17064879834651947, 0.0008091537747532129, 0.0076010944321751595, 0.0011442004470154643, 0.6672927141189575]}, {"target": [0], "doc": ["hmm , i think <tag> would be useful , in case prop or value of prop be n't pass , that could be more logical imo , because false be false , true be true , undefined be when it be miss .", "but yeah , not a big deal"], "issue_sim": [0.5811841487884521, 0.044370297342538834], "prob": [0.9440841674804688, 0.013345819897949696]}, {"target": [0], "doc": ["scoped slot be hard to reason about since they be compile inside the component which be not visible  .", "but the main issue with they be that there be already a way of achieve the same behaviour with component and prop which be concept already exist in vue", "moreover scoped slot be not possible in vue <number> : you can pass component or function and easily use they in render function", "your code snippet be work nicely and you can still use it if you prefer use the scoped - slot syntax", "you may consider use <tag> to handle name modification", "you should share it as a lib so other can benefit from it too"], "issue_sim": [0.5002245903015137, 0.43090248107910156, 0.5346992015838623, 0.2934052348136902, 0.24398010969161987, 0.06140890717506409], "prob": [0.7611865401268005, 0.22330686450004578, 0.19413314759731293, 0.143392413854599, 0.0004473318695090711, 0.0023215070832520723]}, {"target": [0], "doc": ["i 'll release it as a standalone plugin", "out of curiosity , what would be the idiomatic way to achieve this sort of functionality   in vue <number>"], "issue_sim": [0.1724058985710144, 0.46779415011405945], "prob": [0.09065410494804382, 0.836310625076294]}, {"target": [0], "doc": ["scoped slot exist in vue <number> .", "no need for a plug - in"], "issue_sim": [0.28225430846214294, 0.04619165509939194], "prob": [0.9906152486801147, 0.0016012886771932244]}, {"target": [0], "doc": ["this be not a real answer , but for readability in the short term you could break the parameter across multiple line . eg ,"], "issue_sim": [0.39877042174339294], "prob": [0.9998655319213867]}, {"target": [2], "doc": ["i be also have problem with multiple condition classname like in your example", "but please note you be propose to bring new directive syntax for a sole case", "it do not look to like a wise decision to i , because @yyx990803 try to make directive ' syntax as compact as possible and make it look like common javascript with simple expression , array and object ."], "issue_sim": [0.43299394845962524, 0.07879842817783356, 0.559979259967804], "prob": [0.05305635929107666, 0.024135291576385498, 0.6838856935501099]}, {"target": [1], "doc": ["@luwenjin <tag> be es6 only", "other than that you can make a custom method <tag> and use that :", "or , with support for es5 browser :"], "issue_sim": [0.35377800464630127, 0.23559054732322693, 0.3085314929485321], "prob": [0.0029097851365804672, 0.8868516087532043, 0.22410394251346588]}, {"target": [5], "doc": ["@rpkilby in my example , the read - only class be a special case show false value will be ignore", "in common case , it will be like :", "it be es5 object literal vs es6 , if you can use es6 style , you will almost never use the old style", "anyway , thank for the advice", "@fullfs i like the compact feeling of vue", "but just like v - for , imho , if one directive be use so frequently , it be worth break the rule in order to make the user wre code fast / clear .", "and in my proposal , it be still common javascript in some way , it be the spread arguments { } )", "even if stick to the list / object type ,", "be still look well", "i admit support es6 style object literal be the hard part", "and without support it , my proposal be almost meaningless", "not easy to find an elegant way to support it in es5 runtime"], "issue_sim": [0.4065195918083191, 0.026608949527144432, 0.549596905708313, -0.02080094814300537, 0.17878466844558716, 0.3131028413772583, 0.28591328859329224, 0.11277806758880615, 0.09187507629394531, 0.4960055351257324, 0.03808131441473961, 0.4867272675037384], "prob": [0.00699269725009799, 0.011298943310976028, 0.164511576294899, 0.004506909754127264, 1.5471732695004903e-05, 0.36884596943855286, 0.007134159095585346, 0.0013343445025384426, 5.428124131867662e-05, 0.0034704178106039762, 0.0008646587957628071, 0.0011768063995987177]}, {"target": [0], "doc": ["when a tag like <tag> grow to those dimension so i have to start think about how to write it more elegantly , i 'd prefer to just throw out the whole thing and handle it in javascript : <tag>", "there 'll be an overhead when i want to use it in different location with different configuration , but in my opinion it be preferable to introduce new syntax sugar"], "issue_sim": [0.5456964373588562, 0.46660080552101135], "prob": [0.7665521502494812, 0.3242616355419159]}, {"target": [2], "doc": ["here be what i think :", "<tag> binding should still be valid javascript expression", "we should just support object inside array , which should n't be a lot of work :"], "issue_sim": [0.000772334635257721, 0.43640434741973877, 0.3665729761123657], "prob": [0.07666552066802979, 0.1294691115617752, 0.5088357925415039]}, {"target": [0], "doc": ["it be to permit an optimisation that only build a large parameter object for a give event if the event be actually to be receive by the component on which it be emit ."], "issue_sim": [0.5666334629058838], "prob": [0.9999692440032959]}, {"target": [0], "doc": ["as you explain yourself , for parent / child event , you can already<tag> , so i think @posva be interested in understand what use case require to emit and listen to an event * within the same component * , instead of , for example , call a method if <tag> be set in the component 's local datum .", "it be not something i 've ever come across so far", "the reason for ask for the use case be this : add a new api for the purpose of a \" fringe use case \" be n't really anything we would consider right now , so we have to understand the prevalence and severity of the use case for any new api / feature we add"], "issue_sim": [0.6608698964118958, -0.04647032544016838, 0.37543582916259766], "prob": [0.8473742008209229, 0.013390369713306427, 0.4166746735572815]}, {"target": [2], "doc": ["@linusborg i be not listen to the event from the same component", "i be simply listen to this event programmatically through a call to <tag> , instead of directly from the template", "and when do so , the event do n't show up in <tag> , only event that be provide in the template do so .", "this be something i be use in @ditojs / admin : <url> , a vue", "js base framework to build admin ui from simple pojo schema", "and since much of the connecting be happen through code and processing of these schema , i can not listen the vent in a template", "since one be expose , i be wonder why be n't the other"], "issue_sim": [0.3795429468154907, 0.42921578884124756, 0.4457014799118042, 0.12567730247974396, 0.25969910621643066, 0.11452330648899078, 0.07979053258895874], "prob": [0.000501250964589417, 0.34651094675064087, 0.8777251243591309, 9.700382361188531e-05, 3.585955346352421e-05, 0.13743135333061218, 0.016310617327690125]}, {"target": [1], "doc": ["oh , the use case be clear to i :", "you do n't want to <tag> if the component be n't listen to the event because build the payload for the event be expensive"], "issue_sim": [0.12471722066402435, 0.4551498293876648], "prob": [0.05547011271119118, 0.9279983639717102]}, {"target": [0], "doc": ["just an idea : instead of emit the costly object you could emit a function that , when call , return the costly object .", "then the costly object be only ever create when someone actually call the function you emit which in turn should only happen when someone be listen to your event", "just my two cent", "not sure if this any good though"], "issue_sim": [0.5950182676315308, 0.4540320634841919, -0.03125213086605072, -0.02095271646976471], "prob": [0.8320085406303406, 0.6882882118225098, 0.012119675055146217, 0.009311811998486519]}, {"target": [1], "doc": ["@christiankienle a good idea ,", "but this be for a public - face api , and i 'd like to use a similar approach as nuxt do for its hook , where you use destructuring to pluck the parameter that you need out of one single object argument provide to the callback ."], "issue_sim": [0.029649369418621063, 0.4344989061355591], "prob": [0.022292090579867363, 0.9609740972518921]}, {"target": [0], "doc": ["in the meantime i 've transition fully away from vue 's own event mechanism , since i need the callback to be async and also queue .", "i guess we can close this issue , but maybe <tag> would still be useful to other", "here be my <tag> : <url>"], "issue_sim": [0.32497841119766235, 0.28367477655410767, -0.053833212703466415], "prob": [0.9043173789978027, 0.13750852644443512, 0.0335356704890728]}, {"target": [0], "doc": ["why do n't you export the symbol in a separate file , so you can import it in both of your chunk ?"], "issue_sim": [0.4981999695301056], "prob": [0.9998471736907959]}, {"target": [1], "doc": ["that do n't solve the problem ; you still have to asynchronously load that file", "actually complicate it more because you wo n't be able to leverage vue 's \" async component \" feature to block the declaration of the component till the chunk be load because the file be no long a component ."], "issue_sim": [0.26879602670669556, 0.36086931824684143], "prob": [0.046833548694849014, 0.9256638288497925]}, {"target": [0], "doc": ["i mean not asynchronously load that chunk since it be so small , it be unnecessary .", "it do n't change the rest of the code , specially the async component part"], "issue_sim": [0.2134348303079605, 0.24589163064956665], "prob": [0.9605929851531982, 0.015016097575426102]}, {"target": [0], "doc": ["perhaps i should have mention that both <tag> and <tag> be entry point .", "if you be suggest that i synchronously load it , the symbol file will be inline in both entry point and will create two different symbol"], "issue_sim": [0.25731152296066284, 0.5894163846969604], "prob": [0.9794918298721313, 0.015191360376775265]}, {"target": [4], "doc": ["oh , that be right , the symbol will be different", "although , i should have raise this other point right from the start : why be you try to async load two component that use inject", "i suppose you be create an app and not a lib", "and i wonder if you need to use inject / provide which more target towards lib", "imo if you relate two component the way you do , they should be in the same chunk"], "issue_sim": [0.22704830765724182, 0.4715847969055176, 0.15243324637413025, 0.35328060388565063, 0.17369848489761353], "prob": [0.03456199914216995, 0.6740971803665161, 0.009202555753290653, 0.04149920493364334, 0.02419050969183445]}, {"target": [1], "doc": ["a code split library", "even though that look like a bad idea , you should put those component in the same chunk"], "issue_sim": [0.16349628567695618, 0.3014926314353943], "prob": [0.03243847191333771, 0.9194532632827759]}, {"target": [2], "doc": ["the library be modular and have many entry point to accommodate a specific use - case ; but this be besides the point of this feature request and i wo n't be go into the detail of it", "normally , this should n't be an issue as webpack have chunk and async load", "the inconvenience be in the fact that vue have an async component loader but <tag> be n't a function so it be evaluate before the async component be load .", "ask to make <tag> take in a function seem like a reasonable feature request that could have other benefit", "thank for try to help but i be not look for solution to a problem  and would like for this issue to be regard simply as a feature request"], "issue_sim": [0.2414701133966446, 0.48817873001098633, 0.44404423236846924, 0.16727617383003235, 0.22091931104660034], "prob": [0.8951035737991333, 0.0008936365484260023, 0.6175293326377869, 0.0008546109311282635, 0.014480889774858952]}, {"target": [2], "doc": ["do n't worry , i be sceptical about my own fr too    i be usually bad at myself", "i be concerned about how this pattern could impact the usage of inject / provide", "the <tag> usage in inject / provide you provide be definitely as good one , the part i be sceptical be the part reference the parent from the child , it be basically the same as do <tag> .", "right now , inject can not access to the component , and it be very static , it limit the behaviour on purpose", "make it a function make it super flexible and also dangerous", "ps : i feel like it really bother you that i be ask you question but i can not understand why", "the use - case may be super clear for you but it be not for i    i be not do this to bother you , i be do it to make it clear"], "issue_sim": [0.05116359516978264, 0.28299301862716675, 0.2900392413139343, 0.4042387008666992, 0.07341741770505905, 0.05168980360031128, 0.1939544677734375], "prob": [0.003352097235620022, 0.001035316614434123, 0.5674052834510803, 0.039058759808540344, 0.004149224609136581, 0.00029888885910622776, 0.11194907873868942]}, {"target": [0], "doc": ["i think it be too complicated , do we also need to consider custom event ?"], "issue_sim": [0.42519184947013855], "prob": [0.9999548196792603]}, {"target": [1], "doc": ["imo if you do this it should be a separate directive  , but not the native <tag> rewritten itself .", "the reason be <tag>  should also handle custom event as mention by @lonelyclick  , and all this additional inner - library work be redundant for <number> % <tag> use case"], "issue_sim": [0.4603785276412964, 0.48797789216041565], "prob": [0.4170600175857544, 0.518511176109314]}, {"target": [2], "doc": ["i think this could be a good fit  if we follow @wostex 's suggestion", "although , a <tag> or <tag> would make most sense in my mind", "this could open the door for pass around event names+handlers , which would shortcut the  repetitive template assignment ."], "issue_sim": [0.08077874779701233, 0.09448671340942383, 0.2424495667219162], "prob": [0.02714809589087963, 0.2679124176502228, 0.7778028845787048]}, {"target": [0], "doc": ["i still think this should not be a part of vue , it should be a separate directive that you can use ."], "issue_sim": [0.35763221979141235], "prob": [0.9992983341217041]}, {"target": [0], "doc": ["the modifier have be parse when template compile. if we support modifier we should support parse modifier at runtime", "imo this be not a good idea"], "issue_sim": [0.3236771821975708, 0.16047446429729462], "prob": [0.9291139245033264, 0.0268254391849041]}, {"target": [1], "doc": ["this be partially implement in 11614d6 - however , this syntax be introduce primarily for make it easy to proxy event in component", "modifier for this syntax introduce too much runtime complexity and be not support ."], "issue_sim": [0.46279579401016235, 0.33349767327308655], "prob": [0.03353828564286232, 0.9830518960952759]}, {"target": [0], "doc": ["actually it would probably make more sense for <tag> to accept an array of the currently support type since each <tag> decorator could take different option ."], "issue_sim": [0.5588867664337158], "prob": [0.9999735355377197]}, {"target": [1], "doc": ["when do you need to call multiple watcher function on the same property", "it be really weird to split a watcher up"], "issue_sim": [0.5384824872016907, 0.17174506187438965], "prob": [0.7520462870597839, 0.05874074995517731]}, {"target": [4], "doc": ["i do n't think it be that weird", "in my case i have some radio button and select a different one require some other part of the view to be update", "it happen that there be two part of the view that need updating and i already have two separate function to update each part of the view", "as i say above , i be use decorator , so think i 'd just add a <tag> decorator before both of those function , but at the moment only the second one get call because it overwrite the first one", "it be probably possible to change the definition of the decorator so that this work without allow an array  , although this seem a bit hackish and it would n't support different watch option .", "if <tag> accept an array as i suggest in my comment it would be very easy to design the <tag> decorator to support this scenario"], "issue_sim": [0.08895387500524521, 0.26977479457855225, 0.38049638271331787, 0.6352447271347046, 0.614858865737915, 0.5140330791473389], "prob": [0.006254337262362242, 0.4848882257938385, 0.012053546495735645, 0.11635302007198334, 0.1554488092660904, 0.14925582706928253]}, {"target": [5], "doc": ["what i be try to do be something like this", "i think this code be quite intuitive when you see it write down", "however , when <tag> change , <tag> be never call", "this be because the decorator be implement as follow", "so the second <tag> decorator overwrite the first", "in order to support multiple <tag> decorator for the same path i think <tag> should support an array ."], "issue_sim": [0.08241258561611176, 0.13170364499092102, 0.21584434807300568, 0.4488382935523987, 0.35625699162483215, 0.5760120153427124], "prob": [0.00014868036669213325, 0.001317466958425939, 3.2132222258951515e-05, 0.020076775923371315, 0.0006956024444662035, 0.773880660533905]}, {"target": [0], "doc": ["why not just maintain an array in your own code and provide vue one watch handler ?", "i do n't think it be hard for either ts user or vanilla vue user"], "issue_sim": [0.4476500153541565, 0.11348124593496323], "prob": [0.5378708243370056, 0.19472099840641022]}, {"target": [0], "doc": ["but in your example , compute property seem to be a much well choice than watcher"], "issue_sim": [0.2400541603565216], "prob": [0.999384880065918]}, {"target": [2], "doc": ["ok , maybe i will see if i can call $ watch in my decorator definition , but i need to learn more about decorator first", "for the time be have a dedicated method for each <tag> be not too much extra effort", "but i still think it would be quite easy to add support for the component option <tag> to be an array , and this would also cover the case where someone might want to have two watcher with different option  for the same key ."], "issue_sim": [0.5711911916732788, 0.1595398634672165, 0.5042648911476135], "prob": [0.43730825185775757, 0.005650387145578861, 0.7177708148956299]}, {"target": [0], "doc": ["there be a <tag> hook , but i think you 'd need to manage animation purely in js , and from an object in a high scope , like an instance of gsap e.g.", "<tag> which would give you option to cancel or reverse animation"], "issue_sim": [0.44632890820503235, 0.3182700276374817], "prob": [0.9318962097167969, 0.025840604677796364]}, {"target": [3], "doc": ["thank you for your reply", "unfortunately , the problem be not how to stop / reverse the animation / transition", "that work very well already", "the problem be that when the transition  be finish , vue.js will still show the component i 've stop transition to .", "to see what i mean , just play the fiddle : <url>", "drag <tag> just a little to the right", "the component slide back into its original position", "js replace it with <tag>", "i can replace it in turn with <tag> , but for a split second , you will see <tag>none the less"], "issue_sim": [-0.12394742667675018, 0.4177634119987488, 0.059513241052627563, 0.5188931822776794, 0.16444632411003113, 0.15186026692390442, 0.2181268185377121, 0.3044061064720154, 0.25283390283584595], "prob": [0.0033900709822773933, 0.013636747375130653, 0.0005336723406799138, 0.7750906348228455, 0.0010218187235295773, 0.0008092924836091697, 0.001023916294798255, 0.002981538185849786, 0.14052070677280426]}, {"target": [2], "doc": ["@lunelson unfortunately , not call <tag> do n't work", "you can see for yourself here : <url>", "the result be that bar do n't disappear and the router just keep wait for the transition to finish .", "and for the hook : i do n't understand , how i would make use of they", "i ca n't call they to cancel the transition", "they just allow i to * react * to cancel transition", "my problem be how to cancel transition manually in the first place"], "issue_sim": [0.1527763307094574, -0.005892574787139893, 0.26389414072036743, 0.08188476413488388, 0.1863442212343216, 0.2507290244102478, 0.370158314704895], "prob": [0.00668421620503068, 0.012698053382337093, 0.41006335616111755, 0.2374092936515808, 0.01900787465274334, 0.029288286343216896, 0.01955876126885414]}, {"target": [3], "doc": ["the problem be that there be nothing leave to abort by that point", "when you call <tag> , the router transition be complete immediately , the router - view re - render itself with the new component , and the transition hook be only for animate the old child out and the new one in", "that be handle by the transition component , from the router - view 's point of view ,   the change already happen", "you can see that the url change immediately after you start drag , and the old component will be remove as soon as you call do  ."], "issue_sim": [0.13742724061012268, 0.48144567012786865, 0.3994024395942688, 0.5109435319900513], "prob": [0.009428143501281738, 0.7484390735626221, 0.033651936799287796, 0.15251266956329346]}, {"target": [2], "doc": ["sorry for let this sit and this reply be probably too late - but ultimately i think this type of app - like navigation really beg for a dedicated card - stack base , touch - aware navigation solution", "<tag> be still largely design around the \" nested box \" desktop navigation model", "the build - in transition system be really mean for fire - and - forget state toggle animation , just add <tag> would n't be an answer to the root problem ."], "issue_sim": [0.4254756569862366, 0.25014597177505493, 0.35441654920578003], "prob": [0.7660491466522217, 0.00992005504667759, 0.5923600196838379]}, {"target": [0], "doc": ["hi , my understanding and test be that it be support only if the transition component contain a keep - alive component that contain dynamic component , all of which will use the same transition .", "my request be in the use case where each component contain a different transition"], "issue_sim": [0.7012820839881897, 0.6279836893081665], "prob": [0.9391006827354431, 0.03654919192194939]}, {"target": [0], "doc": ["i think about the use case and i do n't think <tag> on <tag> would make sense , because it be not really about <tag> or the component be switch .", "instead , i 'd make a custom transition component that communicate over a share event bus : <url>", "you can use this component as the base and make variation of it for different view , but they can all share the same communication channel as long as they belong to the same <tag>", "note the fix for <tag> be not release yet so i be not include it in the fiddle"], "issue_sim": [0.43190330266952515, 0.5474042892456055, 0.37312328815460205, 0.31259071826934814], "prob": [0.5321758389472961, 0.034112002700567245, 0.4198968708515167, 0.006477906834334135]}, {"target": [3], "doc": ["can you elaborate a bit on your case", "i be curious about it", "the main case i can think off be sub - component like menu > menuitem", "although i 'd apply the bem methodology in that situation .", "what be stop you from use a css methodology like bem in that specific case"], "issue_sim": [0.029311571270227432, 0.019896838814020157, 0.4063951075077057, 0.096739262342453, 0.4239139258861542], "prob": [0.01730954647064209, 0.02120906300842762, 0.059606075286865234, 0.5812326073646545, 0.032589834183454514]}, {"target": [0], "doc": ["for your own component , one should prefer pass in prop to change the component 's behavior .", "if it be a third party component , then i guess i could see the use case , since you ca n't edit the source of it very intuitively"], "issue_sim": [0.5883902907371521, 0.41413095593452454], "prob": [0.9156369566917419, 0.10555611550807953]}, {"target": [4], "doc": ["let take the <tag> example", "menu have a list of child menuitem component", "see the below code snippet", "now if you have <number> different component that use menu - item component on the page and you want to style the menu - item differently on the page", "use global style  in the menu component  will also change the style of the 2nd menu item on the page unless some other unique identifier be use to scope the style .", "nothing be stop i from use bem , but why use it when there be scoped style that can solve the problem"], "issue_sim": [0.1478259265422821, 0.4103601574897766, 0.20692870020866394, 0.5537338256835938, 0.5559958219528198, 0.39559048414230347], "prob": [0.028772050514817238, 0.021105187013745308, 0.002501634880900383, 0.1788208931684494, 0.43446922302246094, 0.023645766079425812]}, {"target": [1], "doc": ["go off that example above ^ i would also like to avoid use the <tag> rule", "what if vue allow you to declare which child component 's style you want to overwrite and it inject that specific <tag> block * below * the child component style in the <tag> so it become more important because of the order ."], "issue_sim": [0.1681760549545288, 0.7540642619132996], "prob": [0.06719718128442764, 0.8079800605773926]}, {"target": [0], "doc": ["yes , that example will work for the first child of the component , but if menuitem have another component inside of it call <tag> then we ca n't modify <tag> style  since it do not contain the menu 's unique id as an attribute ."], "issue_sim": [0.6538255214691162], "prob": [0.9999895095825195]}, {"target": [1], "doc": ["do you try it with <number> component", "i post an example with <number> component and i want to style the button component which be the most deeply nest component which i could n't overwrite   the scoped style from the root component .", "maybe i be do something wrong"], "issue_sim": [0.4654482305049896, 0.7609731554985046, -0.029009433463215828], "prob": [0.04306682199239731, 0.9508782625198364, 0.039510857313871384]}, {"target": [1], "doc": ["@posva your example be work because you be use <tag> in the 2nd component <tag> and you be import the button into the root <tag> component", "in my example , button be import by the <tag> component so its nest inside the 2nd level component .", "here be my example :"], "issue_sim": [0.6435784101486206, 0.5802540183067322, 0.013699685223400593], "prob": [0.29345518350601196, 0.8941907286643982, 0.004045769106596708]}, {"target": [0], "doc": ["it still work that case , add a <tag> without <tag> and make sure the specificity of the selector be high by add one class be enough .", "let the menu , item aside , i be more interested in a different case that can not be solve with a css methodology"], "issue_sim": [0.4357282817363739, 0.5164847373962402], "prob": [0.7685538530349731, 0.144776850938797]}, {"target": [1], "doc": ["yep - just snip the example for brevity", "there might be a well way , but we use a series of watcher .", "it look like  do the same thing"], "issue_sim": [0.12413263320922852, -0.0569179505109787, 0.023426562547683716], "prob": [0.3353606164455414, 0.7208428978919983, 0.02770962007343769]}, {"target": [0], "doc": ["i think this be a cool feature , as it bring consistency to user generate input - component with very little cost .", "i would suggest a very simple implementation :", "when <tag> be set in the component", "let <tag> be a shorthand for <tag>"], "issue_sim": [0.33910301327705383, 0.22410869598388672, 0.27002543210983276, 0.2297576665878296], "prob": [0.8337407112121582, 0.027825068682432175, 0.14062876999378204, 0.04813448712229729]}, {"target": [0], "doc": ["imo it will bring more confusion than profit .", "ca n't see any problem use <tag> here", "to my pov it be just like \" i want it to look like a real input \"", "way too subjective :)"], "issue_sim": [0.012195935472846031, 0.09945153445005417, 0.030765067785978317, -0.07145120948553085], "prob": [0.9846990704536438, 0.0007893489091657102, 0.049880433827638626, 0.004444890655577183]}, {"target": [0], "doc": ["there be n't any problem with the <tag> syntax except that there seem to be some push to deprecate it ."], "issue_sim": [0.2964553236961365], "prob": [0.9999769926071167]}, {"target": [1], "doc": ["@azamat - sharapov i be not entirely sure what about it seem \" magical \"", "i expect <tag> not to mess with data type , keep it whatever type i set .", "instead , when use on an input with <tag> , the input be coerce to string ; not something i would expect it to do", "think about it another way , i have already say , \" this be a number \" by declare <tag>", "why be n't that sufficient", "there be no magic here ; vue be just pay attention to information the user 's already give about their intention"], "issue_sim": [0.04069140553474426, 0.02778911590576172, -0.013938996940851212, 0.055007509887218475, 0.11989979445934296, 0.028293101117014885], "prob": [6.33189893051167e-06, 0.48856431245803833, 0.7539762258529663, 0.0014344754163175821, 1.8819901015376672e-05, 0.014834129251539707]}, {"target": [2], "doc": ["i be call auto - casting as \" magical \" , because as evan also say - it be all string", "it be html to blame", "so , if you want enhancement to standard html , just add vue 's <tag> param or cast it by yourself ."], "issue_sim": [-0.08260498940944672, -0.0036073029041290283, -0.021317407488822937], "prob": [0.3123047351837158, 0.002105368534103036, 0.9861688017845154]}, {"target": [0], "doc": ["i think <tag> should try to stay close to native behavior , and only do value conversion when the user explicitly want it .", "so we 'll keep the current behavior"], "issue_sim": [0.0012652035802602768, 0.018501415848731995], "prob": [0.9824579358100891, 0.0002492258499842137]}, {"target": [0], "doc": ["browser 's behavior be that a numeric input have an additional property <tag> which should be use instead of <tag> . and be numeric by default ."], "issue_sim": [0.022756490856409073], "prob": [0.9999988079071045]}, {"target": [1], "doc": ["why duplicate presence of slot would cause error", "i think it be common to resue slot .", "maybe we should remove this warning"], "issue_sim": [0.3997699022293091, 0.21157442033290863, 0.1230246052145958], "prob": [0.033325813710689545, 0.9224299192428589, 0.010689808055758476]}, {"target": [0], "doc": ["i think this be because the vnode of the slot will always ref to the last render htmlelement , so only the last get patch ."], "issue_sim": [0.269873708486557], "prob": [0.9999679327011108]}, {"target": [0], "doc": ["this be possible to do with render function instead of template .", "there may well be side effect to do this , though it be work for my use case so far", "i do something similar in <url> which coincidentally can be use for breadcrumb - style ui :)"], "issue_sim": [0.4219730496406555, 0.3388684391975403, 0.3224526643753052], "prob": [0.5657707452774048, 0.0735095739364624, 0.19436100125312805]}, {"target": [1], "doc": ["i mean why have \" normal \" <tag> anyway", "from a dev history perspective <tag> be just there before <tag> , but in retrospect the scoped slot approach be more flexible .", "but there be no need to have split approach anymore", "it be more work for the child component that have to check <tag> * and * <tag>", "just deprecate <tag> altogether , mirror its property into cloning function of <tag> and trigger deprecation when try to use <tag>", "no library author need to do anything in this case , except when make a release for the next major vue version , when the deprecate stuff get kick out"], "issue_sim": [0.07368561625480652, 0.3058691918849945, 0.06596000492572784, 0.2406626045703888, 0.45718520879745483, 0.26693636178970337], "prob": [0.0003739048552233726, 0.8521162271499634, 4.4559408706845716e-05, 0.0020451436284929514, 0.1527574360370636, 0.11016014963388443]}, {"target": [0], "doc": ["another benefit of always use scopedslot insteadof slot be lazy evaluation of slot content :", "imagine a component with the follow template <tag>", "the load comp would not display the slot content until item become truthy , but \" normal \" slot be render eagerly cause error despite the slot content not be display"], "issue_sim": [0.27412015199661255, 0.3723154067993164, 0.42114579677581787], "prob": [0.16459999978542328, 0.002684899838641286, 0.9480090737342834]}, {"target": [2], "doc": ["thank for use vue for so long", "what you describe there  look like app level compute property , which be pretty much vuex", "if your piece of state be share across many component that do not have a common parent or it do n't make any sense to pass that datum deep until that component that need it  .", "you definitely need vuex", "otherwise <tag> should help you out by not reuse those component when they come back into the view"], "issue_sim": [-0.007314359303563833, 0.402473509311676, 0.3001668453216553, 0.09101638197898865, 0.21834012866020203], "prob": [0.00904611311852932, 0.16313813626766205, 0.5988916158676147, 0.0036886255256831646, 0.12007056921720505]}, {"target": [5], "doc": ["@posva yes , you be right :)", "but firstly i ca n't use <tag> sometimes", "for example , if user have many - many talk  and not refresh page for day , the performance issue will be :) but i agree it be a very good approach and use it ;)", "but you be right , that i need in app level compute property", "and i use vuex :)", "but i need compute property for each item in array ... but i can only define compute property on module level .", "and ca n't to define compute property on each item of array property in module :) but i very want to do it :)"], "issue_sim": [-0.10101546347141266, 0.02546638622879982, 0.36164844036102295, 0.28380680084228516, 0.09702063351869583, 0.46946388483047485, 0.47435247898101807], "prob": [0.00032181257847696543, 0.0014862105017527938, 0.7745287418365479, 0.001966985175386071, 0.000248653203016147, 0.7708067893981934, 0.06641390174627304]}, {"target": [2], "doc": ["i do n't see why that 'd happen unless you have leak on increasingly take up memory", "imo we do n't need anything new", "we can already solve those issue with vuex and keep - alive as mention above"], "issue_sim": [0.1392447054386139, 0.043088920414447784, 0.20360518991947174], "prob": [0.5932877659797668, 0.03120342455804348, 0.16782520711421967]}, {"target": [1], "doc": ["as for use vue instance with compute property as your state - i do n't recommend that", "create vue instance be relatively expensive .", "btw , i think this be more of a question", "please discuss on forum instead"], "issue_sim": [0.39151501655578613, 0.2360830307006836, 0.00954623892903328, 0.04978335648775101], "prob": [0.20634029805660248, 0.6175342798233032, 0.029631750658154488, 0.03522297739982605]}, {"target": [2], "doc": ["@yyx990803 there be no way to use getter on every item of array", "excuse i , but i think you be not right in this question", "that be why somebody try to use dynamic module , another person try to create <tag> for each item in array .", "and every time you say that \" we have getter , we have compute property \"", "but they be not helpful with array", "sorry for negative comment", ":( i really very like vuejs", "but this problem make i sad every time i face it"], "issue_sim": [0.40474772453308105, 0.03314068913459778, 0.31793490052223206, 0.35735684633255005, -0.0035813404247164726, -0.031783927232027054, 0.2866043448448181, 0.09183208644390106], "prob": [0.0007200484978966415, 0.01725209876894951, 0.5812265276908875, 0.1656983643770218, 0.0016371578676626086, 0.0005627762875519693, 0.003767061745747924, 0.0009443372837267816]}, {"target": [4], "doc": ["before we jump to \" solution \" , can we verify the problem first", "why do <tag> have to be a compute property", "do it really need the reactivity", "how often do a message need to be re - parsed", "it seem edit a message be a very low - frequency action - why ca n't it be parse once the moment a message be create , and have an explicit action for edit an exist message ?"], "issue_sim": [0.11377854645252228, 0.32487258315086365, 0.16764968633651733, 0.1806894838809967, 0.23824574053287506], "prob": [0.04264943674206734, 0.09747497737407684, 0.010497511364519596, 0.04686199501156807, 0.8313807249069214]}, {"target": [7], "doc": ["@yyx990803 i have many case and some of they be not simple as case above", "for example , i have <tag> in every talk", "also i have <tag> - the first <number> symbol of first line of last message body", "i have <tag> in talk , that can be different demand on type of talk", "but when dialog 's opponent change his firstname and lastname , i want the title of the talk with this user also automatically change", "also i have automaically generate avatar for talk that contain first char of first two word of chat title", "and many - many other property", "i want that change of one property have influence to another dependency property automatically .", "it be very hard to keep all this dependency in the head", "that be why knockout", "js invent the compute property", "and that be why awesome vuejs have compute property too", "because they be great for this case", "and problem , that my talk object have some property that i want to be compute", "but not simple method", "because compute property be cache and not recalculate before any of dependency property be change and something describe to these change", "i have many talk object , that be why i think about performance problem", "and the problem that i ca n't define these compute property", "because i have array of talk"], "issue_sim": [0.11273863911628723, 0.061920035630464554, 0.1562420129776001, 0.14671818912029266, 0.13050532341003418, 0.07078544050455093, 0.12765154242515564, 0.416258841753006, 0.10296821594238281, 0.15630251169204712, 0.31492793560028076, 0.2512742877006531, -0.04061518609523773, 0.40060389041900635, 0.008141015656292439, 0.5142471790313721, 0.4079829454421997, 0.1980390101671219, -0.01800452172756195], "prob": [0.0007447735406458378, 0.01300379540771246, 0.0018953316612169147, 0.002259444212540984, 0.007074733730405569, 0.00027450837660580873, 0.0003465346235316247, 0.6203529238700867, 0.00013769387442152947, 6.32094670436345e-05, 4.8119123675860465e-05, 0.00025451273540966213, 5.7111297792289406e-05, 0.002637614030390978, 2.7672700525727123e-05, 0.0032296290155500174, 0.0005388346035033464, 0.00029133824864402413, 0.0006277607171796262]}, {"target": [0], "doc": ["be n't this what <tag> do ?"], "issue_sim": [0.050964757800102234], "prob": [0.9999644756317139]}, {"target": [3], "doc": ["<tag> respond to windows key on windows / linux and command key on mac", "the same modifier be call \" super \" in electron", "<tag>  could respond to control key on windows / linux and command key on mac", "this be more common situation from the ux point of view than <tag> as windows / linux user generally use control key for the same thing that mac user use command key", "the current solution require something like this :", "with the new modifier , you could limit that to :"], "issue_sim": [0.5956685543060303, 0.19525516033172607, 0.656720757484436, 0.5786816477775574, 0.17842087149620056, 0.0662018358707428], "prob": [0.023734094575047493, 0.11123628914356232, 0.1441032737493515, 0.6866969466209412, 0.026084555312991142, 0.09546047449111938]}, {"target": [0], "doc": ["the problem be that vue as a front - end library run not only in electron - when run in browser , we can not consistently detect what os the app be run in , so we ca n't perform the platform check as you do in your first example inside the library itself .", "you will have to do it in userland code anyway", "instead , i 'd suggest create a reusable function wrapper :", "then in component that need this functionality :", "edit : maybe it be * * possible * * to sniff the os from <tag> , but i be really not sure if that be a good idea"], "issue_sim": [0.2408592849969864, 0.18943743407726288, 0.26590675115585327, 0.12371896207332611, 0.2511380910873413], "prob": [0.6045357584953308, 0.06474179774522781, 0.02242187410593033, 0.001692725345492363, 0.6296792030334473]}, {"target": [1], "doc": ["yeah , i think about browser and use <tag> but you be right", "it be get out of the framework scope and more like an idea for a plugin .", "basic wrapper for keyboardevent property be enough for the most of the case", "on the other hand , be this expect behavior of modifier or should be consider as a bug", "jsfiddle demo : <url>", "log for press <tag> <tag>", "cmd + leave press", "<tag> <tag> cmd + shift +   :", "log for press <tag> <tag>", "<tag> <tag> cmd +   :", "log for press <tag> <tag>", "cmd + leave press", "cmd + shift + leave press", "<tag> <tag> shift +   :"], "issue_sim": [0.06436650454998016, 0.1947742998600006, 0.23286311328411102, 0.21631862223148346, 0.15242961049079895, 0.03378152847290039, 0.3164637088775635, 0.3493807315826416, 0.03378152847290039, 0.2769317328929901, 0.03378152847290039, 0.3164637088775635, 0.36068421602249146, 0.2401454746723175], "prob": [0.07405200600624084, 0.3644496500492096, 0.11944432556629181, 0.38795483112335205, 0.0021376442164182663, 0.008672337979078293, 0.012296315282583237, 0.022653212770819664, 0.016620825976133347, 0.0056904517114162445, 0.005057083442807198, 0.005472701042890549, 0.016425970941781998, 0.004672847222536802]}, {"target": [0], "doc": ["i agree that this be something that would be super useful . ctrl be replace by cmd on macos ."], "issue_sim": [0.5881963968276978], "prob": [0.9999945163726807]}]}
